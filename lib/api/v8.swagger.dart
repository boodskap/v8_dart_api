// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';

import 'package:chopper/chopper.dart';

import 'client_mapping.dart';
import 'dart:async';
import 'package:http/http.dart' as http;
import 'package:http/http.dart' show MultipartFile;
import 'package:chopper/chopper.dart' as chopper;
import 'v8.enums.swagger.dart' as enums;
export 'v8.enums.swagger.dart';

part 'v8.swagger.chopper.dart';
part 'v8.swagger.g.dart';

// **************************************************************************
// SwaggerChopperGenerator
// **************************************************************************

@ChopperApi()
abstract class V8 extends ChopperService {
  static V8 create({
    ChopperClient? client,
    http.Client? httpClient,
    Authenticator? authenticator,
    ErrorConverter? errorConverter,
    Converter? converter,
    Uri? baseUrl,
    List<chopper.Interceptor>? interceptors,
  }) {
    if (client != null) {
      return _$V8(client);
    }

    final newClient = ChopperClient(
      services: [_$V8()],
      converter: converter ?? $JsonSerializableConverter(),
      interceptors: interceptors ?? [],
      client: httpClient,
      authenticator: authenticator,
      errorConverter: errorConverter,
      baseUrl: baseUrl ?? Uri.parse('http://local.boodskap.io/api'),
    );
    return _$V8(newClient);
  }

  ///Get Twin Domain info
  ///@param domainKey
  Future<chopper.Response<DomainEntityRes>> getDomainInfo({
    required String? domainKey,
  }) {
    generatedMapping.putIfAbsent(
      DomainEntityRes,
      () => DomainEntityRes.fromJsonFactory,
    );

    return _getDomainInfo(domainKey: domainKey);
  }

  ///Get Twin Domain info
  ///@param domainKey
  @Get(path: '/IoT/domain/info/{domainKey}')
  Future<chopper.Response<DomainEntityRes>> _getDomainInfo({
    @Path('domainKey') required String? domainKey,
  });

  ///Do Login
  ///@param body
  Future<chopper.Response<LoginRes>> loginUser({required Login? body}) {
    generatedMapping.putIfAbsent(Login, () => Login.fromJsonFactory);
    generatedMapping.putIfAbsent(LoginRes, () => LoginRes.fromJsonFactory);

    return _loginUser(body: body);
  }

  ///Do Login
  ///@param body
  @Post(path: '/IoT/login')
  Future<chopper.Response<LoginRes>> _loginUser({@Body() required Login? body});

  ///Do Registration
  ///@param testMode
  ///@param body
  Future<chopper.Response<RegistrationRes>> registerDomain({
    bool? testMode,
    required DomainInfo? body,
  }) {
    generatedMapping.putIfAbsent(DomainInfo, () => DomainInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      RegistrationRes,
      () => RegistrationRes.fromJsonFactory,
    );

    return _registerDomain(testMode: testMode?.toString(), body: body);
  }

  ///Do Registration
  ///@param testMode
  ///@param body
  @Post(path: '/IoT/register')
  Future<chopper.Response<RegistrationRes>> _registerDomain({
    @Header('testMode') String? testMode,
    @Body() required DomainInfo? body,
  });

  ///Do Verification
  ///@param body
  Future<chopper.Response<BaseResponse>> verifyDomainRegistrationPin({
    required VerificationReq? body,
  }) {
    generatedMapping.putIfAbsent(
      VerificationReq,
      () => VerificationReq.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _verifyDomainRegistrationPin(body: body);
  }

  ///Do Verification
  ///@param body
  @Post(path: '/IoT/registration/verify')
  Future<chopper.Response<BaseResponse>> _verifyDomainRegistrationPin({
    @Body() required VerificationReq? body,
  });

  ///Reset password
  ///@param body
  Future<chopper.Response<BaseResponse>> resetDomainRegistrationPassword({
    required ResetPassword? body,
  }) {
    generatedMapping.putIfAbsent(
      ResetPassword,
      () => ResetPassword.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _resetDomainRegistrationPassword(body: body);
  }

  ///Reset password
  ///@param body
  @Post(path: '/IoT/registration/password/reset')
  Future<chopper.Response<BaseResponse>> _resetDomainRegistrationPassword({
    @Body() required ResetPassword? body,
  });

  ///Do User Registration
  ///@param testMode
  ///@param body
  Future<chopper.Response<RegistrationRes>> registerNewUser({
    bool? testMode,
    required UserRegistration? body,
  }) {
    generatedMapping.putIfAbsent(
      UserRegistration,
      () => UserRegistration.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      RegistrationRes,
      () => RegistrationRes.fromJsonFactory,
    );

    return _registerNewUser(testMode: testMode?.toString(), body: body);
  }

  ///Do User Registration
  ///@param testMode
  ///@param body
  @Post(path: '/IoT/user/register')
  Future<chopper.Response<RegistrationRes>> _registerNewUser({
    @Header('testMode') String? testMode,
    @Body() required UserRegistration? body,
  });

  ///Do User Registration Verification
  ///@param body
  Future<chopper.Response<BaseResponse>> verifyNewUserRegistrationPin({
    required VerificationReq? body,
  }) {
    generatedMapping.putIfAbsent(
      VerificationReq,
      () => VerificationReq.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _verifyNewUserRegistrationPin(body: body);
  }

  ///Do User Registration Verification
  ///@param body
  @Post(path: '/IoT/user/registration/verify')
  Future<chopper.Response<BaseResponse>> _verifyNewUserRegistrationPin({
    @Body() required VerificationReq? body,
  });

  ///Reset newly registered user password
  ///@param body
  Future<chopper.Response<BaseResponse>> resetNewUserPassword({
    required ResetPassword? body,
  }) {
    generatedMapping.putIfAbsent(
      ResetPassword,
      () => ResetPassword.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _resetNewUserPassword(body: body);
  }

  ///Reset newly registered user password
  ///@param body
  @Post(path: '/IoT/user/registration/password/reset')
  Future<chopper.Response<BaseResponse>> _resetNewUserPassword({
    @Body() required ResetPassword? body,
  });

  ///Forgot password
  ///@param testMode
  ///@param body
  Future<chopper.Response<RegistrationRes>> forgotPassword({
    bool? testMode,
    required ForgotPassword? body,
  }) {
    generatedMapping.putIfAbsent(
      ForgotPassword,
      () => ForgotPassword.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      RegistrationRes,
      () => RegistrationRes.fromJsonFactory,
    );

    return _forgotPassword(testMode: testMode?.toString(), body: body);
  }

  ///Forgot password
  ///@param testMode
  ///@param body
  @Post(path: '/IoT/forgot/password')
  Future<chopper.Response<RegistrationRes>> _forgotPassword({
    @Header('testMode') String? testMode,
    @Body() required ForgotPassword? body,
  });

  ///Do Verification
  ///@param body
  Future<chopper.Response<BaseResponse>> verifyForgotPasswordPin({
    required VerificationReq? body,
  }) {
    generatedMapping.putIfAbsent(
      VerificationReq,
      () => VerificationReq.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _verifyForgotPasswordPin(body: body);
  }

  ///Do Verification
  ///@param body
  @Post(path: '/IoT/forgot/password/verify')
  Future<chopper.Response<BaseResponse>> _verifyForgotPasswordPin({
    @Body() required VerificationReq? body,
  });

  ///Reset forgot password
  ///@param body
  Future<chopper.Response<BaseResponse>> resetForgotPassword({
    required ResetPassword? body,
  }) {
    generatedMapping.putIfAbsent(
      ResetPassword,
      () => ResetPassword.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _resetForgotPassword(body: body);
  }

  ///Reset forgot password
  ///@param body
  @Post(path: '/IoT/forgot/password/reset')
  Future<chopper.Response<BaseResponse>> _resetForgotPassword({
    @Body() required ResetPassword? body,
  });

  ///Change password
  ///@param body
  Future<chopper.Response<BaseResponse>> changeCurrentPassword({
    required ChangePassword? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ChangePassword,
      () => ChangePassword.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _changeCurrentPassword(body: body, atoken: atoken?.toString());
  }

  ///Change password
  ///@param body
  @Post(path: '/IoT/password/change')
  Future<chopper.Response<BaseResponse>> _changeCurrentPassword({
    @Body() required ChangePassword? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Unregister account
  ///@param body
  Future<chopper.Response<BaseResponse>> unregisterAccount({
    required UnregisterAccount? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      UnregisterAccount,
      () => UnregisterAccount.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _unregisterAccount(body: body, atoken: atoken?.toString());
  }

  ///Unregister account
  ///@param body
  @Post(path: '/IoT/unregister')
  Future<chopper.Response<BaseResponse>> _unregisterAccount({
    @Body() required UnregisterAccount? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create or update configuration
  ///@param body
  Future<chopper.Response<TwinSysInfoEntityRes>> upsertTwinSysInfo({
    required TwinSysInfoBase? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinSysInfoBase,
      () => TwinSysInfoBase.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      TwinSysInfoEntityRes,
      () => TwinSysInfoEntityRes.fromJsonFactory,
    );

    return _upsertTwinSysInfo(body: body, atoken: atoken?.toString());
  }

  ///Create or update configuration
  ///@param body
  @Post(path: '/IoT/twin/sys/info/upsert')
  Future<chopper.Response<TwinSysInfoEntityRes>> _upsertTwinSysInfo({
    @Body() required TwinSysInfoBase? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get Twin system information along with other settings
  Future<chopper.Response<TwinSysInfoEntityRes>> getTwinSysInfo({
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinSysInfoEntityRes,
      () => TwinSysInfoEntityRes.fromJsonFactory,
    );

    return _getTwinSysInfo(atoken: atoken?.toString());
  }

  ///Get Twin system information along with other settings
  @Get(path: '/IoT/twin/sys/info/get')
  Future<chopper.Response<TwinSysInfoEntityRes>> _getTwinSysInfo({
    @Header('ATOKEN') String? atoken,
  });

  ///Get tag list of an entity type
  ///@param entityType
  Future<chopper.Response<TagsRes>> getTags({
    required enums.IoTTwinTagsGetEntityTypeGetEntityType? entityType,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(TagsRes, () => TagsRes.fromJsonFactory);

    return _getTags(
      entityType: entityType?.value?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Get tag list of an entity type
  ///@param entityType
  @Get(path: '/IoT/twin/tags/get/{entityType}')
  Future<chopper.Response<TagsRes>> _getTags({
    @Path('entityType') required String? entityType,
    @Header('ATOKEN') String? atoken,
  });

  ///Query using EQL
  ///@param eql
  Future<chopper.Response<QueryRes>> queryGeneric({
    required QueryReq? eql,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryGeneric(eql: eql, atoken: atoken?.toString());
  }

  ///Query using EQL
  ///@param eql
  @Post(path: '/IoT/query/generic')
  Future<chopper.Response<QueryRes>> _queryGeneric({
    @Body() required QueryReq? eql,
    @Header('ATOKEN') String? atoken,
  });

  ///Update domain
  ///@param body
  Future<chopper.Response<BaseResponse>> updateDomain({
    required DomainInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(DomainInfo, () => DomainInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _updateDomain(body: body, atoken: atoken?.toString());
  }

  ///Update domain
  ///@param body
  @Post(path: '/IoT/domain/update')
  Future<chopper.Response<BaseResponse>> _updateDomain({
    @Body() required DomainInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Change domain email
  ///@param testMode
  ///@param body
  Future<chopper.Response<RegistrationRes>> changeDomainEmail({
    bool? testMode,
    required ChangeEmail? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ChangeEmail,
      () => ChangeEmail.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      RegistrationRes,
      () => RegistrationRes.fromJsonFactory,
    );

    return _changeDomainEmail(
      testMode: testMode?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Change domain email
  ///@param testMode
  ///@param body
  @Post(path: '/IoT/domain/change/email')
  Future<chopper.Response<RegistrationRes>> _changeDomainEmail({
    @Header('testMode') String? testMode,
    @Body() required ChangeEmail? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Verify domain email change
  ///@param body
  Future<chopper.Response<BaseResponse>> verifyChangeDomainEmailPin({
    required VerificationReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      VerificationReq,
      () => VerificationReq.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _verifyChangeDomainEmailPin(body: body, atoken: atoken?.toString());
  }

  ///Verify domain email change
  ///@param body
  @Post(path: '/IoT/domain/change/email/verify')
  Future<chopper.Response<BaseResponse>> _verifyChangeDomainEmailPin({
    @Body() required VerificationReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Factory Reset
  Future<chopper.Response<BaseResponse>> factoryReset({dynamic atoken}) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _factoryReset(atoken: atoken?.toString());
  }

  ///Factory Reset
  @Delete(path: '/IoT/domain/factory/reset')
  Future<chopper.Response<BaseResponse>> _factoryReset({
    @Header('ATOKEN') String? atoken,
  });

  ///Cleanup all custom entity data
  ///@param dropIndexes drop the entire data tables and recreate them
  Future<chopper.Response<BaseResponse>> cleanupEntityData({
    bool? dropIndexes,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _cleanupEntityData(
      dropIndexes: dropIndexes?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Cleanup all custom entity data
  ///@param dropIndexes drop the entire data tables and recreate them
  @Delete(path: '/IoT/domain/clear/entities')
  Future<chopper.Response<BaseResponse>> _cleanupEntityData({
    @Header('dropIndexes') String? dropIndexes,
    @Header('ATOKEN') String? atoken,
  });

  ///Cleanup all device data
  ///@param dropIndexes drop the entire data tables and recreate them
  ///@param modelId provide this to delete only the data belongs to this model
  ///@param deviceId provide this to delete only the data belongs to this device
  Future<chopper.Response<BaseResponse>> cleanupDeviceData({
    bool? dropIndexes,
    String? modelId,
    String? deviceId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _cleanupDeviceData(
      dropIndexes: dropIndexes?.toString(),
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Cleanup all device data
  ///@param dropIndexes drop the entire data tables and recreate them
  ///@param modelId provide this to delete only the data belongs to this model
  ///@param deviceId provide this to delete only the data belongs to this device
  @Delete(path: '/IoT/clear/data')
  Future<chopper.Response<BaseResponse>> _cleanupDeviceData({
    @Header('dropIndexes') String? dropIndexes,
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Header('ATOKEN') String? atoken,
  });

  ///Close Account
  Future<chopper.Response<BaseResponse>> closeAccount({dynamic atoken}) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _closeAccount(atoken: atoken?.toString());
  }

  ///Close Account
  @Delete(path: '/IoT/domain/close')
  Future<chopper.Response<BaseResponse>> _closeAccount({
    @Header('ATOKEN') String? atoken,
  });

  ///Get the most recent data for this device
  ///@param deviceId
  ///@param isHardwareDevice
  Future<chopper.Response<DeviceDataEntityRes>> getDeviceData({
    required String? deviceId,
    bool? isHardwareDevice,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceDataEntityRes,
      () => DeviceDataEntityRes.fromJsonFactory,
    );

    return _getDeviceData(
      deviceId: deviceId,
      isHardwareDevice: isHardwareDevice?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Get the most recent data for this device
  ///@param deviceId
  ///@param isHardwareDevice
  @Get(path: '/DeviceData/get/{deviceId}')
  Future<chopper.Response<DeviceDataEntityRes>> _getDeviceData({
    @Path('deviceId') required String? deviceId,
    @Header('isHardwareDevice') String? isHardwareDevice,
    @Header('ATOKEN') String? atoken,
  });

  ///Search recent device data
  ///@param modelId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetId
  ///@param filterByLocation
  ///@param body
  Future<chopper.Response<DeviceDataArrayRes>> searchRecentDeviceData({
    String? modelId,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? assetId,
    bool? filterByLocation,
    required FilterSearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceDataArrayRes,
      () => DeviceDataArrayRes.fromJsonFactory,
    );

    return _searchRecentDeviceData(
      modelId: modelId?.toString(),
      premiseId: premiseId?.toString(),
      facilityId: facilityId?.toString(),
      floorId: floorId?.toString(),
      assetId: assetId?.toString(),
      filterByLocation: filterByLocation?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search recent device data
  ///@param modelId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetId
  ///@param filterByLocation
  ///@param body
  @Post(path: '/DeviceData/recent')
  Future<chopper.Response<DeviceDataArrayRes>> _searchRecentDeviceData({
    @Header('modelId') String? modelId,
    @Header('premiseId') String? premiseId,
    @Header('facilityId') String? facilityId,
    @Header('floorId') String? floorId,
    @Header('assetId') String? assetId,
    @Header('filterByLocation') String? filterByLocation,
    @Body() required FilterSearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search device history data
  ///@param deviceId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetId
  ///@param filterByLocation
  ///@param body
  Future<chopper.Response<DeviceDataArrayRes>> searchDeviceHistoryData({
    String? deviceId,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? assetId,
    bool? filterByLocation,
    required FilterSearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceDataArrayRes,
      () => DeviceDataArrayRes.fromJsonFactory,
    );

    return _searchDeviceHistoryData(
      deviceId: deviceId?.toString(),
      premiseId: premiseId?.toString(),
      facilityId: facilityId?.toString(),
      floorId: floorId?.toString(),
      assetId: assetId?.toString(),
      filterByLocation: filterByLocation?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search device history data
  ///@param deviceId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetId
  ///@param filterByLocation
  ///@param body
  @Post(path: '/DeviceData/history/search')
  Future<chopper.Response<DeviceDataArrayRes>> _searchDeviceHistoryData({
    @Header('deviceId') String? deviceId,
    @Header('premiseId') String? premiseId,
    @Header('facilityId') String? facilityId,
    @Header('floorId') String? floorId,
    @Header('assetId') String? assetId,
    @Header('filterByLocation') String? filterByLocation,
    @Body() required FilterSearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Remove history data record
  ///@param recordId
  Future<chopper.Response<DeviceDataEntityRes>> removeHistoryDataRecord({
    required String? recordId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceDataEntityRes,
      () => DeviceDataEntityRes.fromJsonFactory,
    );

    return _removeHistoryDataRecord(
      recordId: recordId,
      atoken: atoken?.toString(),
    );
  }

  ///Remove history data record
  ///@param recordId
  @Delete(path: '/DeviceData/history/remove/{recordId}')
  Future<chopper.Response<DeviceDataEntityRes>> _removeHistoryDataRecord({
    @Path('recordId') required String? recordId,
    @Header('ATOKEN') String? atoken,
  });

  ///Send device data
  ///@param hardwareDeviceId hardware device id
  ///@param body
  Future<chopper.Response<BaseResponse>> sendDeviceData({
    String? hardwareDeviceId,
    required Object? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _sendDeviceData(
      hardwareDeviceId: hardwareDeviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Send device data
  ///@param hardwareDeviceId hardware device id
  ///@param body
  @Post(path: '/DeviceData/send')
  Future<chopper.Response<BaseResponse>> _sendDeviceData({
    @Header('hardwareDeviceId') String? hardwareDeviceId,
    @Body() required Object? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Send device data
  ///@param hardwareDeviceId hardware device id
  ///@param geocode do reverse geocoding
  ///@param lon longitude
  ///@param lat latitide
  ///@param body
  Future<chopper.Response<BaseResponse>> sendDeviceLocationData({
    String? hardwareDeviceId,
    bool? geocode,
    required num? lon,
    required num? lat,
    Object? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _sendDeviceLocationData(
      hardwareDeviceId: hardwareDeviceId?.toString(),
      geocode: geocode?.toString(),
      lon: lon,
      lat: lat,
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Send device data
  ///@param hardwareDeviceId hardware device id
  ///@param geocode do reverse geocoding
  ///@param lon longitude
  ///@param lat latitide
  ///@param body
  @Post(path: '/DeviceData/location/send/{lon}/{lat}')
  Future<chopper.Response<BaseResponse>> _sendDeviceLocationData({
    @Header('hardwareDeviceId') String? hardwareDeviceId,
    @Header('geocode') String? geocode,
    @Path('lon') required num? lon,
    @Path('lat') required num? lat,
    @Body() Object? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search triggered events
  ///@param modelId
  ///@param deviceId
  ///@param userId
  ///@param assetId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param body
  Future<chopper.Response<TriggeredEventArrayRes>> seearchTriggeredEvents({
    String? modelId,
    String? deviceId,
    String? userId,
    String? assetId,
    String? premiseId,
    String? facilityId,
    String? floorId,
    required FilterSearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TriggeredEventArrayRes,
      () => TriggeredEventArrayRes.fromJsonFactory,
    );

    return _seearchTriggeredEvents(
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      userId: userId?.toString(),
      assetId: assetId?.toString(),
      premiseId: premiseId?.toString(),
      facilityId: facilityId?.toString(),
      floorId: floorId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search triggered events
  ///@param modelId
  ///@param deviceId
  ///@param userId
  ///@param assetId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param body
  @Post(path: '/DeviceData/triggered/events/search')
  Future<chopper.Response<TriggeredEventArrayRes>> _seearchTriggeredEvents({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Header('userId') String? userId,
    @Header('assetId') String? assetId,
    @Header('premiseId') String? premiseId,
    @Header('facilityId') String? facilityId,
    @Header('floorId') String? floorId,
    @Body() required FilterSearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search triggered controls
  ///@param modelId
  ///@param deviceId
  ///@param body
  Future<chopper.Response<TriggeredControlArrayRes>> seearchTriggeredControls({
    String? modelId,
    String? deviceId,
    required FilterSearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TriggeredControlArrayRes,
      () => TriggeredControlArrayRes.fromJsonFactory,
    );

    return _seearchTriggeredControls(
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search triggered controls
  ///@param modelId
  ///@param deviceId
  ///@param body
  @Post(path: '/DeviceData/triggered/controls/search')
  Future<chopper.Response<TriggeredControlArrayRes>> _seearchTriggeredControls({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Body() required FilterSearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Cleanup entire data
  ///@param deviceId
  ///@param field
  ///@param filter
  ///@param interval
  ///@param beginStamp required if filter is set
  ///@param endStamp required if filter is set
  ///@param tz Timezone
  Future<chopper.Response<TrendValueArrayRes>> getDeviceTrends({
    required String? deviceId,
    required String? field,
    enums.DeviceDataTrendsDeviceIdFieldGetFilter? filter,
    enums.DeviceDataTrendsDeviceIdFieldGetInterval? interval,
    int? beginStamp,
    int? endStamp,
    String? tz,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TrendValueArrayRes,
      () => TrendValueArrayRes.fromJsonFactory,
    );

    return _getDeviceTrends(
      deviceId: deviceId,
      field: field,
      filter: filter?.value?.toString(),
      interval: interval?.value?.toString(),
      beginStamp: beginStamp?.toString(),
      endStamp: endStamp?.toString(),
      tz: tz?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Cleanup entire data
  ///@param deviceId
  ///@param field
  ///@param filter
  ///@param interval
  ///@param beginStamp required if filter is set
  ///@param endStamp required if filter is set
  ///@param tz Timezone
  @Get(path: '/DeviceData/trends/{deviceId}/{field}')
  Future<chopper.Response<TrendValueArrayRes>> _getDeviceTrends({
    @Path('deviceId') required String? deviceId,
    @Path('field') required String? field,
    @Header('filter') String? filter,
    @Header('interval') String? interval,
    @Header('beginStamp') String? beginStamp,
    @Header('endStamp') String? endStamp,
    @Header('tz') String? tz,
    @Header('ATOKEN') String? atoken,
  });

  ///Cleanup entire data
  ///@param deviceId
  ///@param field
  ///@param page
  ///@param size
  ///@param filter
  ///@param beginStamp required if filter is set
  ///@param endStamp required if filter is set
  ///@param tz Timezone
  Future<chopper.Response<TimeSeriesValueArrayRes>> getDeviceTimeSeries({
    required String? deviceId,
    required String? field,
    required int? page,
    required int? size,
    enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter? filter,
    int? beginStamp,
    int? endStamp,
    String? tz,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TimeSeriesValueArrayRes,
      () => TimeSeriesValueArrayRes.fromJsonFactory,
    );

    return _getDeviceTimeSeries(
      deviceId: deviceId,
      field: field,
      page: page,
      size: size,
      filter: filter?.value?.toString(),
      beginStamp: beginStamp?.toString(),
      endStamp: endStamp?.toString(),
      tz: tz?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Cleanup entire data
  ///@param deviceId
  ///@param field
  ///@param page
  ///@param size
  ///@param filter
  ///@param beginStamp required if filter is set
  ///@param endStamp required if filter is set
  ///@param tz Timezone
  @Get(path: '/DeviceData/series/{deviceId}/{field}/{page}/{size}')
  Future<chopper.Response<TimeSeriesValueArrayRes>> _getDeviceTimeSeries({
    @Path('deviceId') required String? deviceId,
    @Path('field') required String? field,
    @Path('page') required int? page,
    @Path('size') required int? size,
    @Header('filter') String? filter,
    @Header('beginStamp') String? beginStamp,
    @Header('endStamp') String? endStamp,
    @Header('tz') String? tz,
    @Header('ATOKEN') String? atoken,
  });

  ///Filter recent device data
  ///@param page
  ///@param size
  ///@param filterId
  Future<chopper.Response<DeviceDataArrayRes>> filterRecentDeviceData({
    int? page,
    int? size,
    required String? filterId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceDataArrayRes,
      () => DeviceDataArrayRes.fromJsonFactory,
    );

    return _filterRecentDeviceData(
      page: page?.toString(),
      size: size?.toString(),
      filterId: filterId,
      atoken: atoken?.toString(),
    );
  }

  ///Filter recent device data
  ///@param page
  ///@param size
  ///@param filterId
  @Get(path: '/DeviceData/filter/{filterId}')
  Future<chopper.Response<DeviceDataArrayRes>> _filterRecentDeviceData({
    @Header('page') String? page,
    @Header('size') String? size,
    @Path('filterId') required String? filterId,
    @Header('ATOKEN') String? atoken,
  });

  ///Get reported asset ids
  ///@param size
  Future<chopper.Response<IDListEntityRes>> getReportedAssetIds({
    required int? size,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      IDListEntityRes,
      () => IDListEntityRes.fromJsonFactory,
    );

    return _getReportedAssetIds(size: size, atoken: atoken?.toString());
  }

  ///Get reported asset ids
  ///@param size
  @Get(path: '/DeviceData/reported/assets/{size}')
  Future<chopper.Response<IDListEntityRes>> _getReportedAssetIds({
    @Path('size') required int? size,
    @Header('ATOKEN') String? atoken,
  });

  ///Search reported assets
  ///@param search
  Future<chopper.Response<IDListEntityRes>> searchReportedAssets({
    required SearchReq? search,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      IDListEntityRes,
      () => IDListEntityRes.fromJsonFactory,
    );

    return _searchReportedAssets(search: search, atoken: atoken?.toString());
  }

  ///Search reported assets
  ///@param search
  @Post(path: '/DeviceData/search/reported/assets')
  Future<chopper.Response<IDListEntityRes>> _searchReportedAssets({
    @Body() required SearchReq? search,
    @Header('ATOKEN') String? atoken,
  });

  ///Field filter recent device data
  ///@param page
  ///@param size
  ///@param fieldFilterId
  Future<chopper.Response<DeviceDataArrayRes>> fieldFilterRecentDeviceData({
    int? page,
    int? size,
    required String? fieldFilterId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceDataArrayRes,
      () => DeviceDataArrayRes.fromJsonFactory,
    );

    return _fieldFilterRecentDeviceData(
      page: page?.toString(),
      size: size?.toString(),
      fieldFilterId: fieldFilterId,
      atoken: atoken?.toString(),
    );
  }

  ///Field filter recent device data
  ///@param page
  ///@param size
  ///@param fieldFilterId
  @Get(path: '/DeviceData/field/filter/{fieldFilterId}')
  Future<chopper.Response<DeviceDataArrayRes>> _fieldFilterRecentDeviceData({
    @Header('page') String? page,
    @Header('size') String? size,
    @Path('fieldFilterId') required String? fieldFilterId,
    @Header('ATOKEN') String? atoken,
  });

  ///query data
  ///@param body
  Future<chopper.Response<QueryRes>> queryDeviceData({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDeviceData(body: body, atoken: atoken?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/DeviceData/query')
  Future<chopper.Response<QueryRes>> _queryDeviceData({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///query history data
  ///@param body
  Future<chopper.Response<QueryRes>> queryDeviceHistoryData({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDeviceHistoryData(body: body, atoken: atoken?.toString());
  }

  ///query history data
  ///@param body
  @Post(path: '/DeviceData/history/query')
  Future<chopper.Response<QueryRes>> _queryDeviceHistoryData({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Field filter recent device data
  ///@param page
  ///@param size
  ///@param alarmId
  Future<chopper.Response<DeviceDataArrayRes>> alarmFilterRecentDeviceData({
    int? page,
    int? size,
    required String? alarmId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceDataArrayRes,
      () => DeviceDataArrayRes.fromJsonFactory,
    );

    return _alarmFilterRecentDeviceData(
      page: page?.toString(),
      size: size?.toString(),
      alarmId: alarmId,
      atoken: atoken?.toString(),
    );
  }

  ///Field filter recent device data
  ///@param page
  ///@param size
  ///@param alarmId
  @Get(path: '/DeviceData/alarm/filter/{alarmId}')
  Future<chopper.Response<DeviceDataArrayRes>> _alarmFilterRecentDeviceData({
    @Header('page') String? page,
    @Header('size') String? size,
    @Path('alarmId') required String? alarmId,
    @Header('ATOKEN') String? atoken,
  });

  ///Field filter recent device data
  ///@param page
  ///@param size
  ///@param eventId
  Future<chopper.Response<DeviceDataArrayRes>> eventFilterRecentDeviceData({
    int? page,
    int? size,
    required String? eventId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceDataArrayRes,
      () => DeviceDataArrayRes.fromJsonFactory,
    );

    return _eventFilterRecentDeviceData(
      page: page?.toString(),
      size: size?.toString(),
      eventId: eventId,
      atoken: atoken?.toString(),
    );
  }

  ///Field filter recent device data
  ///@param page
  ///@param size
  ///@param eventId
  @Get(path: '/DeviceData/event/filter/{eventId}')
  Future<chopper.Response<DeviceDataArrayRes>> _eventFilterRecentDeviceData({
    @Header('page') String? page,
    @Header('size') String? size,
    @Path('eventId') required String? eventId,
    @Header('ATOKEN') String? atoken,
  });

  ///reprocess device data
  ///@param body
  Future<chopper.Response<BaseResponse>> reprocessDeviceData({
    required ReprocessInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ReprocessInfo,
      () => ReprocessInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _reprocessDeviceData(body: body, atoken: atoken?.toString());
  }

  ///reprocess device data
  ///@param body
  @Post(path: '/DeviceData/reprocess')
  Future<chopper.Response<BaseResponse>> _reprocessDeviceData({
    @Body() required ReprocessInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///list non reporting
  ///@param body
  Future<chopper.Response<DeviceDataArrayRes>> listNonReporting({
    required NonReportingReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      NonReportingReq,
      () => NonReportingReq.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DeviceDataArrayRes,
      () => DeviceDataArrayRes.fromJsonFactory,
    );

    return _listNonReporting(body: body, atoken: atoken?.toString());
  }

  ///list non reporting
  ///@param body
  @Post(path: '/DeviceData/list/nonreporting')
  Future<chopper.Response<DeviceDataArrayRes>> _listNonReporting({
    @Body() required NonReportingReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search reported assets
  ///@param search
  Future<chopper.Response<QueryRes>> quryReportedAssets({
    required QueryReq? search,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _quryReportedAssets(search: search, atoken: atoken?.toString());
  }

  ///Search reported assets
  ///@param search
  @Post(path: '/DeviceData/query/reported/assets')
  Future<chopper.Response<QueryRes>> _quryReportedAssets({
    @Body() required QueryReq? search,
    @Header('ATOKEN') String? atoken,
  });

  ///Create device view
  ///@param body
  Future<chopper.Response<DeviceViewEntityRes>> createDeviceView({
    required DeviceViewInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceViewInfo,
      () => DeviceViewInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DeviceViewEntityRes,
      () => DeviceViewEntityRes.fromJsonFactory,
    );

    return _createDeviceView(body: body, atoken: atoken?.toString());
  }

  ///Create device view
  ///@param body
  @Post(path: '/DeviceView/create')
  Future<chopper.Response<DeviceViewEntityRes>> _createDeviceView({
    @Body() required DeviceViewInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update device view
  ///@param deviceViewId
  ///@param body
  Future<chopper.Response<DeviceViewEntityRes>> updateDeviceView({
    String? deviceViewId,
    required DeviceViewInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceViewInfo,
      () => DeviceViewInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DeviceViewEntityRes,
      () => DeviceViewEntityRes.fromJsonFactory,
    );

    return _updateDeviceView(
      deviceViewId: deviceViewId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update device view
  ///@param deviceViewId
  ///@param body
  @Post(path: '/DeviceView/update')
  Future<chopper.Response<DeviceViewEntityRes>> _updateDeviceView({
    @Header('deviceViewId') String? deviceViewId,
    @Body() required DeviceViewInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete device view
  ///@param deviceViewId
  Future<chopper.Response<DeviceViewEntityRes>> deleteDeviceView({
    String? deviceViewId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceViewEntityRes,
      () => DeviceViewEntityRes.fromJsonFactory,
    );

    return _deleteDeviceView(
      deviceViewId: deviceViewId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete device view
  ///@param deviceViewId
  @Delete(path: '/DeviceView/remove')
  Future<chopper.Response<DeviceViewEntityRes>> _deleteDeviceView({
    @Header('deviceViewId') String? deviceViewId,
    @Header('ATOKEN') String? atoken,
  });

  ///List device views
  ///@param modelId
  ///@param body
  Future<chopper.Response<DeviceViewArrayRes>> listDeviceViews({
    String? modelId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DeviceViewArrayRes,
      () => DeviceViewArrayRes.fromJsonFactory,
    );

    return _listDeviceViews(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List device views
  ///@param modelId
  ///@param body
  @Post(path: '/DeviceView/list')
  Future<chopper.Response<DeviceViewArrayRes>> _listDeviceViews({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search device views
  ///@param modelId
  ///@param body
  Future<chopper.Response<DeviceViewArrayRes>> searchDeviceViews({
    String? modelId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceViewArrayRes,
      () => DeviceViewArrayRes.fromJsonFactory,
    );

    return _searchDeviceViews(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search device views
  ///@param modelId
  ///@param body
  @Post(path: '/DeviceView/search')
  Future<chopper.Response<DeviceViewArrayRes>> _searchDeviceViews({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get device views
  ///@param body
  Future<chopper.Response<DeviceViewArrayRes>> getDeviceViews({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DeviceViewArrayRes,
      () => DeviceViewArrayRes.fromJsonFactory,
    );

    return _getDeviceViews(body: body, atoken: atoken?.toString());
  }

  ///Get device views
  ///@param body
  @Post(path: '/DeviceView/get')
  Future<chopper.Response<DeviceViewArrayRes>> _getDeviceViews({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get device view by id
  ///@param deviceViewId
  Future<chopper.Response<DeviceViewEntityRes>> getDeviceView({
    required String? deviceViewId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceViewEntityRes,
      () => DeviceViewEntityRes.fromJsonFactory,
    );

    return _getDeviceView(
      deviceViewId: deviceViewId,
      atoken: atoken?.toString(),
    );
  }

  ///get device view by id
  ///@param deviceViewId
  @Get(path: '/DeviceView/one/{deviceViewId}')
  Future<chopper.Response<DeviceViewEntityRes>> _getDeviceView({
    @Path('deviceViewId') required String? deviceViewId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search device views
  ///@param body
  Future<chopper.Response<QueryRes>> queryDeviceViews({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDeviceViews(body: body, atoken: atoken?.toString());
  }

  ///Search device views
  ///@param body
  @Post(path: '/DeviceView/query')
  Future<chopper.Response<QueryRes>> _queryDeviceViews({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create dashboard screen
  ///@param body
  Future<chopper.Response<DashboardScreenEntityRes>> createDashboardScreen({
    required DashboardScreenInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DashboardScreenInfo,
      () => DashboardScreenInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DashboardScreenEntityRes,
      () => DashboardScreenEntityRes.fromJsonFactory,
    );

    return _createDashboardScreen(body: body, atoken: atoken?.toString());
  }

  ///Create dashboard screen
  ///@param body
  @Post(path: '/DashboardScreen/create')
  Future<chopper.Response<DashboardScreenEntityRes>> _createDashboardScreen({
    @Body() required DashboardScreenInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update dashboard screen
  ///@param screenId
  ///@param body
  Future<chopper.Response<DashboardScreenEntityRes>> updateDashboardScreen({
    String? screenId,
    required DashboardScreenInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DashboardScreenInfo,
      () => DashboardScreenInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DashboardScreenEntityRes,
      () => DashboardScreenEntityRes.fromJsonFactory,
    );

    return _updateDashboardScreen(
      screenId: screenId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update dashboard screen
  ///@param screenId
  ///@param body
  @Post(path: '/DashboardScreen/update')
  Future<chopper.Response<DashboardScreenEntityRes>> _updateDashboardScreen({
    @Header('screenId') String? screenId,
    @Body() required DashboardScreenInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete dashboard screen
  ///@param screenId
  Future<chopper.Response<DashboardScreenEntityRes>> deleteDashboardScreen({
    String? screenId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DashboardScreenEntityRes,
      () => DashboardScreenEntityRes.fromJsonFactory,
    );

    return _deleteDashboardScreen(
      screenId: screenId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete dashboard screen
  ///@param screenId
  @Delete(path: '/DashboardScreen/remove')
  Future<chopper.Response<DashboardScreenEntityRes>> _deleteDashboardScreen({
    @Header('screenId') String? screenId,
    @Header('ATOKEN') String? atoken,
  });

  ///List dashboard screens
  ///@param modelId
  ///@param body
  Future<chopper.Response<DashboardScreenArrayRes>> listDashboardScreens({
    String? modelId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DashboardScreenArrayRes,
      () => DashboardScreenArrayRes.fromJsonFactory,
    );

    return _listDashboardScreens(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List dashboard screens
  ///@param modelId
  ///@param body
  @Post(path: '/DashboardScreen/list')
  Future<chopper.Response<DashboardScreenArrayRes>> _listDashboardScreens({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search dashboard screens
  ///@param modelId
  ///@param body
  Future<chopper.Response<DashboardScreenArrayRes>> searchDashboardScreens({
    String? modelId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DashboardScreenArrayRes,
      () => DashboardScreenArrayRes.fromJsonFactory,
    );

    return _searchDashboardScreens(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search dashboard screens
  ///@param modelId
  ///@param body
  @Post(path: '/DashboardScreen/search')
  Future<chopper.Response<DashboardScreenArrayRes>> _searchDashboardScreens({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get dashboard screens
  ///@param body
  Future<chopper.Response<DashboardScreenArrayRes>> getDashboardScreens({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DashboardScreenArrayRes,
      () => DashboardScreenArrayRes.fromJsonFactory,
    );

    return _getDashboardScreens(body: body, atoken: atoken?.toString());
  }

  ///Get dashboard screens
  ///@param body
  @Post(path: '/DashboardScreen/get')
  Future<chopper.Response<DashboardScreenArrayRes>> _getDashboardScreens({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get dashboard screen by id
  ///@param screenId
  Future<chopper.Response<DashboardScreenEntityRes>> getDashboardScreen({
    required String? screenId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DashboardScreenEntityRes,
      () => DashboardScreenEntityRes.fromJsonFactory,
    );

    return _getDashboardScreen(screenId: screenId, atoken: atoken?.toString());
  }

  ///get dashboard screen by id
  ///@param screenId
  @Get(path: '/DashboardScreen/one/{screenId}')
  Future<chopper.Response<DashboardScreenEntityRes>> _getDashboardScreen({
    @Path('screenId') required String? screenId,
    @Header('ATOKEN') String? atoken,
  });

  ///count
  Future<chopper.Response<CountRes>> countDashboards({dynamic atoken}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countDashboards(atoken: atoken?.toString());
  }

  ///count
  @Get(path: '/DashboardScreen/count')
  Future<chopper.Response<CountRes>> _countDashboards({
    @Header('ATOKEN') String? atoken,
  });

  ///Search dashboard screens
  ///@param body
  Future<chopper.Response<QueryRes>> queryDashboardScreens({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDashboardScreens(body: body, atoken: atoken?.toString());
  }

  ///Search dashboard screens
  ///@param body
  @Post(path: '/DashboardScreen/query')
  Future<chopper.Response<QueryRes>> _queryDashboardScreens({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create dashboard menu
  ///@param body
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
  createDashboardMenuGroup({
    required DashboardMenuGroupInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DashboardMenuGroupInfo,
      () => DashboardMenuGroupInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DashboardMenuGroupEntityRes,
      () => DashboardMenuGroupEntityRes.fromJsonFactory,
    );

    return _createDashboardMenuGroup(body: body, atoken: atoken?.toString());
  }

  ///Create dashboard menu
  ///@param body
  @Post(path: '/DashboardMenu/create')
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
  _createDashboardMenuGroup({
    @Body() required DashboardMenuGroupInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update dashboard menu
  ///@param menuGroupId
  ///@param body
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
  updateDashboardMenuGroup({
    String? menuGroupId,
    required DashboardMenuGroupInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DashboardMenuGroupInfo,
      () => DashboardMenuGroupInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DashboardMenuGroupEntityRes,
      () => DashboardMenuGroupEntityRes.fromJsonFactory,
    );

    return _updateDashboardMenuGroup(
      menuGroupId: menuGroupId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update dashboard menu
  ///@param menuGroupId
  ///@param body
  @Post(path: '/DashboardMenu/update')
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
  _updateDashboardMenuGroup({
    @Header('menuGroupId') String? menuGroupId,
    @Body() required DashboardMenuGroupInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete dashboard menu
  ///@param menuGroupId
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
  deleteDashboardMenuGroup({String? menuGroupId, dynamic atoken}) {
    generatedMapping.putIfAbsent(
      DashboardMenuGroupEntityRes,
      () => DashboardMenuGroupEntityRes.fromJsonFactory,
    );

    return _deleteDashboardMenuGroup(
      menuGroupId: menuGroupId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete dashboard menu
  ///@param menuGroupId
  @Delete(path: '/DashboardMenu/remove')
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
  _deleteDashboardMenuGroup({
    @Header('menuGroupId') String? menuGroupId,
    @Header('ATOKEN') String? atoken,
  });

  ///List dashboard menus
  ///@param modelId
  ///@param body
  Future<chopper.Response<DashboardMenuGroupArrayRes>> listDashboardMenuGroups({
    String? modelId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DashboardMenuGroupArrayRes,
      () => DashboardMenuGroupArrayRes.fromJsonFactory,
    );

    return _listDashboardMenuGroups(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List dashboard menus
  ///@param modelId
  ///@param body
  @Post(path: '/DashboardMenu/list')
  Future<chopper.Response<DashboardMenuGroupArrayRes>>
  _listDashboardMenuGroups({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search dashboard menus
  ///@param body
  Future<chopper.Response<DashboardMenuGroupArrayRes>>
  searchDashboardMenuGroups({required SearchReq? body, dynamic atoken}) {
    generatedMapping.putIfAbsent(
      DashboardMenuGroupArrayRes,
      () => DashboardMenuGroupArrayRes.fromJsonFactory,
    );

    return _searchDashboardMenuGroups(body: body, atoken: atoken?.toString());
  }

  ///Search dashboard menus
  ///@param body
  @Post(path: '/DashboardMenu/search')
  Future<chopper.Response<DashboardMenuGroupArrayRes>>
  _searchDashboardMenuGroups({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get dashboard menus
  ///@param body
  Future<chopper.Response<DashboardMenuGroupArrayRes>> getDashboardMenuGroups({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DashboardMenuGroupArrayRes,
      () => DashboardMenuGroupArrayRes.fromJsonFactory,
    );

    return _getDashboardMenuGroups(body: body, atoken: atoken?.toString());
  }

  ///Get dashboard menus
  ///@param body
  @Post(path: '/DashboardMenu/get')
  Future<chopper.Response<DashboardMenuGroupArrayRes>> _getDashboardMenuGroups({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get dashboard menu by id
  ///@param menuGroupId
  Future<chopper.Response<DashboardMenuGroupEntityRes>> getDashboardMenuGroup({
    required String? menuGroupId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DashboardMenuGroupEntityRes,
      () => DashboardMenuGroupEntityRes.fromJsonFactory,
    );

    return _getDashboardMenuGroup(
      menuGroupId: menuGroupId,
      atoken: atoken?.toString(),
    );
  }

  ///get dashboard menu by id
  ///@param menuGroupId
  @Get(path: '/DashboardMenu/one/{menuGroupId}')
  Future<chopper.Response<DashboardMenuGroupEntityRes>> _getDashboardMenuGroup({
    @Path('menuGroupId') required String? menuGroupId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search dashboard menus
  ///@param body
  Future<chopper.Response<QueryRes>> queryDashboardMenuGroups({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDashboardMenuGroups(body: body, atoken: atoken?.toString());
  }

  ///Search dashboard menus
  ///@param body
  @Post(path: '/DashboardMenu/query')
  Future<chopper.Response<QueryRes>> _queryDashboardMenuGroups({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create event registration
  ///@param body
  Future<chopper.Response<EventRegistrationEntityRes>> createEventRegistration({
    required EventRegistrationInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EventRegistrationInfo,
      () => EventRegistrationInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      EventRegistrationEntityRes,
      () => EventRegistrationEntityRes.fromJsonFactory,
    );

    return _createEventRegistration(body: body, atoken: atoken?.toString());
  }

  ///Create event registration
  ///@param body
  @Post(path: '/EventRegistration/create')
  Future<chopper.Response<EventRegistrationEntityRes>>
  _createEventRegistration({
    @Body() required EventRegistrationInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update event registration
  ///@param eventRegistrationId
  ///@param body
  Future<chopper.Response<EventRegistrationEntityRes>> updateEventRegistration({
    String? eventRegistrationId,
    required EventRegistrationInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EventRegistrationInfo,
      () => EventRegistrationInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      EventRegistrationEntityRes,
      () => EventRegistrationEntityRes.fromJsonFactory,
    );

    return _updateEventRegistration(
      eventRegistrationId: eventRegistrationId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update event registration
  ///@param eventRegistrationId
  ///@param body
  @Post(path: '/EventRegistration/update')
  Future<chopper.Response<EventRegistrationEntityRes>>
  _updateEventRegistration({
    @Header('eventRegistrationId') String? eventRegistrationId,
    @Body() required EventRegistrationInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete event registration
  ///@param eventRegistrationId
  Future<chopper.Response<EventRegistrationEntityRes>> deleteEventRegistration({
    String? eventRegistrationId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EventRegistrationEntityRes,
      () => EventRegistrationEntityRes.fromJsonFactory,
    );

    return _deleteEventRegistration(
      eventRegistrationId: eventRegistrationId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete event registration
  ///@param eventRegistrationId
  @Delete(path: '/EventRegistration/remove')
  Future<chopper.Response<EventRegistrationEntityRes>>
  _deleteEventRegistration({
    @Header('eventRegistrationId') String? eventRegistrationId,
    @Header('ATOKEN') String? atoken,
  });

  ///List event registrations
  ///@param body
  Future<chopper.Response<EventRegistrationArrayRes>> listEventRegistrations({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      EventRegistrationArrayRes,
      () => EventRegistrationArrayRes.fromJsonFactory,
    );

    return _listEventRegistrations(body: body, atoken: atoken?.toString());
  }

  ///List event registrations
  ///@param body
  @Post(path: '/EventRegistration/list')
  Future<chopper.Response<EventRegistrationArrayRes>> _listEventRegistrations({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create device model
  ///@param body
  Future<chopper.Response<DeviceModelEntityRes>> createDeviceModel({
    required DeviceModelInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceModelInfo,
      () => DeviceModelInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DeviceModelEntityRes,
      () => DeviceModelEntityRes.fromJsonFactory,
    );

    return _createDeviceModel(body: body, atoken: atoken?.toString());
  }

  ///Create device model
  ///@param body
  @Post(path: '/DeviceModel/create')
  Future<chopper.Response<DeviceModelEntityRes>> _createDeviceModel({
    @Body() required DeviceModelInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update device model
  ///@param modelId
  ///@param body
  Future<chopper.Response<DeviceModelEntityRes>> updateDeviceModel({
    String? modelId,
    required DeviceModelInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceModelInfo,
      () => DeviceModelInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DeviceModelEntityRes,
      () => DeviceModelEntityRes.fromJsonFactory,
    );

    return _updateDeviceModel(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update device model
  ///@param modelId
  ///@param body
  @Post(path: '/DeviceModel/update')
  Future<chopper.Response<DeviceModelEntityRes>> _updateDeviceModel({
    @Header('modelId') String? modelId,
    @Body() required DeviceModelInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete device model
  ///@param modelId
  Future<chopper.Response<DeviceModelEntityRes>> deleteDeviceModel({
    String? modelId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceModelEntityRes,
      () => DeviceModelEntityRes.fromJsonFactory,
    );

    return _deleteDeviceModel(
      modelId: modelId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete device model
  ///@param modelId
  @Delete(path: '/DeviceModel/remove')
  Future<chopper.Response<DeviceModelEntityRes>> _deleteDeviceModel({
    @Header('modelId') String? modelId,
    @Header('ATOKEN') String? atoken,
  });

  ///List device models
  ///@param body
  Future<chopper.Response<DeviceModelArrayRes>> listDeviceModels({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DeviceModelArrayRes,
      () => DeviceModelArrayRes.fromJsonFactory,
    );

    return _listDeviceModels(body: body, atoken: atoken?.toString());
  }

  ///List device models
  ///@param body
  @Post(path: '/DeviceModel/list')
  Future<chopper.Response<DeviceModelArrayRes>> _listDeviceModels({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search device models
  ///@param body
  Future<chopper.Response<DeviceModelArrayRes>> searchDeviceModels({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceModelArrayRes,
      () => DeviceModelArrayRes.fromJsonFactory,
    );

    return _searchDeviceModels(body: body, atoken: atoken?.toString());
  }

  ///Search device models
  ///@param body
  @Post(path: '/DeviceModel/search')
  Future<chopper.Response<DeviceModelArrayRes>> _searchDeviceModels({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get device models by list of id's
  ///@param body
  Future<chopper.Response<DeviceModelArrayRes>> getDeviceModels({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DeviceModelArrayRes,
      () => DeviceModelArrayRes.fromJsonFactory,
    );

    return _getDeviceModels(body: body, atoken: atoken?.toString());
  }

  ///get device models by list of id's
  ///@param body
  @Post(path: '/DeviceModel/get')
  Future<chopper.Response<DeviceModelArrayRes>> _getDeviceModels({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get device models by id
  ///@param modelId
  Future<chopper.Response<DeviceModelEntityRes>> getDeviceModel({
    required String? modelId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceModelEntityRes,
      () => DeviceModelEntityRes.fromJsonFactory,
    );

    return _getDeviceModel(modelId: modelId, atoken: atoken?.toString());
  }

  ///get device models by id
  ///@param modelId
  @Get(path: '/DeviceModel/one/{modelId}')
  Future<chopper.Response<DeviceModelEntityRes>> _getDeviceModel({
    @Path('modelId') required String? modelId,
    @Header('ATOKEN') String? atoken,
  });

  ///export device model
  ///@param modelId device model id
  Future<chopper.Response<List<int>>> exportDeviceModel({
    required String? modelId,
    dynamic atoken,
  }) {
    return _exportDeviceModel(modelId: modelId, atoken: atoken?.toString());
  }

  ///export device model
  ///@param modelId device model id
  @Get(path: '/DeviceModel/export/{modelId}')
  Future<chopper.Response<List<int>>> _exportDeviceModel({
    @Path('modelId') required String? modelId,
    @Header('ATOKEN') String? atoken,
  });

  ///import device model exported data
  ///@param file
  Future<chopper.Response<BaseResponse>> importDeviceModel({
    required List<int>? file,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _importDeviceModel(file: file, atoken: atoken?.toString());
  }

  ///import device model exported data
  ///@param file
  @Post(path: '/DeviceModel/import', optionalBody: true)
  Future<chopper.Response<BaseResponse>> _importDeviceModel({
    @Field('file') required List<int>? file,
    @Header('ATOKEN') String? atoken,
  });

  ///list all device model's parameters
  ///@param modelId
  Future<chopper.Response<ParameterArrayRes>> listAllParameters({
    String? modelId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ParameterArrayRes,
      () => ParameterArrayRes.fromJsonFactory,
    );

    return _listAllParameters(
      modelId: modelId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///list all device model's parameters
  ///@param modelId
  @Get(path: '/DeviceModel/param/list')
  Future<chopper.Response<ParameterArrayRes>> _listAllParameters({
    @Header('modelId') String? modelId,
    @Header('ATOKEN') String? atoken,
  });

  ///count
  Future<chopper.Response<CountRes>> countDeviceModels({dynamic atoken}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countDeviceModels(atoken: atoken?.toString());
  }

  ///count
  @Get(path: '/DeviceModel/count')
  Future<chopper.Response<CountRes>> _countDeviceModels({
    @Header('ATOKEN') String? atoken,
  });

  ///get parameter units
  Future<chopper.Response<ParameterUnitsEntityRes>> getParameterUnits({
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ParameterUnitsEntityRes,
      () => ParameterUnitsEntityRes.fromJsonFactory,
    );

    return _getParameterUnits(atoken: atoken?.toString());
  }

  ///get parameter units
  @Get(path: '/DeviceModel/param/units')
  Future<chopper.Response<ParameterUnitsEntityRes>> _getParameterUnits({
    @Header('ATOKEN') String? atoken,
  });

  ///Search device models
  ///@param body
  Future<chopper.Response<QueryRes>> queryDeviceModels({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDeviceModels(body: body, atoken: atoken?.toString());
  }

  ///Search device models
  ///@param body
  @Post(path: '/DeviceModel/query')
  Future<chopper.Response<QueryRes>> _queryDeviceModels({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create device
  ///@param body
  Future<chopper.Response<DeviceEntityRes>> createDevice({
    required DeviceInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(DeviceInfo, () => DeviceInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DeviceEntityRes,
      () => DeviceEntityRes.fromJsonFactory,
    );

    return _createDevice(body: body, atoken: atoken?.toString());
  }

  ///Create device
  ///@param body
  @Post(path: '/Device/create')
  Future<chopper.Response<DeviceEntityRes>> _createDevice({
    @Body() required DeviceInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update device
  ///@param deviceId
  ///@param body
  Future<chopper.Response<DeviceEntityRes>> updateDevice({
    String? deviceId,
    required DeviceInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(DeviceInfo, () => DeviceInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DeviceEntityRes,
      () => DeviceEntityRes.fromJsonFactory,
    );

    return _updateDevice(
      deviceId: deviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update device
  ///@param deviceId
  ///@param body
  @Post(path: '/Device/update')
  Future<chopper.Response<DeviceEntityRes>> _updateDevice({
    @Header('deviceId') String? deviceId,
    @Body() required DeviceInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete device
  ///@param deviceId
  Future<chopper.Response<DeviceEntityRes>> deleteDevice({
    String? deviceId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceEntityRes,
      () => DeviceEntityRes.fromJsonFactory,
    );

    return _deleteDevice(
      deviceId: deviceId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete device
  ///@param deviceId
  @Delete(path: '/Device/remove')
  Future<chopper.Response<DeviceEntityRes>> _deleteDevice({
    @Header('deviceId') String? deviceId,
    @Header('ATOKEN') String? atoken,
  });

  ///List devices
  ///@param modelId
  ///@param body
  Future<chopper.Response<DeviceArrayRes>> listDevices({
    String? modelId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DeviceArrayRes,
      () => DeviceArrayRes.fromJsonFactory,
    );

    return _listDevices(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List devices
  ///@param modelId
  ///@param body
  @Post(path: '/Device/list')
  Future<chopper.Response<DeviceArrayRes>> _listDevices({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search devices
  ///@param modelId
  ///@param assetId
  ///@param floorId
  ///@param facilityId
  ///@param premiseId
  ///@param body
  Future<chopper.Response<DeviceArrayRes>> searchDevices({
    String? modelId,
    String? assetId,
    String? floorId,
    String? facilityId,
    String? premiseId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceArrayRes,
      () => DeviceArrayRes.fromJsonFactory,
    );

    return _searchDevices(
      modelId: modelId?.toString(),
      assetId: assetId?.toString(),
      floorId: floorId?.toString(),
      facilityId: facilityId?.toString(),
      premiseId: premiseId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search devices
  ///@param modelId
  ///@param assetId
  ///@param floorId
  ///@param facilityId
  ///@param premiseId
  ///@param body
  @Post(path: '/Device/search')
  Future<chopper.Response<DeviceArrayRes>> _searchDevices({
    @Header('modelId') String? modelId,
    @Header('assetId') String? assetId,
    @Header('floorId') String? floorId,
    @Header('facilityId') String? facilityId,
    @Header('premiseId') String? premiseId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get devices
  ///@param body
  Future<chopper.Response<DeviceArrayRes>> getDevices({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DeviceArrayRes,
      () => DeviceArrayRes.fromJsonFactory,
    );

    return _getDevices(body: body, atoken: atoken?.toString());
  }

  ///get devices
  ///@param body
  @Post(path: '/Device/get')
  Future<chopper.Response<DeviceArrayRes>> _getDevices({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get device by id
  ///@param deviceId
  ///@param isHardwareDevice
  Future<chopper.Response<DeviceEntityRes>> getDevice({
    required String? deviceId,
    bool? isHardwareDevice,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceEntityRes,
      () => DeviceEntityRes.fromJsonFactory,
    );

    return _getDevice(
      deviceId: deviceId,
      isHardwareDevice: isHardwareDevice?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///get device by id
  ///@param deviceId
  ///@param isHardwareDevice
  @Get(path: '/Device/one/{deviceId}')
  Future<chopper.Response<DeviceEntityRes>> _getDevice({
    @Path('deviceId') required String? deviceId,
    @Header('isHardwareDevice') String? isHardwareDevice,
    @Header('ATOKEN') String? atoken,
  });

  ///Reset API key of a device
  ///@param deviceId
  ///@param apiKey
  Future<chopper.Response<DeviceEntityRes>> resetDeviceApiKey({
    String? deviceId,
    String? apiKey,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DeviceEntityRes,
      () => DeviceEntityRes.fromJsonFactory,
    );

    return _resetDeviceApiKey(
      deviceId: deviceId?.toString(),
      apiKey: apiKey?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Reset API key of a device
  ///@param deviceId
  ///@param apiKey
  @Put(path: '/Device/reset_key', optionalBody: true)
  Future<chopper.Response<DeviceEntityRes>> _resetDeviceApiKey({
    @Header('deviceId') String? deviceId,
    @Header('apiKey') String? apiKey,
    @Header('ATOKEN') String? atoken,
  });

  ///count
  Future<chopper.Response<CountRes>> countDevices({dynamic atoken}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countDevices(atoken: atoken?.toString());
  }

  ///count
  @Get(path: '/Device/count')
  Future<chopper.Response<CountRes>> _countDevices({
    @Header('ATOKEN') String? atoken,
  });

  ///Search devices
  ///@param body
  Future<chopper.Response<QueryRes>> queryDevices({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDevices(body: body, atoken: atoken?.toString());
  }

  ///Search devices
  ///@param body
  @Post(path: '/Device/query')
  Future<chopper.Response<QueryRes>> _queryDevices({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create condition
  ///@param body
  Future<chopper.Response<ConditionEntityRes>> createCondition({
    required ConditionInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ConditionInfo,
      () => ConditionInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ConditionEntityRes,
      () => ConditionEntityRes.fromJsonFactory,
    );

    return _createCondition(body: body, atoken: atoken?.toString());
  }

  ///Create condition
  ///@param body
  @Post(path: '/Condition/create')
  Future<chopper.Response<ConditionEntityRes>> _createCondition({
    @Body() required ConditionInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update condition
  ///@param conditionId
  ///@param body
  Future<chopper.Response<ConditionEntityRes>> updateCondition({
    String? conditionId,
    required ConditionInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ConditionInfo,
      () => ConditionInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ConditionEntityRes,
      () => ConditionEntityRes.fromJsonFactory,
    );

    return _updateCondition(
      conditionId: conditionId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update condition
  ///@param conditionId
  ///@param body
  @Post(path: '/Condition/update')
  Future<chopper.Response<ConditionEntityRes>> _updateCondition({
    @Header('conditionId') String? conditionId,
    @Body() required ConditionInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete condition
  ///@param conditionId
  Future<chopper.Response<ConditionEntityRes>> deleteCondition({
    String? conditionId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ConditionEntityRes,
      () => ConditionEntityRes.fromJsonFactory,
    );

    return _deleteCondition(
      conditionId: conditionId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete condition
  ///@param conditionId
  @Delete(path: '/Condition/remove')
  Future<chopper.Response<ConditionEntityRes>> _deleteCondition({
    @Header('conditionId') String? conditionId,
    @Header('ATOKEN') String? atoken,
  });

  ///List conditions
  ///@param modelId
  ///@param body
  Future<chopper.Response<ConditionArrayRes>> listConditions({
    String? modelId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ConditionArrayRes,
      () => ConditionArrayRes.fromJsonFactory,
    );

    return _listConditions(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List conditions
  ///@param modelId
  ///@param body
  @Post(path: '/Condition/list')
  Future<chopper.Response<ConditionArrayRes>> _listConditions({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search conditions
  ///@param modelId
  ///@param body
  Future<chopper.Response<ConditionArrayRes>> searchConditions({
    String? modelId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ConditionArrayRes,
      () => ConditionArrayRes.fromJsonFactory,
    );

    return _searchConditions(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search conditions
  ///@param modelId
  ///@param body
  @Post(path: '/Condition/search')
  Future<chopper.Response<ConditionArrayRes>> _searchConditions({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get conditions
  ///@param body
  Future<chopper.Response<ConditionArrayRes>> getConditions({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ConditionArrayRes,
      () => ConditionArrayRes.fromJsonFactory,
    );

    return _getConditions(body: body, atoken: atoken?.toString());
  }

  ///Get conditions
  ///@param body
  @Post(path: '/Condition/get')
  Future<chopper.Response<ConditionArrayRes>> _getConditions({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get condition by id
  ///@param conditionId
  Future<chopper.Response<ConditionEntityRes>> getCondition({
    required String? conditionId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ConditionEntityRes,
      () => ConditionEntityRes.fromJsonFactory,
    );

    return _getCondition(conditionId: conditionId, atoken: atoken?.toString());
  }

  ///get condition by id
  ///@param conditionId
  @Get(path: '/Condition/one/{conditionId}')
  Future<chopper.Response<ConditionEntityRes>> _getCondition({
    @Path('conditionId') required String? conditionId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search conditions
  ///@param body
  Future<chopper.Response<QueryRes>> queryConditions({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryConditions(body: body, atoken: atoken?.toString());
  }

  ///Search conditions
  ///@param body
  @Post(path: '/Condition/query')
  Future<chopper.Response<QueryRes>> _queryConditions({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create alarm
  ///@param body
  Future<chopper.Response<AlarmEntityRes>> createAlarm({
    required AlarmInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(AlarmInfo, () => AlarmInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AlarmEntityRes,
      () => AlarmEntityRes.fromJsonFactory,
    );

    return _createAlarm(body: body, atoken: atoken?.toString());
  }

  ///Create alarm
  ///@param body
  @Post(path: '/Alarm/create')
  Future<chopper.Response<AlarmEntityRes>> _createAlarm({
    @Body() required AlarmInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update alarm
  ///@param alarmId
  ///@param body
  Future<chopper.Response<AlarmEntityRes>> updateAlarm({
    String? alarmId,
    required AlarmInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(AlarmInfo, () => AlarmInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AlarmEntityRes,
      () => AlarmEntityRes.fromJsonFactory,
    );

    return _updateAlarm(
      alarmId: alarmId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update alarm
  ///@param alarmId
  ///@param body
  @Post(path: '/Alarm/update')
  Future<chopper.Response<AlarmEntityRes>> _updateAlarm({
    @Header('alarmId') String? alarmId,
    @Body() required AlarmInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete alarm
  ///@param alarmId
  Future<chopper.Response<AlarmEntityRes>> deleteAlarm({
    String? alarmId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AlarmEntityRes,
      () => AlarmEntityRes.fromJsonFactory,
    );

    return _deleteAlarm(
      alarmId: alarmId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete alarm
  ///@param alarmId
  @Delete(path: '/Alarm/remove')
  Future<chopper.Response<AlarmEntityRes>> _deleteAlarm({
    @Header('alarmId') String? alarmId,
    @Header('ATOKEN') String? atoken,
  });

  ///List alarms
  ///@param modelId
  ///@param deviceId
  ///@param body
  Future<chopper.Response<AlarmArrayRes>> listAlarms({
    String? modelId,
    String? deviceId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AlarmArrayRes,
      () => AlarmArrayRes.fromJsonFactory,
    );

    return _listAlarms(
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List alarms
  ///@param modelId
  ///@param deviceId
  ///@param body
  @Post(path: '/Alarm/list')
  Future<chopper.Response<AlarmArrayRes>> _listAlarms({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search alarms
  ///@param modelId
  ///@param deviceId
  ///@param body
  Future<chopper.Response<AlarmArrayRes>> searchAlarms({
    String? modelId,
    String? deviceId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AlarmArrayRes,
      () => AlarmArrayRes.fromJsonFactory,
    );

    return _searchAlarms(
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search alarms
  ///@param modelId
  ///@param deviceId
  ///@param body
  @Post(path: '/Alarm/search')
  Future<chopper.Response<AlarmArrayRes>> _searchAlarms({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get alarms
  ///@param body
  Future<chopper.Response<AlarmArrayRes>> getAlarms({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AlarmArrayRes,
      () => AlarmArrayRes.fromJsonFactory,
    );

    return _getAlarms(body: body, atoken: atoken?.toString());
  }

  ///Get alarms
  ///@param body
  @Post(path: '/Alarm/get')
  Future<chopper.Response<AlarmArrayRes>> _getAlarms({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get alarm by id
  ///@param alarmId
  Future<chopper.Response<AlarmEntityRes>> getAlarm({
    required String? alarmId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AlarmEntityRes,
      () => AlarmEntityRes.fromJsonFactory,
    );

    return _getAlarm(alarmId: alarmId, atoken: atoken?.toString());
  }

  ///get alarm by id
  ///@param alarmId
  @Get(path: '/Alarm/one/{alarmId}')
  Future<chopper.Response<AlarmEntityRes>> _getAlarm({
    @Path('alarmId') required String? alarmId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search alarms
  ///@param body
  Future<chopper.Response<QueryRes>> queryAlarms({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryAlarms(body: body, atoken: atoken?.toString());
  }

  ///Search alarms
  ///@param body
  @Post(path: '/Alarm/query')
  Future<chopper.Response<QueryRes>> _queryAlarms({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create display
  ///@param body
  Future<chopper.Response<DisplayEntityRes>> createDisplay({
    required DisplayInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayInfo,
      () => DisplayInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DisplayEntityRes,
      () => DisplayEntityRes.fromJsonFactory,
    );

    return _createDisplay(body: body, atoken: atoken?.toString());
  }

  ///Create display
  ///@param body
  @Post(path: '/Display/create')
  Future<chopper.Response<DisplayEntityRes>> _createDisplay({
    @Body() required DisplayInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update display
  ///@param displayId
  ///@param body
  Future<chopper.Response<DisplayEntityRes>> updateDisplay({
    String? displayId,
    required DisplayInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayInfo,
      () => DisplayInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DisplayEntityRes,
      () => DisplayEntityRes.fromJsonFactory,
    );

    return _updateDisplay(
      displayId: displayId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update display
  ///@param displayId
  ///@param body
  @Post(path: '/Display/update')
  Future<chopper.Response<DisplayEntityRes>> _updateDisplay({
    @Header('displayId') String? displayId,
    @Body() required DisplayInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete display
  ///@param displayId
  Future<chopper.Response<DisplayEntityRes>> deleteDisplay({
    String? displayId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayEntityRes,
      () => DisplayEntityRes.fromJsonFactory,
    );

    return _deleteDisplay(
      displayId: displayId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete display
  ///@param displayId
  @Delete(path: '/Display/remove')
  Future<chopper.Response<DisplayEntityRes>> _deleteDisplay({
    @Header('displayId') String? displayId,
    @Header('ATOKEN') String? atoken,
  });

  ///List displays
  ///@param modelId
  ///@param deviceId
  ///@param body
  Future<chopper.Response<DisplayArrayRes>> listDisplays({
    String? modelId,
    String? deviceId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DisplayArrayRes,
      () => DisplayArrayRes.fromJsonFactory,
    );

    return _listDisplays(
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List displays
  ///@param modelId
  ///@param deviceId
  ///@param body
  @Post(path: '/Display/list')
  Future<chopper.Response<DisplayArrayRes>> _listDisplays({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search displays
  ///@param modelId
  ///@param deviceId
  ///@param body
  Future<chopper.Response<DisplayArrayRes>> searchDisplays({
    String? modelId,
    String? deviceId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayArrayRes,
      () => DisplayArrayRes.fromJsonFactory,
    );

    return _searchDisplays(
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search displays
  ///@param modelId
  ///@param deviceId
  ///@param body
  @Post(path: '/Display/search')
  Future<chopper.Response<DisplayArrayRes>> _searchDisplays({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get displays
  ///@param body
  Future<chopper.Response<DisplayArrayRes>> getDisplays({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DisplayArrayRes,
      () => DisplayArrayRes.fromJsonFactory,
    );

    return _getDisplays(body: body, atoken: atoken?.toString());
  }

  ///Get displays
  ///@param body
  @Post(path: '/Display/get')
  Future<chopper.Response<DisplayArrayRes>> _getDisplays({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get display by id
  ///@param displayId
  Future<chopper.Response<DisplayEntityRes>> getDisplay({
    required String? displayId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayEntityRes,
      () => DisplayEntityRes.fromJsonFactory,
    );

    return _getDisplay(displayId: displayId, atoken: atoken?.toString());
  }

  ///get display by id
  ///@param displayId
  @Get(path: '/Display/one/{displayId}')
  Future<chopper.Response<DisplayEntityRes>> _getDisplay({
    @Path('displayId') required String? displayId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search displays
  ///@param body
  Future<chopper.Response<QueryRes>> queryDisplays({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDisplays(body: body, atoken: atoken?.toString());
  }

  ///Search displays
  ///@param body
  @Post(path: '/Display/query')
  Future<chopper.Response<QueryRes>> _queryDisplays({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create control
  ///@param body
  Future<chopper.Response<ControlEntityRes>> createControl({
    required ControlInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ControlInfo,
      () => ControlInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ControlEntityRes,
      () => ControlEntityRes.fromJsonFactory,
    );

    return _createControl(body: body, atoken: atoken?.toString());
  }

  ///Create control
  ///@param body
  @Post(path: '/Control/create')
  Future<chopper.Response<ControlEntityRes>> _createControl({
    @Body() required ControlInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update control
  ///@param controlId
  ///@param body
  Future<chopper.Response<ControlEntityRes>> updateControl({
    String? controlId,
    required ControlInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ControlInfo,
      () => ControlInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ControlEntityRes,
      () => ControlEntityRes.fromJsonFactory,
    );

    return _updateControl(
      controlId: controlId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update control
  ///@param controlId
  ///@param body
  @Post(path: '/Control/update')
  Future<chopper.Response<ControlEntityRes>> _updateControl({
    @Header('controlId') String? controlId,
    @Body() required ControlInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete control
  ///@param modelId
  ///@param controlId
  Future<chopper.Response<ControlEntityRes>> deleteControl({
    String? modelId,
    String? controlId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ControlEntityRes,
      () => ControlEntityRes.fromJsonFactory,
    );

    return _deleteControl(
      modelId: modelId?.toString(),
      controlId: controlId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete control
  ///@param modelId
  ///@param controlId
  @Delete(path: '/Control/remove')
  Future<chopper.Response<ControlEntityRes>> _deleteControl({
    @Header('modelId') String? modelId,
    @Header('controlId') String? controlId,
    @Header('ATOKEN') String? atoken,
  });

  ///List controls
  ///@param modelId
  ///@param body
  Future<chopper.Response<ControlArrayRes>> listControls({
    String? modelId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ControlArrayRes,
      () => ControlArrayRes.fromJsonFactory,
    );

    return _listControls(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List controls
  ///@param modelId
  ///@param body
  @Post(path: '/Control/list')
  Future<chopper.Response<ControlArrayRes>> _listControls({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search controls
  ///@param modelId
  ///@param body
  Future<chopper.Response<ControlArrayRes>> searchControls({
    String? modelId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ControlArrayRes,
      () => ControlArrayRes.fromJsonFactory,
    );

    return _searchControls(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search controls
  ///@param modelId
  ///@param body
  @Post(path: '/Control/search')
  Future<chopper.Response<ControlArrayRes>> _searchControls({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get controls
  ///@param body
  Future<chopper.Response<ControlArrayRes>> getControls({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ControlArrayRes,
      () => ControlArrayRes.fromJsonFactory,
    );

    return _getControls(body: body, atoken: atoken?.toString());
  }

  ///Get controls
  ///@param body
  @Post(path: '/Control/get')
  Future<chopper.Response<ControlArrayRes>> _getControls({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get control by id
  ///@param controlId
  Future<chopper.Response<ControlEntityRes>> getControl({
    required String? controlId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ControlEntityRes,
      () => ControlEntityRes.fromJsonFactory,
    );

    return _getControl(controlId: controlId, atoken: atoken?.toString());
  }

  ///get control by id
  ///@param controlId
  @Get(path: '/Control/one/{controlId}')
  Future<chopper.Response<ControlEntityRes>> _getControl({
    @Path('controlId') required String? controlId,
    @Header('ATOKEN') String? atoken,
  });

  ///Fire control
  ///@param body
  Future<chopper.Response<ControlEntityRes>> fireControl({
    required FireReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(FireReq, () => FireReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ControlEntityRes,
      () => ControlEntityRes.fromJsonFactory,
    );

    return _fireControl(body: body, atoken: atoken?.toString());
  }

  ///Fire control
  ///@param body
  @Post(path: '/Control/fire')
  Future<chopper.Response<ControlEntityRes>> _fireControl({
    @Body() required FireReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///set control state
  ///@param deviceId
  ///@param controlId
  ///@param state
  Future<chopper.Response<ControlEntityRes>> setControlState({
    required String? deviceId,
    required String? controlId,
    required int? state,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ControlEntityRes,
      () => ControlEntityRes.fromJsonFactory,
    );

    return _setControlState(
      deviceId: deviceId,
      controlId: controlId,
      state: state,
      atoken: atoken?.toString(),
    );
  }

  ///set control state
  ///@param deviceId
  ///@param controlId
  ///@param state
  @Get(path: '/Control/set/state/{deviceId}/{controlId}/{state}')
  Future<chopper.Response<ControlEntityRes>> _setControlState({
    @Path('deviceId') required String? deviceId,
    @Path('controlId') required String? controlId,
    @Path('state') required int? state,
    @Header('ATOKEN') String? atoken,
  });

  ///Search controls
  ///@param body
  Future<chopper.Response<QueryRes>> queryControls({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryControls(body: body, atoken: atoken?.toString());
  }

  ///Search controls
  ///@param body
  @Post(path: '/Control/query')
  Future<chopper.Response<QueryRes>> _queryControls({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create display widget
  ///@param body
  Future<chopper.Response<DisplayWidgetEntityRes>> createDisplayWidget({
    required DisplayWidgetInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayWidgetInfo,
      () => DisplayWidgetInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DisplayWidgetEntityRes,
      () => DisplayWidgetEntityRes.fromJsonFactory,
    );

    return _createDisplayWidget(body: body, atoken: atoken?.toString());
  }

  ///Create display widget
  ///@param body
  @Post(path: '/DisplayWidget/create')
  Future<chopper.Response<DisplayWidgetEntityRes>> _createDisplayWidget({
    @Body() required DisplayWidgetInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update display widget
  ///@param displayWidgetId
  ///@param body
  Future<chopper.Response<DisplayWidgetEntityRes>> updateDisplayWidget({
    String? displayWidgetId,
    required DisplayWidgetInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayWidgetInfo,
      () => DisplayWidgetInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DisplayWidgetEntityRes,
      () => DisplayWidgetEntityRes.fromJsonFactory,
    );

    return _updateDisplayWidget(
      displayWidgetId: displayWidgetId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update display widget
  ///@param displayWidgetId
  ///@param body
  @Post(path: '/DisplayWidget/update')
  Future<chopper.Response<DisplayWidgetEntityRes>> _updateDisplayWidget({
    @Header('displayWidgetId') String? displayWidgetId,
    @Body() required DisplayWidgetInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete display widget
  ///@param displayWidgetId
  Future<chopper.Response<DisplayWidgetEntityRes>> deleteDisplayWidget({
    String? displayWidgetId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayWidgetEntityRes,
      () => DisplayWidgetEntityRes.fromJsonFactory,
    );

    return _deleteDisplayWidget(
      displayWidgetId: displayWidgetId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete display widget
  ///@param displayWidgetId
  @Delete(path: '/DisplayWidget/remove')
  Future<chopper.Response<DisplayWidgetEntityRes>> _deleteDisplayWidget({
    @Header('displayWidgetId') String? displayWidgetId,
    @Header('ATOKEN') String? atoken,
  });

  ///List display widgets
  ///@param modelId
  ///@param body
  Future<chopper.Response<DisplayWidgetArrayRes>> listDisplayWidgets({
    String? modelId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DisplayWidgetArrayRes,
      () => DisplayWidgetArrayRes.fromJsonFactory,
    );

    return _listDisplayWidgets(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List display widgets
  ///@param modelId
  ///@param body
  @Post(path: '/DisplayWidget/list')
  Future<chopper.Response<DisplayWidgetArrayRes>> _listDisplayWidgets({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search display widgets
  ///@param modelId
  ///@param body
  Future<chopper.Response<DisplayWidgetArrayRes>> searchDisplayWidgets({
    String? modelId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayWidgetArrayRes,
      () => DisplayWidgetArrayRes.fromJsonFactory,
    );

    return _searchDisplayWidgets(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search display widgets
  ///@param modelId
  ///@param body
  @Post(path: '/DisplayWidget/search')
  Future<chopper.Response<DisplayWidgetArrayRes>> _searchDisplayWidgets({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get display widgets
  ///@param body
  Future<chopper.Response<DisplayWidgetArrayRes>> getDisplayWidgets({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DisplayWidgetArrayRes,
      () => DisplayWidgetArrayRes.fromJsonFactory,
    );

    return _getDisplayWidgets(body: body, atoken: atoken?.toString());
  }

  ///Get display widgets
  ///@param body
  @Post(path: '/DisplayWidget/get')
  Future<chopper.Response<DisplayWidgetArrayRes>> _getDisplayWidgets({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get display widget by id
  ///@param displayWidgetId
  Future<chopper.Response<DisplayWidgetEntityRes>> getDisplayWidget({
    required String? displayWidgetId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DisplayWidgetEntityRes,
      () => DisplayWidgetEntityRes.fromJsonFactory,
    );

    return _getDisplayWidget(
      displayWidgetId: displayWidgetId,
      atoken: atoken?.toString(),
    );
  }

  ///get display widget by id
  ///@param displayWidgetId
  @Get(path: '/DisplayWidget/one/{displayWidgetId}')
  Future<chopper.Response<DisplayWidgetEntityRes>> _getDisplayWidget({
    @Path('displayWidgetId') required String? displayWidgetId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search display widgets
  ///@param body
  Future<chopper.Response<QueryRes>> queryDisplayWidgets({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDisplayWidgets(body: body, atoken: atoken?.toString());
  }

  ///Search display widgets
  ///@param body
  @Post(path: '/DisplayWidget/query')
  Future<chopper.Response<QueryRes>> _queryDisplayWidgets({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create screen widget
  ///@param body
  Future<chopper.Response<ScreenWidgetEntityRes>> createScreenWidget({
    required ScreenWidgetInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScreenWidgetInfo,
      () => ScreenWidgetInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ScreenWidgetEntityRes,
      () => ScreenWidgetEntityRes.fromJsonFactory,
    );

    return _createScreenWidget(body: body, atoken: atoken?.toString());
  }

  ///Create screen widget
  ///@param body
  @Post(path: '/ScreenWidget/create')
  Future<chopper.Response<ScreenWidgetEntityRes>> _createScreenWidget({
    @Body() required ScreenWidgetInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update screen widget
  ///@param screenWidgetId
  ///@param body
  Future<chopper.Response<ScreenWidgetEntityRes>> updateScreenWidget({
    String? screenWidgetId,
    required ScreenWidgetInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScreenWidgetInfo,
      () => ScreenWidgetInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ScreenWidgetEntityRes,
      () => ScreenWidgetEntityRes.fromJsonFactory,
    );

    return _updateScreenWidget(
      screenWidgetId: screenWidgetId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update screen widget
  ///@param screenWidgetId
  ///@param body
  @Post(path: '/ScreenWidget/update')
  Future<chopper.Response<ScreenWidgetEntityRes>> _updateScreenWidget({
    @Header('screenWidgetId') String? screenWidgetId,
    @Body() required ScreenWidgetInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete screen widget
  ///@param screenWidgetId
  Future<chopper.Response<ScreenWidgetEntityRes>> deleteScreenWidget({
    String? screenWidgetId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScreenWidgetEntityRes,
      () => ScreenWidgetEntityRes.fromJsonFactory,
    );

    return _deleteScreenWidget(
      screenWidgetId: screenWidgetId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete screen widget
  ///@param screenWidgetId
  @Delete(path: '/ScreenWidget/remove')
  Future<chopper.Response<ScreenWidgetEntityRes>> _deleteScreenWidget({
    @Header('screenWidgetId') String? screenWidgetId,
    @Header('ATOKEN') String? atoken,
  });

  ///List screen widgets
  ///@param target
  ///@param body
  Future<chopper.Response<ScreenWidgetArrayRes>> listScreenWidgets({
    required enums.ScreenWidgetListTargetPostTarget? target,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ScreenWidgetArrayRes,
      () => ScreenWidgetArrayRes.fromJsonFactory,
    );

    return _listScreenWidgets(
      target: target?.value?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List screen widgets
  ///@param target
  ///@param body
  @Post(path: '/ScreenWidget/list/{target}')
  Future<chopper.Response<ScreenWidgetArrayRes>> _listScreenWidgets({
    @Path('target') required String? target,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search screen widgets
  ///@param target
  ///@param body
  Future<chopper.Response<ScreenWidgetArrayRes>> searchScreenWidgets({
    required enums.ScreenWidgetSearchTargetPostTarget? target,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScreenWidgetArrayRes,
      () => ScreenWidgetArrayRes.fromJsonFactory,
    );

    return _searchScreenWidgets(
      target: target?.value?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search screen widgets
  ///@param target
  ///@param body
  @Post(path: '/ScreenWidget/search/{target}')
  Future<chopper.Response<ScreenWidgetArrayRes>> _searchScreenWidgets({
    @Path('target') required String? target,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get screen widgets
  ///@param body
  Future<chopper.Response<ScreenWidgetArrayRes>> getScreenWidgets({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ScreenWidgetArrayRes,
      () => ScreenWidgetArrayRes.fromJsonFactory,
    );

    return _getScreenWidgets(body: body, atoken: atoken?.toString());
  }

  ///Get screen widgets
  ///@param body
  @Post(path: '/ScreenWidget/get')
  Future<chopper.Response<ScreenWidgetArrayRes>> _getScreenWidgets({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get screen widget by id
  ///@param screenWidgetId
  Future<chopper.Response<ScreenWidgetEntityRes>> getScreenWidget({
    required String? screenWidgetId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScreenWidgetEntityRes,
      () => ScreenWidgetEntityRes.fromJsonFactory,
    );

    return _getScreenWidget(
      screenWidgetId: screenWidgetId,
      atoken: atoken?.toString(),
    );
  }

  ///get screen widget by id
  ///@param screenWidgetId
  @Get(path: '/ScreenWidget/one/{screenWidgetId}')
  Future<chopper.Response<ScreenWidgetEntityRes>> _getScreenWidget({
    @Path('screenWidgetId') required String? screenWidgetId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search screen widgets
  ///@param body
  Future<chopper.Response<QueryRes>> queryScreenWidgets({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryScreenWidgets(body: body, atoken: atoken?.toString());
  }

  ///Search screen widgets
  ///@param body
  @Post(path: '/ScreenWidget/query')
  Future<chopper.Response<QueryRes>> _queryScreenWidgets({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create event
  ///@param body
  Future<chopper.Response<EventEntityRes>> createEvent({
    required EventInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(EventInfo, () => EventInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      EventEntityRes,
      () => EventEntityRes.fromJsonFactory,
    );

    return _createEvent(body: body, atoken: atoken?.toString());
  }

  ///Create event
  ///@param body
  @Post(path: '/Event/create')
  Future<chopper.Response<EventEntityRes>> _createEvent({
    @Body() required EventInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update event
  ///@param eventId
  ///@param body
  Future<chopper.Response<EventEntityRes>> updateEvent({
    String? eventId,
    required EventInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(EventInfo, () => EventInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      EventEntityRes,
      () => EventEntityRes.fromJsonFactory,
    );

    return _updateEvent(
      eventId: eventId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update event
  ///@param eventId
  ///@param body
  @Post(path: '/Event/update')
  Future<chopper.Response<EventEntityRes>> _updateEvent({
    @Header('eventId') String? eventId,
    @Body() required EventInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete event
  ///@param eventId
  Future<chopper.Response<EventEntityRes>> deleteEvent({
    String? eventId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EventEntityRes,
      () => EventEntityRes.fromJsonFactory,
    );

    return _deleteEvent(
      eventId: eventId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete event
  ///@param eventId
  @Delete(path: '/Event/remove')
  Future<chopper.Response<EventEntityRes>> _deleteEvent({
    @Header('eventId') String? eventId,
    @Header('ATOKEN') String? atoken,
  });

  ///List events
  ///@param modelId
  ///@param deviceId
  ///@param body
  Future<chopper.Response<EventArrayRes>> listEvents({
    String? modelId,
    String? deviceId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      EventArrayRes,
      () => EventArrayRes.fromJsonFactory,
    );

    return _listEvents(
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List events
  ///@param modelId
  ///@param deviceId
  ///@param body
  @Post(path: '/Event/list')
  Future<chopper.Response<EventArrayRes>> _listEvents({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search events
  ///@param modelId
  ///@param deviceId
  ///@param body
  Future<chopper.Response<EventArrayRes>> searchEvents({
    String? modelId,
    String? deviceId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EventArrayRes,
      () => EventArrayRes.fromJsonFactory,
    );

    return _searchEvents(
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search events
  ///@param modelId
  ///@param deviceId
  ///@param body
  @Post(path: '/Event/search')
  Future<chopper.Response<EventArrayRes>> _searchEvents({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search events
  ///@param body
  Future<chopper.Response<QueryRes>> queryEvents({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryEvents(body: body, atoken: atoken?.toString());
  }

  ///Search events
  ///@param body
  @Post(path: '/Event/query')
  Future<chopper.Response<QueryRes>> _queryEvents({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get events
  ///@param body
  Future<chopper.Response<EventArrayRes>> getEvents({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      EventArrayRes,
      () => EventArrayRes.fromJsonFactory,
    );

    return _getEvents(body: body, atoken: atoken?.toString());
  }

  ///Get events
  ///@param body
  @Post(path: '/Event/get')
  Future<chopper.Response<EventArrayRes>> _getEvents({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get event by id
  ///@param eventId
  Future<chopper.Response<EventEntityRes>> getEvent({
    required String? eventId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EventEntityRes,
      () => EventEntityRes.fromJsonFactory,
    );

    return _getEvent(eventId: eventId, atoken: atoken?.toString());
  }

  ///get event by id
  ///@param eventId
  @Get(path: '/Event/one/{eventId}')
  Future<chopper.Response<EventEntityRes>> _getEvent({
    @Path('eventId') required String? eventId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search triggered events
  ///@param eventId
  ///@param userId
  ///@param modelId
  ///@param deviceId
  ///@param assetId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param body
  Future<chopper.Response<TriggeredEventArrayRes>> searchTriggeredEvents({
    String? eventId,
    String? userId,
    String? modelId,
    String? deviceId,
    String? assetId,
    String? premiseId,
    String? facilityId,
    String? floorId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TriggeredEventArrayRes,
      () => TriggeredEventArrayRes.fromJsonFactory,
    );

    return _searchTriggeredEvents(
      eventId: eventId?.toString(),
      userId: userId?.toString(),
      modelId: modelId?.toString(),
      deviceId: deviceId?.toString(),
      assetId: assetId?.toString(),
      premiseId: premiseId?.toString(),
      facilityId: facilityId?.toString(),
      floorId: floorId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search triggered events
  ///@param eventId
  ///@param userId
  ///@param modelId
  ///@param deviceId
  ///@param assetId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param body
  @Post(path: '/Event/search/triggered')
  Future<chopper.Response<TriggeredEventArrayRes>> _searchTriggeredEvents({
    @Header('eventId') String? eventId,
    @Header('userId') String? userId,
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Header('assetId') String? assetId,
    @Header('premiseId') String? premiseId,
    @Header('facilityId') String? facilityId,
    @Header('floorId') String? floorId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search triggered events
  ///@param body
  Future<chopper.Response<QueryRes>> queryTriggeredEvents({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryTriggeredEvents(body: body, atoken: atoken?.toString());
  }

  ///Search triggered events
  ///@param body
  @Post(path: '/Event/query/triggered')
  Future<chopper.Response<QueryRes>> _queryTriggeredEvents({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create trigger
  ///@param body
  Future<chopper.Response<TriggerEntityRes>> createTrigger({
    required TriggerInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TriggerInfo,
      () => TriggerInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      TriggerEntityRes,
      () => TriggerEntityRes.fromJsonFactory,
    );

    return _createTrigger(body: body, atoken: atoken?.toString());
  }

  ///Create trigger
  ///@param body
  @Post(path: '/Trigger/create')
  Future<chopper.Response<TriggerEntityRes>> _createTrigger({
    @Body() required TriggerInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update trigger
  ///@param triggerId
  ///@param body
  Future<chopper.Response<TriggerEntityRes>> updateTrigger({
    String? triggerId,
    required TriggerInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TriggerInfo,
      () => TriggerInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      TriggerEntityRes,
      () => TriggerEntityRes.fromJsonFactory,
    );

    return _updateTrigger(
      triggerId: triggerId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update trigger
  ///@param triggerId
  ///@param body
  @Post(path: '/Trigger/update')
  Future<chopper.Response<TriggerEntityRes>> _updateTrigger({
    @Header('triggerId') String? triggerId,
    @Body() required TriggerInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete trigger
  ///@param triggerId
  Future<chopper.Response<TriggerEntityRes>> deleteTrigger({
    String? triggerId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TriggerEntityRes,
      () => TriggerEntityRes.fromJsonFactory,
    );

    return _deleteTrigger(
      triggerId: triggerId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete trigger
  ///@param triggerId
  @Delete(path: '/Trigger/remove')
  Future<chopper.Response<TriggerEntityRes>> _deleteTrigger({
    @Header('triggerId') String? triggerId,
    @Header('ATOKEN') String? atoken,
  });

  ///List triggers
  ///@param modelId
  ///@param body
  Future<chopper.Response<TriggerArrayRes>> listTrigger({
    String? modelId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      TriggerArrayRes,
      () => TriggerArrayRes.fromJsonFactory,
    );

    return _listTrigger(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List triggers
  ///@param modelId
  ///@param body
  @Post(path: '/Trigger/list')
  Future<chopper.Response<TriggerArrayRes>> _listTrigger({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search triggers
  ///@param modelId
  ///@param body
  Future<chopper.Response<TriggerArrayRes>> searchTriggers({
    String? modelId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TriggerArrayRes,
      () => TriggerArrayRes.fromJsonFactory,
    );

    return _searchTriggers(
      modelId: modelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search triggers
  ///@param modelId
  ///@param body
  @Post(path: '/Trigger/search')
  Future<chopper.Response<TriggerArrayRes>> _searchTriggers({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get triggers
  ///@param body
  Future<chopper.Response<TriggerArrayRes>> getTriggers({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      TriggerArrayRes,
      () => TriggerArrayRes.fromJsonFactory,
    );

    return _getTriggers(body: body, atoken: atoken?.toString());
  }

  ///Get triggers
  ///@param body
  @Post(path: '/Trigger/get')
  Future<chopper.Response<TriggerArrayRes>> _getTriggers({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get trigger by id
  ///@param triggerId
  Future<chopper.Response<TriggerEntityRes>> getTrigger({
    required String? triggerId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TriggerEntityRes,
      () => TriggerEntityRes.fromJsonFactory,
    );

    return _getTrigger(triggerId: triggerId, atoken: atoken?.toString());
  }

  ///get trigger by id
  ///@param triggerId
  @Get(path: '/Trigger/one/{triggerId}')
  Future<chopper.Response<TriggerEntityRes>> _getTrigger({
    @Path('triggerId') required String? triggerId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search triggers
  ///@param body
  Future<chopper.Response<QueryRes>> queryTriggers({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryTriggers(body: body, atoken: atoken?.toString());
  }

  ///Search triggers
  ///@param body
  @Post(path: '/Trigger/query')
  Future<chopper.Response<QueryRes>> _queryTriggers({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create preprocessor
  ///@param body
  Future<chopper.Response<PreprocessorEntityRes>> createPreprocessor({
    required PreprocessorInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PreprocessorInfo,
      () => PreprocessorInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      PreprocessorEntityRes,
      () => PreprocessorEntityRes.fromJsonFactory,
    );

    return _createPreprocessor(body: body, atoken: atoken?.toString());
  }

  ///Create preprocessor
  ///@param body
  @Post(path: '/Preprocessor/create')
  Future<chopper.Response<PreprocessorEntityRes>> _createPreprocessor({
    @Body() required PreprocessorInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update preprocessor
  ///@param preprocessorId
  ///@param body
  Future<chopper.Response<PreprocessorEntityRes>> updatePreprocessor({
    String? preprocessorId,
    required PreprocessorInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PreprocessorInfo,
      () => PreprocessorInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      PreprocessorEntityRes,
      () => PreprocessorEntityRes.fromJsonFactory,
    );

    return _updatePreprocessor(
      preprocessorId: preprocessorId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update preprocessor
  ///@param preprocessorId
  ///@param body
  @Post(path: '/Preprocessor/update')
  Future<chopper.Response<PreprocessorEntityRes>> _updatePreprocessor({
    @Header('preprocessorId') String? preprocessorId,
    @Body() required PreprocessorInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete preprocessor
  ///@param preprocessorId
  Future<chopper.Response<PreprocessorEntityRes>> deletePreprocessor({
    String? preprocessorId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PreprocessorEntityRes,
      () => PreprocessorEntityRes.fromJsonFactory,
    );

    return _deletePreprocessor(
      preprocessorId: preprocessorId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete preprocessor
  ///@param preprocessorId
  @Delete(path: '/Preprocessor/remove')
  Future<chopper.Response<PreprocessorEntityRes>> _deletePreprocessor({
    @Header('preprocessorId') String? preprocessorId,
    @Header('ATOKEN') String? atoken,
  });

  ///List preprocessors
  ///@param body
  Future<chopper.Response<PreprocessorArrayRes>> listPreprocessors({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      PreprocessorArrayRes,
      () => PreprocessorArrayRes.fromJsonFactory,
    );

    return _listPreprocessors(body: body, atoken: atoken?.toString());
  }

  ///List preprocessors
  ///@param body
  @Post(path: '/Preprocessor/list')
  Future<chopper.Response<PreprocessorArrayRes>> _listPreprocessors({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search preprocessors
  ///@param body
  Future<chopper.Response<PreprocessorArrayRes>> searchPreprocessors({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PreprocessorArrayRes,
      () => PreprocessorArrayRes.fromJsonFactory,
    );

    return _searchPreprocessors(body: body, atoken: atoken?.toString());
  }

  ///Search preprocessors
  ///@param body
  @Post(path: '/Preprocessor/search')
  Future<chopper.Response<PreprocessorArrayRes>> _searchPreprocessors({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get preprocessors
  ///@param body
  Future<chopper.Response<PreprocessorArrayRes>> getPreprocessors({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      PreprocessorArrayRes,
      () => PreprocessorArrayRes.fromJsonFactory,
    );

    return _getPreprocessors(body: body, atoken: atoken?.toString());
  }

  ///Get preprocessors
  ///@param body
  @Post(path: '/Preprocessor/get')
  Future<chopper.Response<PreprocessorArrayRes>> _getPreprocessors({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get preprocessor by id
  ///@param preprocessorId
  Future<chopper.Response<PreprocessorEntityRes>> getPreprocessor({
    required String? preprocessorId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PreprocessorEntityRes,
      () => PreprocessorEntityRes.fromJsonFactory,
    );

    return _getPreprocessor(
      preprocessorId: preprocessorId,
      atoken: atoken?.toString(),
    );
  }

  ///get preprocessor by id
  ///@param preprocessorId
  @Get(path: '/Preprocessor/one/{preprocessorId}')
  Future<chopper.Response<PreprocessorEntityRes>> _getPreprocessor({
    @Path('preprocessorId') required String? preprocessorId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search preprocessors
  ///@param body
  Future<chopper.Response<QueryRes>> queryPreprocessors({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryPreprocessors(body: body, atoken: atoken?.toString());
  }

  ///Search preprocessors
  ///@param body
  @Post(path: '/Preprocessor/query')
  Future<chopper.Response<QueryRes>> _queryPreprocessors({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create dataFilter
  ///@param body
  Future<chopper.Response<DataFilterEntityRes>> createDataFilter({
    required DataFilterInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DataFilterInfo,
      () => DataFilterInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DataFilterEntityRes,
      () => DataFilterEntityRes.fromJsonFactory,
    );

    return _createDataFilter(body: body, atoken: atoken?.toString());
  }

  ///Create dataFilter
  ///@param body
  @Post(path: '/DataFilter/create')
  Future<chopper.Response<DataFilterEntityRes>> _createDataFilter({
    @Body() required DataFilterInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update dataFilter
  ///@param dataFilterId
  ///@param body
  Future<chopper.Response<DataFilterEntityRes>> updateDataFilter({
    String? dataFilterId,
    required DataFilterInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DataFilterInfo,
      () => DataFilterInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      DataFilterEntityRes,
      () => DataFilterEntityRes.fromJsonFactory,
    );

    return _updateDataFilter(
      dataFilterId: dataFilterId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update dataFilter
  ///@param dataFilterId
  ///@param body
  @Post(path: '/DataFilter/update')
  Future<chopper.Response<DataFilterEntityRes>> _updateDataFilter({
    @Header('dataFilterId') String? dataFilterId,
    @Body() required DataFilterInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete dataFilter
  ///@param dataFilterId
  Future<chopper.Response<DataFilterEntityRes>> deleteDataFilter({
    String? dataFilterId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DataFilterEntityRes,
      () => DataFilterEntityRes.fromJsonFactory,
    );

    return _deleteDataFilter(
      dataFilterId: dataFilterId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete dataFilter
  ///@param dataFilterId
  @Delete(path: '/DataFilter/remove')
  Future<chopper.Response<DataFilterEntityRes>> _deleteDataFilter({
    @Header('dataFilterId') String? dataFilterId,
    @Header('ATOKEN') String? atoken,
  });

  ///List dataFilters
  ///@param modelId
  ///@param myFilters
  ///@param body
  Future<chopper.Response<DataFilterArrayRes>> listDataFilters({
    String? modelId,
    bool? myFilters,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DataFilterArrayRes,
      () => DataFilterArrayRes.fromJsonFactory,
    );

    return _listDataFilters(
      modelId: modelId?.toString(),
      myFilters: myFilters?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List dataFilters
  ///@param modelId
  ///@param myFilters
  ///@param body
  @Post(path: '/DataFilter/list')
  Future<chopper.Response<DataFilterArrayRes>> _listDataFilters({
    @Header('modelId') String? modelId,
    @Header('myFilters') String? myFilters,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search dataFilters
  ///@param modelId
  ///@param myFilters
  ///@param body
  Future<chopper.Response<DataFilterArrayRes>> searchDataFilters({
    String? modelId,
    bool? myFilters,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DataFilterArrayRes,
      () => DataFilterArrayRes.fromJsonFactory,
    );

    return _searchDataFilters(
      modelId: modelId?.toString(),
      myFilters: myFilters?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search dataFilters
  ///@param modelId
  ///@param myFilters
  ///@param body
  @Post(path: '/DataFilter/search')
  Future<chopper.Response<DataFilterArrayRes>> _searchDataFilters({
    @Header('modelId') String? modelId,
    @Header('myFilters') String? myFilters,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get dataFilters
  ///@param body
  Future<chopper.Response<DataFilterArrayRes>> getDataFilters({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      DataFilterArrayRes,
      () => DataFilterArrayRes.fromJsonFactory,
    );

    return _getDataFilters(body: body, atoken: atoken?.toString());
  }

  ///Get dataFilters
  ///@param body
  @Post(path: '/DataFilter/get')
  Future<chopper.Response<DataFilterArrayRes>> _getDataFilters({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get dataFilter by id
  ///@param dataFilterId
  Future<chopper.Response<DataFilterEntityRes>> getDataFilter({
    required String? dataFilterId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      DataFilterEntityRes,
      () => DataFilterEntityRes.fromJsonFactory,
    );

    return _getDataFilter(
      dataFilterId: dataFilterId,
      atoken: atoken?.toString(),
    );
  }

  ///get dataFilter by id
  ///@param dataFilterId
  @Get(path: '/DataFilter/one/{dataFilterId}')
  Future<chopper.Response<DataFilterEntityRes>> _getDataFilter({
    @Path('dataFilterId') required String? dataFilterId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search dataFilters
  ///@param body
  Future<chopper.Response<QueryRes>> queryDataFilters({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDataFilters(body: body, atoken: atoken?.toString());
  }

  ///Search dataFilters
  ///@param body
  @Post(path: '/DataFilter/query')
  Future<chopper.Response<QueryRes>> _queryDataFilters({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create geoFence
  ///@param body
  Future<chopper.Response<GeoFenceEntityRes>> createGeoFence({
    required GeoFenceInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      GeoFenceInfo,
      () => GeoFenceInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      GeoFenceEntityRes,
      () => GeoFenceEntityRes.fromJsonFactory,
    );

    return _createGeoFence(body: body, atoken: atoken?.toString());
  }

  ///Create geoFence
  ///@param body
  @Post(path: '/GeoFence/create')
  Future<chopper.Response<GeoFenceEntityRes>> _createGeoFence({
    @Body() required GeoFenceInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update geoFence
  ///@param geoFenceId
  ///@param body
  Future<chopper.Response<GeoFenceEntityRes>> updateGeoFence({
    String? geoFenceId,
    required GeoFenceInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      GeoFenceInfo,
      () => GeoFenceInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      GeoFenceEntityRes,
      () => GeoFenceEntityRes.fromJsonFactory,
    );

    return _updateGeoFence(
      geoFenceId: geoFenceId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update geoFence
  ///@param geoFenceId
  ///@param body
  @Post(path: '/GeoFence/update')
  Future<chopper.Response<GeoFenceEntityRes>> _updateGeoFence({
    @Header('geoFenceId') String? geoFenceId,
    @Body() required GeoFenceInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete geoFence
  ///@param geoFenceId
  Future<chopper.Response<GeoFenceEntityRes>> deleteGeoFence({
    String? geoFenceId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      GeoFenceEntityRes,
      () => GeoFenceEntityRes.fromJsonFactory,
    );

    return _deleteGeoFence(
      geoFenceId: geoFenceId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete geoFence
  ///@param geoFenceId
  @Delete(path: '/GeoFence/remove')
  Future<chopper.Response<GeoFenceEntityRes>> _deleteGeoFence({
    @Header('geoFenceId') String? geoFenceId,
    @Header('ATOKEN') String? atoken,
  });

  ///List geoFences
  ///@param body
  Future<chopper.Response<GeoFenceArrayRes>> listGeoFences({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      GeoFenceArrayRes,
      () => GeoFenceArrayRes.fromJsonFactory,
    );

    return _listGeoFences(body: body, atoken: atoken?.toString());
  }

  ///List geoFences
  ///@param body
  @Post(path: '/GeoFence/list')
  Future<chopper.Response<GeoFenceArrayRes>> _listGeoFences({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search geoFences
  ///@param body
  Future<chopper.Response<GeoFenceArrayRes>> searchGeoFences({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      GeoFenceArrayRes,
      () => GeoFenceArrayRes.fromJsonFactory,
    );

    return _searchGeoFences(body: body, atoken: atoken?.toString());
  }

  ///Search geoFences
  ///@param body
  @Post(path: '/GeoFence/search')
  Future<chopper.Response<GeoFenceArrayRes>> _searchGeoFences({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get geoFences
  ///@param body
  Future<chopper.Response<GeoFenceArrayRes>> getGeoFences({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      GeoFenceArrayRes,
      () => GeoFenceArrayRes.fromJsonFactory,
    );

    return _getGeoFences(body: body, atoken: atoken?.toString());
  }

  ///Get geoFences
  ///@param body
  @Post(path: '/GeoFence/get')
  Future<chopper.Response<GeoFenceArrayRes>> _getGeoFences({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get geoFence by id
  ///@param geoFenceId
  Future<chopper.Response<GeoFenceEntityRes>> getGeoFence({
    required String? geoFenceId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      GeoFenceEntityRes,
      () => GeoFenceEntityRes.fromJsonFactory,
    );

    return _getGeoFence(geoFenceId: geoFenceId, atoken: atoken?.toString());
  }

  ///get geoFence by id
  ///@param geoFenceId
  @Get(path: '/GeoFence/one/{geoFenceId}')
  Future<chopper.Response<GeoFenceEntityRes>> _getGeoFence({
    @Path('geoFenceId') required String? geoFenceId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search geoFences
  ///@param body
  Future<chopper.Response<QueryRes>> queryGeoFences({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryGeoFences(body: body, atoken: atoken?.toString());
  }

  ///Search geoFences
  ///@param body
  @Post(path: '/GeoFence/query')
  Future<chopper.Response<QueryRes>> _queryGeoFences({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create analytics screen
  ///@param body
  Future<chopper.Response<AnalyticsScreenEntityRes>> createAnalyticsScreen({
    required AnalyticsScreenInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AnalyticsScreenInfo,
      () => AnalyticsScreenInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      AnalyticsScreenEntityRes,
      () => AnalyticsScreenEntityRes.fromJsonFactory,
    );

    return _createAnalyticsScreen(body: body, atoken: atoken?.toString());
  }

  ///Create analytics screen
  ///@param body
  @Post(path: '/AnalyticsScreen/create')
  Future<chopper.Response<AnalyticsScreenEntityRes>> _createAnalyticsScreen({
    @Body() required AnalyticsScreenInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update analytics screen
  ///@param analyticsScreenId
  ///@param body
  Future<chopper.Response<AnalyticsScreenEntityRes>> updateAnalyticsScreen({
    String? analyticsScreenId,
    required AnalyticsScreenInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AnalyticsScreenInfo,
      () => AnalyticsScreenInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      AnalyticsScreenEntityRes,
      () => AnalyticsScreenEntityRes.fromJsonFactory,
    );

    return _updateAnalyticsScreen(
      analyticsScreenId: analyticsScreenId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update analytics screen
  ///@param analyticsScreenId
  ///@param body
  @Post(path: '/AnalyticsScreen/update')
  Future<chopper.Response<AnalyticsScreenEntityRes>> _updateAnalyticsScreen({
    @Header('analyticsScreenId') String? analyticsScreenId,
    @Body() required AnalyticsScreenInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete analytics screen
  ///@param analyticsScreenId
  Future<chopper.Response<AnalyticsScreenEntityRes>> deleteAnalyticsScreen({
    String? analyticsScreenId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AnalyticsScreenEntityRes,
      () => AnalyticsScreenEntityRes.fromJsonFactory,
    );

    return _deleteAnalyticsScreen(
      analyticsScreenId: analyticsScreenId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete analytics screen
  ///@param analyticsScreenId
  @Delete(path: '/AnalyticsScreen/remove')
  Future<chopper.Response<AnalyticsScreenEntityRes>> _deleteAnalyticsScreen({
    @Header('analyticsScreenId') String? analyticsScreenId,
    @Header('ATOKEN') String? atoken,
  });

  ///List analytics screens
  ///@param body
  Future<chopper.Response<AnalyticsScreenArrayRes>> listAnalyticsScreens({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AnalyticsScreenArrayRes,
      () => AnalyticsScreenArrayRes.fromJsonFactory,
    );

    return _listAnalyticsScreens(body: body, atoken: atoken?.toString());
  }

  ///List analytics screens
  ///@param body
  @Post(path: '/AnalyticsScreen/list')
  Future<chopper.Response<AnalyticsScreenArrayRes>> _listAnalyticsScreens({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search analytics screens
  ///@param body
  Future<chopper.Response<AnalyticsScreenArrayRes>> searchAnalyticsScreens({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AnalyticsScreenArrayRes,
      () => AnalyticsScreenArrayRes.fromJsonFactory,
    );

    return _searchAnalyticsScreens(body: body, atoken: atoken?.toString());
  }

  ///Search analytics screens
  ///@param body
  @Post(path: '/AnalyticsScreen/search')
  Future<chopper.Response<AnalyticsScreenArrayRes>> _searchAnalyticsScreens({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get analytics screens
  ///@param body
  Future<chopper.Response<AnalyticsScreenArrayRes>> getAnalyticsScreens({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AnalyticsScreenArrayRes,
      () => AnalyticsScreenArrayRes.fromJsonFactory,
    );

    return _getAnalyticsScreens(body: body, atoken: atoken?.toString());
  }

  ///Get analytics screens
  ///@param body
  @Post(path: '/AnalyticsScreen/get')
  Future<chopper.Response<AnalyticsScreenArrayRes>> _getAnalyticsScreens({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get analytics screen by id
  ///@param analyticsScreenId
  Future<chopper.Response<AnalyticsScreenEntityRes>> getAnalyticsScreen({
    required String? analyticsScreenId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AnalyticsScreenEntityRes,
      () => AnalyticsScreenEntityRes.fromJsonFactory,
    );

    return _getAnalyticsScreen(
      analyticsScreenId: analyticsScreenId,
      atoken: atoken?.toString(),
    );
  }

  ///get analytics screen by id
  ///@param analyticsScreenId
  @Get(path: '/AnalyticsScreen/one/{analyticsScreenId}')
  Future<chopper.Response<AnalyticsScreenEntityRes>> _getAnalyticsScreen({
    @Path('analyticsScreenId') required String? analyticsScreenId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search analytics screens
  ///@param body
  Future<chopper.Response<QueryRes>> queryAnalyticsScreens({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryAnalyticsScreens(body: body, atoken: atoken?.toString());
  }

  ///Search analytics screens
  ///@param body
  @Post(path: '/AnalyticsScreen/query')
  Future<chopper.Response<QueryRes>> _queryAnalyticsScreens({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create role
  ///@param body
  Future<chopper.Response<RoleEntityRes>> createRole({
    required RoleInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(RoleInfo, () => RoleInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      RoleEntityRes,
      () => RoleEntityRes.fromJsonFactory,
    );

    return _createRole(body: body, atoken: atoken?.toString());
  }

  ///Create role
  ///@param body
  @Post(path: '/Role/create')
  Future<chopper.Response<RoleEntityRes>> _createRole({
    @Body() required RoleInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update role
  ///@param roleId
  ///@param body
  Future<chopper.Response<RoleEntityRes>> updateRole({
    String? roleId,
    required RoleInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(RoleInfo, () => RoleInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      RoleEntityRes,
      () => RoleEntityRes.fromJsonFactory,
    );

    return _updateRole(
      roleId: roleId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update role
  ///@param roleId
  ///@param body
  @Post(path: '/Role/update')
  Future<chopper.Response<RoleEntityRes>> _updateRole({
    @Header('roleId') String? roleId,
    @Body() required RoleInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete role
  ///@param roleId
  Future<chopper.Response<RoleEntityRes>> deleteRole({
    String? roleId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      RoleEntityRes,
      () => RoleEntityRes.fromJsonFactory,
    );

    return _deleteRole(roleId: roleId?.toString(), atoken: atoken?.toString());
  }

  ///Delete role
  ///@param roleId
  @Delete(path: '/Role/remove')
  Future<chopper.Response<RoleEntityRes>> _deleteRole({
    @Header('roleId') String? roleId,
    @Header('ATOKEN') String? atoken,
  });

  ///List roles
  ///@param body
  Future<chopper.Response<RoleArrayRes>> listRoles({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      RoleArrayRes,
      () => RoleArrayRes.fromJsonFactory,
    );

    return _listRoles(body: body, atoken: atoken?.toString());
  }

  ///List roles
  ///@param body
  @Post(path: '/Role/list')
  Future<chopper.Response<RoleArrayRes>> _listRoles({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search roles
  ///@param body
  Future<chopper.Response<RoleArrayRes>> searchRoles({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      RoleArrayRes,
      () => RoleArrayRes.fromJsonFactory,
    );

    return _searchRoles(body: body, atoken: atoken?.toString());
  }

  ///Search roles
  ///@param body
  @Post(path: '/Role/search')
  Future<chopper.Response<RoleArrayRes>> _searchRoles({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get roles
  ///@param body
  Future<chopper.Response<RoleArrayRes>> getRoles({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      RoleArrayRes,
      () => RoleArrayRes.fromJsonFactory,
    );

    return _getRoles(body: body, atoken: atoken?.toString());
  }

  ///Get roles
  ///@param body
  @Post(path: '/Role/get')
  Future<chopper.Response<RoleArrayRes>> _getRoles({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get role by id
  ///@param roleId
  Future<chopper.Response<RoleEntityRes>> getRole({
    required String? roleId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      RoleEntityRes,
      () => RoleEntityRes.fromJsonFactory,
    );

    return _getRole(roleId: roleId, atoken: atoken?.toString());
  }

  ///get role by id
  ///@param roleId
  @Get(path: '/Role/one/{roleId}')
  Future<chopper.Response<RoleEntityRes>> _getRole({
    @Path('roleId') required String? roleId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search roles
  ///@param body
  Future<chopper.Response<QueryRes>> queryRoles({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryRoles(body: body, atoken: atoken?.toString());
  }

  ///Search roles
  ///@param body
  @Post(path: '/Role/query')
  Future<chopper.Response<QueryRes>> _queryRoles({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create floor
  ///@param body
  Future<chopper.Response<FloorEntityRes>> createFloor({
    required FloorInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(FloorInfo, () => FloorInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      FloorEntityRes,
      () => FloorEntityRes.fromJsonFactory,
    );

    return _createFloor(body: body, atoken: atoken?.toString());
  }

  ///Create floor
  ///@param body
  @Post(path: '/Floor/create')
  Future<chopper.Response<FloorEntityRes>> _createFloor({
    @Body() required FloorInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update floor
  ///@param floorId
  ///@param body
  Future<chopper.Response<FloorEntityRes>> updateFloor({
    String? floorId,
    required FloorInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(FloorInfo, () => FloorInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      FloorEntityRes,
      () => FloorEntityRes.fromJsonFactory,
    );

    return _updateFloor(
      floorId: floorId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update floor
  ///@param floorId
  ///@param body
  @Post(path: '/Floor/update')
  Future<chopper.Response<FloorEntityRes>> _updateFloor({
    @Header('floorId') String? floorId,
    @Body() required FloorInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete floor
  ///@param floorId
  Future<chopper.Response<FloorEntityRes>> deleteFloor({
    String? floorId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FloorEntityRes,
      () => FloorEntityRes.fromJsonFactory,
    );

    return _deleteFloor(
      floorId: floorId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete floor
  ///@param floorId
  @Delete(path: '/Floor/remove')
  Future<chopper.Response<FloorEntityRes>> _deleteFloor({
    @Header('floorId') String? floorId,
    @Header('ATOKEN') String? atoken,
  });

  ///List floors
  ///@param facilityId
  ///@param body
  Future<chopper.Response<FloorArrayRes>> listFloors({
    String? facilityId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      FloorArrayRes,
      () => FloorArrayRes.fromJsonFactory,
    );

    return _listFloors(
      facilityId: facilityId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List floors
  ///@param facilityId
  ///@param body
  @Post(path: '/Floor/list')
  Future<chopper.Response<FloorArrayRes>> _listFloors({
    @Header('facilityId') String? facilityId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search floors
  ///@param facilityId
  ///@param premiseId
  ///@param body
  Future<chopper.Response<FloorArrayRes>> searchFloors({
    String? facilityId,
    String? premiseId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FloorArrayRes,
      () => FloorArrayRes.fromJsonFactory,
    );

    return _searchFloors(
      facilityId: facilityId?.toString(),
      premiseId: premiseId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search floors
  ///@param facilityId
  ///@param premiseId
  ///@param body
  @Post(path: '/Floor/search')
  Future<chopper.Response<FloorArrayRes>> _searchFloors({
    @Header('facilityId') String? facilityId,
    @Header('premiseId') String? premiseId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get floors
  ///@param body
  Future<chopper.Response<FloorArrayRes>> getFloors({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      FloorArrayRes,
      () => FloorArrayRes.fromJsonFactory,
    );

    return _getFloors(body: body, atoken: atoken?.toString());
  }

  ///Get floors
  ///@param body
  @Post(path: '/Floor/get')
  Future<chopper.Response<FloorArrayRes>> _getFloors({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get floor by id
  ///@param floorId
  Future<chopper.Response<FloorEntityRes>> getFloor({
    required String? floorId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FloorEntityRes,
      () => FloorEntityRes.fromJsonFactory,
    );

    return _getFloor(floorId: floorId, atoken: atoken?.toString());
  }

  ///get floor by id
  ///@param floorId
  @Get(path: '/Floor/one/{floorId}')
  Future<chopper.Response<FloorEntityRes>> _getFloor({
    @Path('floorId') required String? floorId,
    @Header('ATOKEN') String? atoken,
  });

  ///Get stats
  ///@param floorId
  Future<chopper.Response<FloorStatsEntityRes>> getFloorStats({
    required String? floorId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FloorStatsEntityRes,
      () => FloorStatsEntityRes.fromJsonFactory,
    );

    return _getFloorStats(floorId: floorId, atoken: atoken?.toString());
  }

  ///Get stats
  ///@param floorId
  @Get(path: '/Floor/stats/{floorId}')
  Future<chopper.Response<FloorStatsEntityRes>> _getFloorStats({
    @Path('floorId') required String? floorId,
    @Header('ATOKEN') String? atoken,
  });

  ///query data
  ///@param body
  Future<chopper.Response<QueryRes>> queryFloors({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryFloors(body: body, atoken: atoken?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/Floor/query')
  Future<chopper.Response<QueryRes>> _queryFloors({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create asset
  ///@param body
  Future<chopper.Response<AssetEntityRes>> createAsset({
    required AssetInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(AssetInfo, () => AssetInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AssetEntityRes,
      () => AssetEntityRes.fromJsonFactory,
    );

    return _createAsset(body: body, atoken: atoken?.toString());
  }

  ///Create asset
  ///@param body
  @Post(path: '/Asset/create')
  Future<chopper.Response<AssetEntityRes>> _createAsset({
    @Body() required AssetInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update asset
  ///@param assetId
  ///@param body
  Future<chopper.Response<AssetEntityRes>> updateAsset({
    String? assetId,
    required AssetInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(AssetInfo, () => AssetInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AssetEntityRes,
      () => AssetEntityRes.fromJsonFactory,
    );

    return _updateAsset(
      assetId: assetId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update asset
  ///@param assetId
  ///@param body
  @Post(path: '/Asset/update')
  Future<chopper.Response<AssetEntityRes>> _updateAsset({
    @Header('assetId') String? assetId,
    @Body() required AssetInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete asset
  ///@param assetId
  Future<chopper.Response<AssetEntityRes>> deleteAsset({
    String? assetId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetEntityRes,
      () => AssetEntityRes.fromJsonFactory,
    );

    return _deleteAsset(
      assetId: assetId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete asset
  ///@param assetId
  @Delete(path: '/Asset/remove')
  Future<chopper.Response<AssetEntityRes>> _deleteAsset({
    @Header('assetId') String? assetId,
    @Header('ATOKEN') String? atoken,
  });

  ///List assets
  ///@param floorId
  ///@param body
  Future<chopper.Response<AssetArrayRes>> listAssets({
    String? floorId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AssetArrayRes,
      () => AssetArrayRes.fromJsonFactory,
    );

    return _listAssets(
      floorId: floorId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List assets
  ///@param floorId
  ///@param body
  @Post(path: '/Asset/list')
  Future<chopper.Response<AssetArrayRes>> _listAssets({
    @Header('floorId') String? floorId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search assets
  ///@param floorId
  ///@param facilityId
  ///@param premiseId
  ///@param body
  Future<chopper.Response<AssetArrayRes>> searchAssets({
    String? floorId,
    String? facilityId,
    String? premiseId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetArrayRes,
      () => AssetArrayRes.fromJsonFactory,
    );

    return _searchAssets(
      floorId: floorId?.toString(),
      facilityId: facilityId?.toString(),
      premiseId: premiseId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search assets
  ///@param floorId
  ///@param facilityId
  ///@param premiseId
  ///@param body
  @Post(path: '/Asset/search')
  Future<chopper.Response<AssetArrayRes>> _searchAssets({
    @Header('floorId') String? floorId,
    @Header('facilityId') String? facilityId,
    @Header('premiseId') String? premiseId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get assets
  ///@param body
  Future<chopper.Response<AssetArrayRes>> getAssets({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AssetArrayRes,
      () => AssetArrayRes.fromJsonFactory,
    );

    return _getAssets(body: body, atoken: atoken?.toString());
  }

  ///Get assets
  ///@param body
  @Post(path: '/Asset/get')
  Future<chopper.Response<AssetArrayRes>> _getAssets({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get asset by id
  ///@param assetId
  Future<chopper.Response<AssetEntityRes>> getAsset({
    required String? assetId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetEntityRes,
      () => AssetEntityRes.fromJsonFactory,
    );

    return _getAsset(assetId: assetId, atoken: atoken?.toString());
  }

  ///get asset by id
  ///@param assetId
  @Get(path: '/Asset/one/{assetId}')
  Future<chopper.Response<AssetEntityRes>> _getAsset({
    @Path('assetId') required String? assetId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search assets
  ///@param body
  Future<chopper.Response<QueryRes>> queryAssets({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryAssets(body: body, atoken: atoken?.toString());
  }

  ///Search assets
  ///@param body
  @Post(path: '/Asset/query')
  Future<chopper.Response<QueryRes>> _queryAssets({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create facility
  ///@param body
  Future<chopper.Response<FacilityEntityRes>> createFacility({
    required FacilityInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FacilityInfo,
      () => FacilityInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      FacilityEntityRes,
      () => FacilityEntityRes.fromJsonFactory,
    );

    return _createFacility(body: body, atoken: atoken?.toString());
  }

  ///Create facility
  ///@param body
  @Post(path: '/Facility/create')
  Future<chopper.Response<FacilityEntityRes>> _createFacility({
    @Body() required FacilityInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update facility
  ///@param facilityId
  ///@param body
  Future<chopper.Response<FacilityEntityRes>> updateFacility({
    String? facilityId,
    required FacilityInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FacilityInfo,
      () => FacilityInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      FacilityEntityRes,
      () => FacilityEntityRes.fromJsonFactory,
    );

    return _updateFacility(
      facilityId: facilityId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update facility
  ///@param facilityId
  ///@param body
  @Post(path: '/Facility/update')
  Future<chopper.Response<FacilityEntityRes>> _updateFacility({
    @Header('facilityId') String? facilityId,
    @Body() required FacilityInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete facility
  ///@param facilityId
  Future<chopper.Response<FacilityEntityRes>> deleteFacility({
    String? facilityId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FacilityEntityRes,
      () => FacilityEntityRes.fromJsonFactory,
    );

    return _deleteFacility(
      facilityId: facilityId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete facility
  ///@param facilityId
  @Delete(path: '/Facility/remove')
  Future<chopper.Response<FacilityEntityRes>> _deleteFacility({
    @Header('facilityId') String? facilityId,
    @Header('ATOKEN') String? atoken,
  });

  ///List facilitys
  ///@param premiseId
  ///@param body
  Future<chopper.Response<FacilityArrayRes>> listFacilities({
    String? premiseId,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      FacilityArrayRes,
      () => FacilityArrayRes.fromJsonFactory,
    );

    return _listFacilities(
      premiseId: premiseId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List facilitys
  ///@param premiseId
  ///@param body
  @Post(path: '/Facility/list')
  Future<chopper.Response<FacilityArrayRes>> _listFacilities({
    @Header('premiseId') String? premiseId,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search facilitys
  ///@param premiseId
  ///@param body
  Future<chopper.Response<FacilityArrayRes>> searchFacilities({
    String? premiseId,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FacilityArrayRes,
      () => FacilityArrayRes.fromJsonFactory,
    );

    return _searchFacilities(
      premiseId: premiseId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search facilitys
  ///@param premiseId
  ///@param body
  @Post(path: '/Facility/search')
  Future<chopper.Response<FacilityArrayRes>> _searchFacilities({
    @Header('premiseId') String? premiseId,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get facilitys
  ///@param body
  Future<chopper.Response<FacilityArrayRes>> getFacilities({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      FacilityArrayRes,
      () => FacilityArrayRes.fromJsonFactory,
    );

    return _getFacilities(body: body, atoken: atoken?.toString());
  }

  ///Get facilitys
  ///@param body
  @Post(path: '/Facility/get')
  Future<chopper.Response<FacilityArrayRes>> _getFacilities({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get facility by id
  ///@param facilityId
  Future<chopper.Response<FacilityEntityRes>> getFacility({
    required String? facilityId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FacilityEntityRes,
      () => FacilityEntityRes.fromJsonFactory,
    );

    return _getFacility(facilityId: facilityId, atoken: atoken?.toString());
  }

  ///get facility by id
  ///@param facilityId
  @Get(path: '/Facility/one/{facilityId}')
  Future<chopper.Response<FacilityEntityRes>> _getFacility({
    @Path('facilityId') required String? facilityId,
    @Header('ATOKEN') String? atoken,
  });

  ///Get stats
  ///@param facilityId
  Future<chopper.Response<FacilityStatsEntityRes>> getFacilityStats({
    required String? facilityId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FacilityStatsEntityRes,
      () => FacilityStatsEntityRes.fromJsonFactory,
    );

    return _getFacilityStats(
      facilityId: facilityId,
      atoken: atoken?.toString(),
    );
  }

  ///Get stats
  ///@param facilityId
  @Get(path: '/Facility/stats/{facilityId}')
  Future<chopper.Response<FacilityStatsEntityRes>> _getFacilityStats({
    @Path('facilityId') required String? facilityId,
    @Header('ATOKEN') String? atoken,
  });

  ///query data
  ///@param body
  Future<chopper.Response<QueryRes>> queryFacilities({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryFacilities(body: body, atoken: atoken?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/Facility/query')
  Future<chopper.Response<QueryRes>> _queryFacilities({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create twin user
  ///@param body
  Future<chopper.Response<TwinUserEntityRes>> createTwinUser({
    required TwinUserInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserInfo,
      () => TwinUserInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      TwinUserEntityRes,
      () => TwinUserEntityRes.fromJsonFactory,
    );

    return _createTwinUser(body: body, atoken: atoken?.toString());
  }

  ///Create twin user
  ///@param body
  @Post(path: '/TwinUser/create')
  Future<chopper.Response<TwinUserEntityRes>> _createTwinUser({
    @Body() required TwinUserInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update twin user
  ///@param twinUserId
  ///@param body
  Future<chopper.Response<TwinUserEntityRes>> updateTwinUser({
    String? twinUserId,
    required TwinUserInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserInfo,
      () => TwinUserInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      TwinUserEntityRes,
      () => TwinUserEntityRes.fromJsonFactory,
    );

    return _updateTwinUser(
      twinUserId: twinUserId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update twin user
  ///@param twinUserId
  ///@param body
  @Post(path: '/TwinUser/update')
  Future<chopper.Response<TwinUserEntityRes>> _updateTwinUser({
    @Header('twinUserId') String? twinUserId,
    @Body() required TwinUserInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete twin user
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> deleteTwinUser({
    String? twinUserId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserEntityRes,
      () => TwinUserEntityRes.fromJsonFactory,
    );

    return _deleteTwinUser(
      twinUserId: twinUserId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete twin user
  ///@param twinUserId
  @Delete(path: '/TwinUser/remove')
  Future<chopper.Response<TwinUserEntityRes>> _deleteTwinUser({
    @Header('twinUserId') String? twinUserId,
    @Header('ATOKEN') String? atoken,
  });

  ///List twin users
  ///@param body
  Future<chopper.Response<TwinUserArrayRes>> listTwinUsers({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      TwinUserArrayRes,
      () => TwinUserArrayRes.fromJsonFactory,
    );

    return _listTwinUsers(body: body, atoken: atoken?.toString());
  }

  ///List twin users
  ///@param body
  @Post(path: '/TwinUser/list')
  Future<chopper.Response<TwinUserArrayRes>> _listTwinUsers({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search twin users
  ///@param body
  Future<chopper.Response<TwinUserArrayRes>> searchTwinUsers({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserArrayRes,
      () => TwinUserArrayRes.fromJsonFactory,
    );

    return _searchTwinUsers(body: body, atoken: atoken?.toString());
  }

  ///Search twin users
  ///@param body
  @Post(path: '/TwinUser/search')
  Future<chopper.Response<TwinUserArrayRes>> _searchTwinUsers({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get twin users
  ///@param body
  Future<chopper.Response<TwinUserArrayRes>> getTwinUsers({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      TwinUserArrayRes,
      () => TwinUserArrayRes.fromJsonFactory,
    );

    return _getTwinUsers(body: body, atoken: atoken?.toString());
  }

  ///Get twin users
  ///@param body
  @Post(path: '/TwinUser/get')
  Future<chopper.Response<TwinUserArrayRes>> _getTwinUsers({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get twin user by id
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> getTwinUser({
    required String? twinUserId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserEntityRes,
      () => TwinUserEntityRes.fromJsonFactory,
    );

    return _getTwinUser(twinUserId: twinUserId, atoken: atoken?.toString());
  }

  ///get twin user by id
  ///@param twinUserId
  @Get(path: '/TwinUser/one/{twinUserId}')
  Future<chopper.Response<TwinUserEntityRes>> _getTwinUser({
    @Path('twinUserId') required String? twinUserId,
    @Header('ATOKEN') String? atoken,
  });

  ///set twin user as admin
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> setAdmin({
    required String? twinUserId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserEntityRes,
      () => TwinUserEntityRes.fromJsonFactory,
    );

    return _setAdmin(twinUserId: twinUserId, atoken: atoken?.toString());
  }

  ///set twin user as admin
  ///@param twinUserId
  @Get(path: '/TwinUser/set/admin/{twinUserId}')
  Future<chopper.Response<TwinUserEntityRes>> _setAdmin({
    @Path('twinUserId') required String? twinUserId,
    @Header('ATOKEN') String? atoken,
  });

  ///set twin user as regular user
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> unsetAdmin({
    required String? twinUserId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserEntityRes,
      () => TwinUserEntityRes.fromJsonFactory,
    );

    return _unsetAdmin(twinUserId: twinUserId, atoken: atoken?.toString());
  }

  ///set twin user as regular user
  ///@param twinUserId
  @Get(path: '/TwinUser/unset/admin/{twinUserId}')
  Future<chopper.Response<TwinUserEntityRes>> _unsetAdmin({
    @Path('twinUserId') required String? twinUserId,
    @Header('ATOKEN') String? atoken,
  });

  ///set twin user as client admin
  ///@param twinUserId
  ///@param clientId
  Future<chopper.Response<TwinUserEntityRes>> setClientAdmin({
    required String? twinUserId,
    required String? clientId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserEntityRes,
      () => TwinUserEntityRes.fromJsonFactory,
    );

    return _setClientAdmin(
      twinUserId: twinUserId,
      clientId: clientId,
      atoken: atoken?.toString(),
    );
  }

  ///set twin user as client admin
  ///@param twinUserId
  ///@param clientId
  @Get(path: '/TwinUser/set/client/admin/{twinUserId}/{clientId}')
  Future<chopper.Response<TwinUserEntityRes>> _setClientAdmin({
    @Path('twinUserId') required String? twinUserId,
    @Path('clientId') required String? clientId,
    @Header('ATOKEN') String? atoken,
  });

  ///set twin user as regular client user
  ///@param twinUserId
  ///@param clientId
  Future<chopper.Response<TwinUserEntityRes>> unsetClientAdmin({
    required String? twinUserId,
    required String? clientId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinUserEntityRes,
      () => TwinUserEntityRes.fromJsonFactory,
    );

    return _unsetClientAdmin(
      twinUserId: twinUserId,
      clientId: clientId,
      atoken: atoken?.toString(),
    );
  }

  ///set twin user as regular client user
  ///@param twinUserId
  ///@param clientId
  @Get(path: '/TwinUser/unset/client/admin/{twinUserId}/{clientId}')
  Future<chopper.Response<TwinUserEntityRes>> _unsetClientAdmin({
    @Path('twinUserId') required String? twinUserId,
    @Path('clientId') required String? clientId,
    @Header('ATOKEN') String? atoken,
  });

  ///count
  Future<chopper.Response<CountRes>> countTwinUsers({dynamic atoken}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countTwinUsers(atoken: atoken?.toString());
  }

  ///count
  @Get(path: '/TwinUser/count')
  Future<chopper.Response<CountRes>> _countTwinUsers({
    @Header('ATOKEN') String? atoken,
  });

  ///Search twin users
  ///@param body
  Future<chopper.Response<QueryRes>> queryTwinUsers({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryTwinUsers(body: body, atoken: atoken?.toString());
  }

  ///Search twin users
  ///@param body
  @Post(path: '/TwinUser/query')
  Future<chopper.Response<QueryRes>> _queryTwinUsers({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create premise
  ///@param body
  Future<chopper.Response<PremiseEntityRes>> createPremise({
    required PremiseInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PremiseInfo,
      () => PremiseInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      PremiseEntityRes,
      () => PremiseEntityRes.fromJsonFactory,
    );

    return _createPremise(body: body, atoken: atoken?.toString());
  }

  ///Create premise
  ///@param body
  @Post(path: '/Premise/create')
  Future<chopper.Response<PremiseEntityRes>> _createPremise({
    @Body() required PremiseInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update premise
  ///@param premiseId
  ///@param body
  Future<chopper.Response<PremiseEntityRes>> updatePremise({
    String? premiseId,
    required PremiseInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PremiseInfo,
      () => PremiseInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      PremiseEntityRes,
      () => PremiseEntityRes.fromJsonFactory,
    );

    return _updatePremise(
      premiseId: premiseId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update premise
  ///@param premiseId
  ///@param body
  @Post(path: '/Premise/update')
  Future<chopper.Response<PremiseEntityRes>> _updatePremise({
    @Header('premiseId') String? premiseId,
    @Body() required PremiseInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete premise
  ///@param premiseId
  Future<chopper.Response<PremiseEntityRes>> deletePremise({
    String? premiseId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PremiseEntityRes,
      () => PremiseEntityRes.fromJsonFactory,
    );

    return _deletePremise(
      premiseId: premiseId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete premise
  ///@param premiseId
  @Delete(path: '/Premise/remove')
  Future<chopper.Response<PremiseEntityRes>> _deletePremise({
    @Header('premiseId') String? premiseId,
    @Header('ATOKEN') String? atoken,
  });

  ///List premises
  ///@param body
  Future<chopper.Response<PremiseArrayRes>> listPremises({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      PremiseArrayRes,
      () => PremiseArrayRes.fromJsonFactory,
    );

    return _listPremises(body: body, atoken: atoken?.toString());
  }

  ///List premises
  ///@param body
  @Post(path: '/Premise/list')
  Future<chopper.Response<PremiseArrayRes>> _listPremises({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search premises
  ///@param body
  Future<chopper.Response<PremiseArrayRes>> searchPremises({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PremiseArrayRes,
      () => PremiseArrayRes.fromJsonFactory,
    );

    return _searchPremises(body: body, atoken: atoken?.toString());
  }

  ///Search premises
  ///@param body
  @Post(path: '/Premise/search')
  Future<chopper.Response<PremiseArrayRes>> _searchPremises({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get premises
  ///@param body
  Future<chopper.Response<PremiseArrayRes>> getPremises({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      PremiseArrayRes,
      () => PremiseArrayRes.fromJsonFactory,
    );

    return _getPremises(body: body, atoken: atoken?.toString());
  }

  ///Get premises
  ///@param body
  @Post(path: '/Premise/get')
  Future<chopper.Response<PremiseArrayRes>> _getPremises({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get premise by id
  ///@param premiseId
  Future<chopper.Response<PremiseEntityRes>> getPremise({
    required String? premiseId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PremiseEntityRes,
      () => PremiseEntityRes.fromJsonFactory,
    );

    return _getPremise(premiseId: premiseId, atoken: atoken?.toString());
  }

  ///get premise by id
  ///@param premiseId
  @Get(path: '/Premise/one/{premiseId}')
  Future<chopper.Response<PremiseEntityRes>> _getPremise({
    @Path('premiseId') required String? premiseId,
    @Header('ATOKEN') String? atoken,
  });

  ///Get stats
  ///@param premiseId
  Future<chopper.Response<PremiseStatsEntityRes>> getPremiseStats({
    required String? premiseId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      PremiseStatsEntityRes,
      () => PremiseStatsEntityRes.fromJsonFactory,
    );

    return _getPremiseStats(premiseId: premiseId, atoken: atoken?.toString());
  }

  ///Get stats
  ///@param premiseId
  @Get(path: '/Premise/stats/{premiseId}')
  Future<chopper.Response<PremiseStatsEntityRes>> _getPremiseStats({
    @Path('premiseId') required String? premiseId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search premises
  ///@param body
  Future<chopper.Response<QueryRes>> queryPremises({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryPremises(body: body, atoken: atoken?.toString());
  }

  ///Search premises
  ///@param body
  @Post(path: '/Premise/query')
  Future<chopper.Response<QueryRes>> _queryPremises({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create scrapping table
  ///@param body
  Future<chopper.Response<ScrappingTableEntityRes>> createScrappingTable({
    required ScrappingTableInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScrappingTableInfo,
      () => ScrappingTableInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ScrappingTableEntityRes,
      () => ScrappingTableEntityRes.fromJsonFactory,
    );

    return _createScrappingTable(body: body, atoken: atoken?.toString());
  }

  ///Create scrapping table
  ///@param body
  @Post(path: '/ScrappingTable/create')
  Future<chopper.Response<ScrappingTableEntityRes>> _createScrappingTable({
    @Body() required ScrappingTableInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update scrapping table
  ///@param scrappingTableId
  ///@param body
  Future<chopper.Response<ScrappingTableEntityRes>> updateScrappingTable({
    String? scrappingTableId,
    required ScrappingTableInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScrappingTableInfo,
      () => ScrappingTableInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ScrappingTableEntityRes,
      () => ScrappingTableEntityRes.fromJsonFactory,
    );

    return _updateScrappingTable(
      scrappingTableId: scrappingTableId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update scrapping table
  ///@param scrappingTableId
  ///@param body
  @Post(path: '/ScrappingTable/update')
  Future<chopper.Response<ScrappingTableEntityRes>> _updateScrappingTable({
    @Header('scrappingTableId') String? scrappingTableId,
    @Body() required ScrappingTableInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete scrappingTable
  ///@param scrappingTableid
  Future<chopper.Response<ScrappingTableEntityRes>> deleteScrappingTable({
    String? scrappingTableid,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScrappingTableEntityRes,
      () => ScrappingTableEntityRes.fromJsonFactory,
    );

    return _deleteScrappingTable(
      scrappingTableid: scrappingTableid?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete scrappingTable
  ///@param scrappingTableid
  @Delete(path: '/ScrappingTable/remove')
  Future<chopper.Response<ScrappingTableEntityRes>> _deleteScrappingTable({
    @Header('scrappingTableid') String? scrappingTableid,
    @Header('ATOKEN') String? atoken,
  });

  ///List scrapping tables
  ///@param body
  Future<chopper.Response<ScrappingTableArrayRes>> listScrappingTables({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ScrappingTableArrayRes,
      () => ScrappingTableArrayRes.fromJsonFactory,
    );

    return _listScrappingTables(body: body, atoken: atoken?.toString());
  }

  ///List scrapping tables
  ///@param body
  @Post(path: '/ScrappingTable/list')
  Future<chopper.Response<ScrappingTableArrayRes>> _listScrappingTables({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search scrapping tables
  ///@param body
  Future<chopper.Response<ScrappingTableArrayRes>> searchScrappingTables({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScrappingTableArrayRes,
      () => ScrappingTableArrayRes.fromJsonFactory,
    );

    return _searchScrappingTables(body: body, atoken: atoken?.toString());
  }

  ///Search scrapping tables
  ///@param body
  @Post(path: '/ScrappingTable/search')
  Future<chopper.Response<ScrappingTableArrayRes>> _searchScrappingTables({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get scrapping tables
  ///@param body
  Future<chopper.Response<ScrappingTableArrayRes>> getScrappingTables({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ScrappingTableArrayRes,
      () => ScrappingTableArrayRes.fromJsonFactory,
    );

    return _getScrappingTables(body: body, atoken: atoken?.toString());
  }

  ///Get scrapping tables
  ///@param body
  @Post(path: '/ScrappingTable/get')
  Future<chopper.Response<ScrappingTableArrayRes>> _getScrappingTables({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get scrapping table by id
  ///@param scrappingTableId
  Future<chopper.Response<ScrappingTableEntityRes>> getScrappingTable({
    required String? scrappingTableId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ScrappingTableEntityRes,
      () => ScrappingTableEntityRes.fromJsonFactory,
    );

    return _getScrappingTable(
      scrappingTableId: scrappingTableId,
      atoken: atoken?.toString(),
    );
  }

  ///get scrapping table by id
  ///@param scrappingTableId
  @Get(path: '/ScrappingTable/one/{scrappingTableId}')
  Future<chopper.Response<ScrappingTableEntityRes>> _getScrappingTable({
    @Path('scrappingTableId') required String? scrappingTableId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search scrapping tables
  ///@param body
  Future<chopper.Response<QueryRes>> queryScrappingTables({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryScrappingTables(body: body, atoken: atoken?.toString());
  }

  ///Search scrapping tables
  ///@param body
  @Post(path: '/ScrappingTable/query')
  Future<chopper.Response<QueryRes>> _queryScrappingTables({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create Asset Group
  ///@param body
  Future<chopper.Response<AssetGroupEntityRes>> createAssetGroup({
    required AssetGroupInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetGroupInfo,
      () => AssetGroupInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      AssetGroupEntityRes,
      () => AssetGroupEntityRes.fromJsonFactory,
    );

    return _createAssetGroup(body: body, atoken: atoken?.toString());
  }

  ///Create Asset Group
  ///@param body
  @Post(path: '/AssetGroup/create')
  Future<chopper.Response<AssetGroupEntityRes>> _createAssetGroup({
    @Body() required AssetGroupInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update Asset Group
  ///@param assetGroupId
  ///@param body
  Future<chopper.Response<AssetGroupEntityRes>> updateAssetGroup({
    String? assetGroupId,
    required AssetGroupInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetGroupInfo,
      () => AssetGroupInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      AssetGroupEntityRes,
      () => AssetGroupEntityRes.fromJsonFactory,
    );

    return _updateAssetGroup(
      assetGroupId: assetGroupId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update Asset Group
  ///@param assetGroupId
  ///@param body
  @Post(path: '/AssetGroup/update')
  Future<chopper.Response<AssetGroupEntityRes>> _updateAssetGroup({
    @Header('assetGroupId') String? assetGroupId,
    @Body() required AssetGroupInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete Asset Group
  ///@param assetGroupId
  Future<chopper.Response<AssetGroupEntityRes>> deleteAssetGroup({
    String? assetGroupId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetGroupEntityRes,
      () => AssetGroupEntityRes.fromJsonFactory,
    );

    return _deleteAssetGroup(
      assetGroupId: assetGroupId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete Asset Group
  ///@param assetGroupId
  @Delete(path: '/AssetGroup/remove')
  Future<chopper.Response<AssetGroupEntityRes>> _deleteAssetGroup({
    @Header('assetGroupId') String? assetGroupId,
    @Header('ATOKEN') String? atoken,
  });

  ///List Asset Groups
  ///@param myGroups
  ///@param body
  Future<chopper.Response<AssetGroupArrayRes>> listAssetGroups({
    bool? myGroups,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AssetGroupArrayRes,
      () => AssetGroupArrayRes.fromJsonFactory,
    );

    return _listAssetGroups(
      myGroups: myGroups?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List Asset Groups
  ///@param myGroups
  ///@param body
  @Post(path: '/AssetGroup/list')
  Future<chopper.Response<AssetGroupArrayRes>> _listAssetGroups({
    @Header('myGroups') String? myGroups,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search Asset Groups
  ///@param myGroups
  ///@param body
  Future<chopper.Response<AssetGroupArrayRes>> searchAssetGroups({
    bool? myGroups,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetGroupArrayRes,
      () => AssetGroupArrayRes.fromJsonFactory,
    );

    return _searchAssetGroups(
      myGroups: myGroups?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search Asset Groups
  ///@param myGroups
  ///@param body
  @Post(path: '/AssetGroup/search')
  Future<chopper.Response<AssetGroupArrayRes>> _searchAssetGroups({
    @Header('myGroups') String? myGroups,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search Asset Groups
  ///@param body
  Future<chopper.Response<QueryRes>> queryAssetGroups({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryAssetGroups(body: body, atoken: atoken?.toString());
  }

  ///Search Asset Groups
  ///@param body
  @Post(path: '/AssetGroup/query')
  Future<chopper.Response<QueryRes>> _queryAssetGroups({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create report
  ///@param body
  Future<chopper.Response<ReportEntityRes>> createReport({
    required ReportInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ReportInfo, () => ReportInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ReportEntityRes,
      () => ReportEntityRes.fromJsonFactory,
    );

    return _createReport(body: body, atoken: atoken?.toString());
  }

  ///Create report
  ///@param body
  @Post(path: '/Report/create')
  Future<chopper.Response<ReportEntityRes>> _createReport({
    @Body() required ReportInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update report
  ///@param reportId
  ///@param body
  Future<chopper.Response<ReportEntityRes>> updateReport({
    String? reportId,
    required ReportInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ReportInfo, () => ReportInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ReportEntityRes,
      () => ReportEntityRes.fromJsonFactory,
    );

    return _updateReport(
      reportId: reportId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update report
  ///@param reportId
  ///@param body
  @Post(path: '/Report/update')
  Future<chopper.Response<ReportEntityRes>> _updateReport({
    @Header('reportId') String? reportId,
    @Body() required ReportInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete report
  ///@param reportId
  Future<chopper.Response<ReportEntityRes>> deleteReport({
    String? reportId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ReportEntityRes,
      () => ReportEntityRes.fromJsonFactory,
    );

    return _deleteReport(
      reportId: reportId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete report
  ///@param reportId
  @Delete(path: '/Report/remove')
  Future<chopper.Response<ReportEntityRes>> _deleteReport({
    @Header('reportId') String? reportId,
    @Header('ATOKEN') String? atoken,
  });

  ///List reports
  ///@param modelId
  ///@param myReports
  ///@param body
  Future<chopper.Response<ReportArrayRes>> listReports({
    String? modelId,
    bool? myReports,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ReportArrayRes,
      () => ReportArrayRes.fromJsonFactory,
    );

    return _listReports(
      modelId: modelId?.toString(),
      myReports: myReports?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List reports
  ///@param modelId
  ///@param myReports
  ///@param body
  @Post(path: '/Report/list')
  Future<chopper.Response<ReportArrayRes>> _listReports({
    @Header('modelId') String? modelId,
    @Header('myReports') String? myReports,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search reports
  ///@param modelId
  ///@param myReports
  ///@param body
  Future<chopper.Response<ReportArrayRes>> searchReports({
    String? modelId,
    bool? myReports,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ReportArrayRes,
      () => ReportArrayRes.fromJsonFactory,
    );

    return _searchReports(
      modelId: modelId?.toString(),
      myReports: myReports?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search reports
  ///@param modelId
  ///@param myReports
  ///@param body
  @Post(path: '/Report/search')
  Future<chopper.Response<ReportArrayRes>> _searchReports({
    @Header('modelId') String? modelId,
    @Header('myReports') String? myReports,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get reports
  ///@param body
  Future<chopper.Response<ReportArrayRes>> getReports({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ReportArrayRes,
      () => ReportArrayRes.fromJsonFactory,
    );

    return _getReports(body: body, atoken: atoken?.toString());
  }

  ///Get reports
  ///@param body
  @Post(path: '/Report/get')
  Future<chopper.Response<ReportArrayRes>> _getReports({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get report by id
  ///@param reportId
  Future<chopper.Response<ReportEntityRes>> getReport({
    required String? reportId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ReportEntityRes,
      () => ReportEntityRes.fromJsonFactory,
    );

    return _getReport(reportId: reportId, atoken: atoken?.toString());
  }

  ///get report by id
  ///@param reportId
  @Get(path: '/Report/one/{reportId}')
  Future<chopper.Response<ReportEntityRes>> _getReport({
    @Path('reportId') required String? reportId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search reports
  ///@param body
  Future<chopper.Response<QueryRes>> queryReports({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryReports(body: body, atoken: atoken?.toString());
  }

  ///Search reports
  ///@param body
  @Post(path: '/Report/query')
  Future<chopper.Response<QueryRes>> _queryReports({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create asset model
  ///@param body
  Future<chopper.Response<AssetModelEntityRes>> createAssetModel({
    required AssetModelInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetModelInfo,
      () => AssetModelInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      AssetModelEntityRes,
      () => AssetModelEntityRes.fromJsonFactory,
    );

    return _createAssetModel(body: body, atoken: atoken?.toString());
  }

  ///Create asset model
  ///@param body
  @Post(path: '/AssetModel/create')
  Future<chopper.Response<AssetModelEntityRes>> _createAssetModel({
    @Body() required AssetModelInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update asset model
  ///@param assetModelId
  ///@param body
  Future<chopper.Response<AssetModelEntityRes>> updateAssetModel({
    String? assetModelId,
    required AssetModelInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetModelInfo,
      () => AssetModelInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      AssetModelEntityRes,
      () => AssetModelEntityRes.fromJsonFactory,
    );

    return _updateAssetModel(
      assetModelId: assetModelId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update asset model
  ///@param assetModelId
  ///@param body
  @Post(path: '/AssetModel/update')
  Future<chopper.Response<AssetModelEntityRes>> _updateAssetModel({
    @Header('assetModelId') String? assetModelId,
    @Body() required AssetModelInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete asset model
  ///@param assetModelId
  Future<chopper.Response<AssetModelEntityRes>> deleteAssetModel({
    String? assetModelId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetModelEntityRes,
      () => AssetModelEntityRes.fromJsonFactory,
    );

    return _deleteAssetModel(
      assetModelId: assetModelId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete asset model
  ///@param assetModelId
  @Delete(path: '/AssetModel/remove')
  Future<chopper.Response<AssetModelEntityRes>> _deleteAssetModel({
    @Header('assetModelId') String? assetModelId,
    @Header('ATOKEN') String? atoken,
  });

  ///List asset models
  ///@param body
  Future<chopper.Response<AssetModelArrayRes>> listAssetModels({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AssetModelArrayRes,
      () => AssetModelArrayRes.fromJsonFactory,
    );

    return _listAssetModels(body: body, atoken: atoken?.toString());
  }

  ///List asset models
  ///@param body
  @Post(path: '/AssetModel/list')
  Future<chopper.Response<AssetModelArrayRes>> _listAssetModels({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search asset models
  ///@param body
  Future<chopper.Response<AssetModelArrayRes>> searchAssetModels({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetModelArrayRes,
      () => AssetModelArrayRes.fromJsonFactory,
    );

    return _searchAssetModels(body: body, atoken: atoken?.toString());
  }

  ///Search asset models
  ///@param body
  @Post(path: '/AssetModel/search')
  Future<chopper.Response<AssetModelArrayRes>> _searchAssetModels({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get asset models
  ///@param body
  Future<chopper.Response<AssetModelArrayRes>> getAssetModels({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      AssetModelArrayRes,
      () => AssetModelArrayRes.fromJsonFactory,
    );

    return _getAssetModels(body: body, atoken: atoken?.toString());
  }

  ///Get asset models
  ///@param body
  @Post(path: '/AssetModel/get')
  Future<chopper.Response<AssetModelArrayRes>> _getAssetModels({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get asset model by id
  ///@param assetModelId
  Future<chopper.Response<AssetModelEntityRes>> getAssetModel({
    required String? assetModelId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      AssetModelEntityRes,
      () => AssetModelEntityRes.fromJsonFactory,
    );

    return _getAssetModel(
      assetModelId: assetModelId,
      atoken: atoken?.toString(),
    );
  }

  ///get asset model by id
  ///@param assetModelId
  @Get(path: '/AssetModel/one/{assetModelId}')
  Future<chopper.Response<AssetModelEntityRes>> _getAssetModel({
    @Path('assetModelId') required String? assetModelId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search asset models
  ///@param body
  Future<chopper.Response<QueryRes>> queryAssetModels({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryAssetModels(body: body, atoken: atoken?.toString());
  }

  ///Search asset models
  ///@param body
  @Post(path: '/AssetModel/query')
  Future<chopper.Response<QueryRes>> _queryAssetModels({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create field filter
  ///@param body
  Future<chopper.Response<FieldFilterEntityRes>> createFieldFilter({
    required FieldFilterInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FieldFilterInfo,
      () => FieldFilterInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      FieldFilterEntityRes,
      () => FieldFilterEntityRes.fromJsonFactory,
    );

    return _createFieldFilter(body: body, atoken: atoken?.toString());
  }

  ///Create field filter
  ///@param body
  @Post(path: '/FieldFilter/create')
  Future<chopper.Response<FieldFilterEntityRes>> _createFieldFilter({
    @Body() required FieldFilterInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update field filter
  ///@param fieldFilterId
  ///@param body
  Future<chopper.Response<FieldFilterEntityRes>> updateFieldFilter({
    String? fieldFilterId,
    required FieldFilterInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FieldFilterInfo,
      () => FieldFilterInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      FieldFilterEntityRes,
      () => FieldFilterEntityRes.fromJsonFactory,
    );

    return _updateFieldFilter(
      fieldFilterId: fieldFilterId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update field filter
  ///@param fieldFilterId
  ///@param body
  @Post(path: '/FieldFilter/update')
  Future<chopper.Response<FieldFilterEntityRes>> _updateFieldFilter({
    @Header('fieldFilterId') String? fieldFilterId,
    @Body() required FieldFilterInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete field filter
  ///@param fieldFilterId
  Future<chopper.Response<FieldFilterEntityRes>> deleteFieldFilter({
    String? fieldFilterId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FieldFilterEntityRes,
      () => FieldFilterEntityRes.fromJsonFactory,
    );

    return _deleteFieldFilter(
      fieldFilterId: fieldFilterId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete field filter
  ///@param fieldFilterId
  @Delete(path: '/FieldFilter/remove')
  Future<chopper.Response<FieldFilterEntityRes>> _deleteFieldFilter({
    @Header('fieldFilterId') String? fieldFilterId,
    @Header('ATOKEN') String? atoken,
  });

  ///List field filters
  ///@param myFilters
  ///@param body
  Future<chopper.Response<FieldFilterArrayRes>> listFieldFilters({
    bool? myFilters,
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      FieldFilterArrayRes,
      () => FieldFilterArrayRes.fromJsonFactory,
    );

    return _listFieldFilters(
      myFilters: myFilters?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///List field filters
  ///@param myFilters
  ///@param body
  @Post(path: '/FieldFilter/list')
  Future<chopper.Response<FieldFilterArrayRes>> _listFieldFilters({
    @Header('myFilters') String? myFilters,
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search field filters
  ///@param myFilters
  ///@param body
  Future<chopper.Response<FieldFilterArrayRes>> searchFieldFilters({
    bool? myFilters,
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FieldFilterArrayRes,
      () => FieldFilterArrayRes.fromJsonFactory,
    );

    return _searchFieldFilters(
      myFilters: myFilters?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search field filters
  ///@param myFilters
  ///@param body
  @Post(path: '/FieldFilter/search')
  Future<chopper.Response<FieldFilterArrayRes>> _searchFieldFilters({
    @Header('myFilters') String? myFilters,
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get field filters
  ///@param body
  Future<chopper.Response<FieldFilterArrayRes>> getFieldFilters({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      FieldFilterArrayRes,
      () => FieldFilterArrayRes.fromJsonFactory,
    );

    return _getFieldFilters(body: body, atoken: atoken?.toString());
  }

  ///Get field filters
  ///@param body
  @Post(path: '/FieldFilter/get')
  Future<chopper.Response<FieldFilterArrayRes>> _getFieldFilters({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get field filter by id
  ///@param fieldFilterId
  Future<chopper.Response<FieldFilterEntityRes>> getFieldFilter({
    required String? fieldFilterId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      FieldFilterEntityRes,
      () => FieldFilterEntityRes.fromJsonFactory,
    );

    return _getFieldFilter(
      fieldFilterId: fieldFilterId,
      atoken: atoken?.toString(),
    );
  }

  ///get field filter by id
  ///@param fieldFilterId
  @Get(path: '/FieldFilter/one/{fieldFilterId}')
  Future<chopper.Response<FieldFilterEntityRes>> _getFieldFilter({
    @Path('fieldFilterId') required String? fieldFilterId,
    @Header('ATOKEN') String? atoken,
  });

  ///Search field filters
  ///@param body
  Future<chopper.Response<QueryRes>> queryFieldFilters({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryFieldFilters(body: body, atoken: atoken?.toString());
  }

  ///Search field filters
  ///@param body
  @Post(path: '/FieldFilter/query')
  Future<chopper.Response<QueryRes>> _queryFieldFilters({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create client
  ///@param body
  Future<chopper.Response<ClientEntityRes>> createClient({
    required ClientInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ClientInfo, () => ClientInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ClientEntityRes,
      () => ClientEntityRes.fromJsonFactory,
    );

    return _createClient(body: body, atoken: atoken?.toString());
  }

  ///Create client
  ///@param body
  @Post(path: '/Client/create')
  Future<chopper.Response<ClientEntityRes>> _createClient({
    @Body() required ClientInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update client
  ///@param clientId
  ///@param body
  Future<chopper.Response<ClientEntityRes>> updateClient({
    String? clientId,
    required ClientInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ClientInfo, () => ClientInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ClientEntityRes,
      () => ClientEntityRes.fromJsonFactory,
    );

    return _updateClient(
      clientId: clientId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update client
  ///@param clientId
  ///@param body
  @Post(path: '/Client/update')
  Future<chopper.Response<ClientEntityRes>> _updateClient({
    @Header('clientId') String? clientId,
    @Body() required ClientInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete client
  ///@param clientId
  Future<chopper.Response<ClientEntityRes>> deleteClient({
    String? clientId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ClientEntityRes,
      () => ClientEntityRes.fromJsonFactory,
    );

    return _deleteClient(
      clientId: clientId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete client
  ///@param clientId
  @Delete(path: '/Client/remove')
  Future<chopper.Response<ClientEntityRes>> _deleteClient({
    @Header('clientId') String? clientId,
    @Header('ATOKEN') String? atoken,
  });

  ///List clients
  ///@param body
  Future<chopper.Response<ClientArrayRes>> listClients({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ClientArrayRes,
      () => ClientArrayRes.fromJsonFactory,
    );

    return _listClients(body: body, atoken: atoken?.toString());
  }

  ///List clients
  ///@param body
  @Post(path: '/Client/list')
  Future<chopper.Response<ClientArrayRes>> _listClients({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search clients
  ///@param body
  Future<chopper.Response<ClientArrayRes>> searchClients({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ClientArrayRes,
      () => ClientArrayRes.fromJsonFactory,
    );

    return _searchClients(body: body, atoken: atoken?.toString());
  }

  ///Search clients
  ///@param body
  @Post(path: '/Client/search')
  Future<chopper.Response<ClientArrayRes>> _searchClients({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get clients
  ///@param body
  Future<chopper.Response<ClientArrayRes>> getClients({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ClientArrayRes,
      () => ClientArrayRes.fromJsonFactory,
    );

    return _getClients(body: body, atoken: atoken?.toString());
  }

  ///Get clients
  ///@param body
  @Post(path: '/Client/get')
  Future<chopper.Response<ClientArrayRes>> _getClients({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get client by id
  ///@param clientId
  Future<chopper.Response<ClientEntityRes>> getClient({
    required String? clientId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ClientEntityRes,
      () => ClientEntityRes.fromJsonFactory,
    );

    return _getClient(clientId: clientId, atoken: atoken?.toString());
  }

  ///get client by id
  ///@param clientId
  @Get(path: '/Client/one/{clientId}')
  Future<chopper.Response<ClientEntityRes>> _getClient({
    @Path('clientId') required String? clientId,
    @Header('ATOKEN') String? atoken,
  });

  ///count
  Future<chopper.Response<CountRes>> countClients({dynamic atoken}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countClients(atoken: atoken?.toString());
  }

  ///count
  @Get(path: '/Client/count')
  Future<chopper.Response<CountRes>> _countClients({
    @Header('ATOKEN') String? atoken,
  });

  ///Search clients
  ///@param body
  Future<chopper.Response<QueryRes>> queryClients({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryClients(body: body, atoken: atoken?.toString());
  }

  ///Search clients
  ///@param body
  @Post(path: '/Client/query')
  Future<chopper.Response<QueryRes>> _queryClients({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create update custom entity mapping
  ///@param body
  Future<chopper.Response<CustomEntityMappingRes>> upsertCustomEntityMapping({
    required CustomEntityMappingInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      CustomEntityMappingInfo,
      () => CustomEntityMappingInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      CustomEntityMappingRes,
      () => CustomEntityMappingRes.fromJsonFactory,
    );

    return _upsertCustomEntityMapping(body: body, atoken: atoken?.toString());
  }

  ///Create update custom entity mapping
  ///@param body
  @Post(path: '/CustomEntity/mapping/set')
  Future<chopper.Response<CustomEntityMappingRes>> _upsertCustomEntityMapping({
    @Body() required CustomEntityMappingInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get custom entity mapping
  ///@param name
  Future<chopper.Response<CustomEntityMappingRes>> getCustomEntityMapping({
    required String? name,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      CustomEntityMappingRes,
      () => CustomEntityMappingRes.fromJsonFactory,
    );

    return _getCustomEntityMapping(name: name, atoken: atoken?.toString());
  }

  ///Get custom entity mapping
  ///@param name
  @Get(path: '/CustomEntity/mapping/get/{name}')
  Future<chopper.Response<CustomEntityMappingRes>> _getCustomEntityMapping({
    @Path('name') required String? name,
    @Header('ATOKEN') String? atoken,
  });

  ///Get custom entity mapping
  Future<chopper.Response<CustomEntityMappingArrayRes>>
  listCustomEntityMapping({dynamic atoken}) {
    generatedMapping.putIfAbsent(
      CustomEntityMappingArrayRes,
      () => CustomEntityMappingArrayRes.fromJsonFactory,
    );

    return _listCustomEntityMapping(atoken: atoken?.toString());
  }

  ///Get custom entity mapping
  @Get(path: '/CustomEntity/mapping/list')
  Future<chopper.Response<CustomEntityMappingArrayRes>>
  _listCustomEntityMapping({@Header('ATOKEN') String? atoken});

  ///Create custom entity
  ///@param name
  ///@param id
  ///@param body
  Future<chopper.Response<CustomEntityRes>> createCustomEntity({
    required String? name,
    String? id,
    required Object? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      CustomEntityRes,
      () => CustomEntityRes.fromJsonFactory,
    );

    return _createCustomEntity(
      name: name,
      id: id?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Create custom entity
  ///@param name
  ///@param id
  ///@param body
  @Post(path: '/CustomEntity/create/{name}')
  Future<chopper.Response<CustomEntityRes>> _createCustomEntity({
    @Path('name') required String? name,
    @Header('id') String? id,
    @Body() required Object? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update custom entity
  ///@param name
  ///@param id
  ///@param body
  Future<chopper.Response<CustomEntityRes>> updateCustomEntity({
    required String? name,
    required String? id,
    required Object? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      CustomEntityRes,
      () => CustomEntityRes.fromJsonFactory,
    );

    return _updateCustomEntity(
      name: name,
      id: id,
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update custom entity
  ///@param name
  ///@param id
  ///@param body
  @Post(path: '/CustomEntity/update/{name}/{id}')
  Future<chopper.Response<CustomEntityRes>> _updateCustomEntity({
    @Path('name') required String? name,
    @Path('id') required String? id,
    @Body() required Object? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Remove custom entity
  ///@param name
  ///@param id
  Future<chopper.Response<CustomEntityRes>> deleteCustomEntity({
    required String? name,
    required String? id,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      CustomEntityRes,
      () => CustomEntityRes.fromJsonFactory,
    );

    return _deleteCustomEntity(name: name, id: id, atoken: atoken?.toString());
  }

  ///Remove custom entity
  ///@param name
  ///@param id
  @Delete(path: '/CustomEntity/remove/{name}/{id}')
  Future<chopper.Response<CustomEntityRes>> _deleteCustomEntity({
    @Path('name') required String? name,
    @Path('id') required String? id,
    @Header('ATOKEN') String? atoken,
  });

  ///Get custom entity
  ///@param name
  ///@param id
  Future<chopper.Response<CustomEntityRes>> getCustomEntity({
    required String? name,
    required String? id,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      CustomEntityRes,
      () => CustomEntityRes.fromJsonFactory,
    );

    return _getCustomEntity(name: name, id: id, atoken: atoken?.toString());
  }

  ///Get custom entity
  ///@param name
  ///@param id
  @Get(path: '/CustomEntity/get/{name}/{id}')
  Future<chopper.Response<CustomEntityRes>> _getCustomEntity({
    @Path('name') required String? name,
    @Path('id') required String? id,
    @Header('ATOKEN') String? atoken,
  });

  ///Search custom entities
  ///@param name
  ///@param body
  Future<chopper.Response<CustomEntityArrayRes>> searchCustomEntities({
    required String? name,
    required CustomSearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      CustomEntityArrayRes,
      () => CustomEntityArrayRes.fromJsonFactory,
    );

    return _searchCustomEntities(
      name: name,
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search custom entities
  ///@param name
  ///@param body
  @Post(path: '/CustomEntity/search/{name}')
  Future<chopper.Response<CustomEntityArrayRes>> _searchCustomEntities({
    @Path('name') required String? name,
    @Body() required CustomSearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Remove all custom entities
  ///@param name
  Future<chopper.Response<BaseResponse>> removeAllCustomEntities({
    required String? name,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _removeAllCustomEntities(name: name, atoken: atoken?.toString());
  }

  ///Remove all custom entities
  ///@param name
  @Delete(path: '/CustomEntity/clear/{name}')
  Future<chopper.Response<BaseResponse>> _removeAllCustomEntities({
    @Path('name') required String? name,
    @Header('ATOKEN') String? atoken,
  });

  ///bulk upload
  ///@param name
  ///@param file
  Future<chopper.Response<BaseResponse>> bulkUploadCustomEntityCsv({
    required String? name,
    required List<int>? file,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _bulkUploadCustomEntityCsv(
      name: name,
      file: file,
      atoken: atoken?.toString(),
    );
  }

  ///bulk upload
  ///@param name
  ///@param file
  @Post(path: '/CustomEntity/bulk/upload/csv/{name}', optionalBody: true)
  Future<chopper.Response<BaseResponse>> _bulkUploadCustomEntityCsv({
    @Path('name') required String? name,
    @Field('file') required List<int>? file,
    @Header('ATOKEN') String? atoken,
  });

  ///bulk upload
  ///@param file
  ///@param sheet
  Future<chopper.Response<BaseResponse>> bulkUploadCustomEntityExcel({
    required List<int>? file,
    required List<String>? sheet,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      BaseResponse,
      () => BaseResponse.fromJsonFactory,
    );

    return _bulkUploadCustomEntityExcel(
      file: file,
      sheet: sheet,
      atoken: atoken?.toString(),
    );
  }

  ///bulk upload
  ///@param file
  ///@param sheet
  @Post(path: '/CustomEntity/bulk/upload/excel', optionalBody: true)
  Future<chopper.Response<BaseResponse>> _bulkUploadCustomEntityExcel({
    @Field('file') required List<int>? file,
    @Field('sheet') required List<String>? sheet,
    @Header('ATOKEN') String? atoken,
  });

  ///Search custom entities
  ///@param name
  ///@param body
  Future<chopper.Response<QueryRes>> queryCustomEntities({
    required String? name,
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryCustomEntities(
      name: name,
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Search custom entities
  ///@param name
  ///@param body
  @Post(path: '/CustomEntity/query/{name}')
  Future<chopper.Response<QueryRes>> _queryCustomEntities({
    @Path('name') required String? name,
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Upload twin image
  ///@param tags
  ///@param file
  Future<chopper.Response<TwinImageEntityRes>> uploadImage({
    String? tags,
    required List<int>? file,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinImageEntityRes,
      () => TwinImageEntityRes.fromJsonFactory,
    );

    return _uploadImage(
      tags: tags?.toString(),
      file: file,
      atoken: atoken?.toString(),
    );
  }

  ///Upload twin image
  ///@param tags
  ///@param file
  @Post(path: '/TwinImage/upload', optionalBody: true)
  Future<chopper.Response<TwinImageEntityRes>> _uploadImage({
    @Header('tags') String? tags,
    @Field('file') required List<int>? file,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete image
  ///@param id Image ID
  Future<chopper.Response<TwinImageEntityRes>> deleteImage({
    required String? id,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinImageEntityRes,
      () => TwinImageEntityRes.fromJsonFactory,
    );

    return _deleteImage(id: id, atoken: atoken?.toString());
  }

  ///Delete image
  ///@param id Image ID
  @Delete(path: '/TwinImage/remove/{id}')
  Future<chopper.Response<TwinImageEntityRes>> _deleteImage({
    @Path('id') required String? id,
    @Header('ATOKEN') String? atoken,
  });

  ///Get image
  ///@param domainKey Domain key
  ///@param id Image ID
  Future<chopper.Response<List<int>>> domanloadImage({
    required String? domainKey,
    required String? id,
  }) {
    return _domanloadImage(domainKey: domainKey, id: id);
  }

  ///Get image
  ///@param domainKey Domain key
  ///@param id Image ID
  @Get(path: '/TwinImage/download/{domainKey}/{id}')
  Future<chopper.Response<List<int>>> _domanloadImage({
    @Path('domainKey') required String? domainKey,
    @Path('id') required String? id,
  });

  ///Search images
  ///@param body
  Future<chopper.Response<TwinImageArrayRes>> searchImages({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinImageArrayRes,
      () => TwinImageArrayRes.fromJsonFactory,
    );

    return _searchImages(body: body, atoken: atoken?.toString());
  }

  ///Search images
  ///@param body
  @Post(path: '/TwinImage/search')
  Future<chopper.Response<TwinImageArrayRes>> _searchImages({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search images by tags
  ///@param body
  Future<chopper.Response<TwinImageArrayRes>> searchImagesByTags({
    required SearchTagReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      TwinImageArrayRes,
      () => TwinImageArrayRes.fromJsonFactory,
    );

    return _searchImagesByTags(body: body, atoken: atoken?.toString());
  }

  ///Search images by tags
  ///@param body
  @Post(path: '/TwinImage/search/tags')
  Future<chopper.Response<TwinImageArrayRes>> _searchImagesByTags({
    @Body() required SearchTagReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search images
  ///@param body
  Future<chopper.Response<QueryRes>> queryImages({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryImages(body: body, atoken: atoken?.toString());
  }

  ///Search images
  ///@param body
  @Post(path: '/TwinImage/query')
  Future<chopper.Response<QueryRes>> _queryImages({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create token
  ///@param body
  Future<chopper.Response<ApiTokenEntityRes>> createApiToken({
    required ApiTokenInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ApiTokenInfo,
      () => ApiTokenInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      ApiTokenEntityRes,
      () => ApiTokenEntityRes.fromJsonFactory,
    );

    return _createApiToken(body: body, atoken: atoken?.toString());
  }

  ///Create token
  ///@param body
  @Post(path: '/ApiToken/create')
  Future<chopper.Response<ApiTokenEntityRes>> _createApiToken({
    @Body() required ApiTokenInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete token
  ///@param tokenId
  Future<chopper.Response<ApiTokenEntityRes>> deleteApiToken({
    String? tokenId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      ApiTokenEntityRes,
      () => ApiTokenEntityRes.fromJsonFactory,
    );

    return _deleteApiToken(
      tokenId: tokenId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete token
  ///@param tokenId
  @Delete(path: '/ApiToken/remove')
  Future<chopper.Response<ApiTokenEntityRes>> _deleteApiToken({
    @Header('tokenId') String? tokenId,
    @Header('ATOKEN') String? atoken,
  });

  ///List tokens
  ///@param body
  Future<chopper.Response<ApiTokenArrayRes>> listTokens({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      ApiTokenArrayRes,
      () => ApiTokenArrayRes.fromJsonFactory,
    );

    return _listTokens(body: body, atoken: atoken?.toString());
  }

  ///List tokens
  ///@param body
  @Post(path: '/ApiToken/list')
  Future<chopper.Response<ApiTokenArrayRes>> _listTokens({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Create eql template
  ///@param body
  Future<chopper.Response<EqlTemplateEntityRes>> createEqlTemplate({
    required EqlTemplateInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EqlTemplateInfo,
      () => EqlTemplateInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      EqlTemplateEntityRes,
      () => EqlTemplateEntityRes.fromJsonFactory,
    );

    return _createEqlTemplate(body: body, atoken: atoken?.toString());
  }

  ///Create eql template
  ///@param body
  @Post(path: '/EqlTemplate/create')
  Future<chopper.Response<EqlTemplateEntityRes>> _createEqlTemplate({
    @Body() required EqlTemplateInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Update eql template
  ///@param eqlTemplateId
  ///@param body
  Future<chopper.Response<EqlTemplateEntityRes>> updateEqlTemplate({
    String? eqlTemplateId,
    required EqlTemplateInfo? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EqlTemplateInfo,
      () => EqlTemplateInfo.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(
      EqlTemplateEntityRes,
      () => EqlTemplateEntityRes.fromJsonFactory,
    );

    return _updateEqlTemplate(
      eqlTemplateId: eqlTemplateId?.toString(),
      body: body,
      atoken: atoken?.toString(),
    );
  }

  ///Update eql template
  ///@param eqlTemplateId
  ///@param body
  @Post(path: '/EqlTemplate/update')
  Future<chopper.Response<EqlTemplateEntityRes>> _updateEqlTemplate({
    @Header('eqlTemplateId') String? eqlTemplateId,
    @Body() required EqlTemplateInfo? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Delete eql template
  ///@param eqlTemplateId
  Future<chopper.Response<EqlTemplateEntityRes>> deleteEqlTemplate({
    String? eqlTemplateId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EqlTemplateEntityRes,
      () => EqlTemplateEntityRes.fromJsonFactory,
    );

    return _deleteEqlTemplate(
      eqlTemplateId: eqlTemplateId?.toString(),
      atoken: atoken?.toString(),
    );
  }

  ///Delete eql template
  ///@param eqlTemplateId
  @Delete(path: '/EqlTemplate/remove')
  Future<chopper.Response<EqlTemplateEntityRes>> _deleteEqlTemplate({
    @Header('eqlTemplateId') String? eqlTemplateId,
    @Header('ATOKEN') String? atoken,
  });

  ///List eql templates
  ///@param body
  Future<chopper.Response<EqlTemplateArrayRes>> listEqlTemplates({
    required ListReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      EqlTemplateArrayRes,
      () => EqlTemplateArrayRes.fromJsonFactory,
    );

    return _listEqlTemplates(body: body, atoken: atoken?.toString());
  }

  ///List eql templates
  ///@param body
  @Post(path: '/EqlTemplate/list')
  Future<chopper.Response<EqlTemplateArrayRes>> _listEqlTemplates({
    @Body() required ListReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Search eql templates
  ///@param body
  Future<chopper.Response<EqlTemplateArrayRes>> searchEqlTemplates({
    required SearchReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EqlTemplateArrayRes,
      () => EqlTemplateArrayRes.fromJsonFactory,
    );

    return _searchEqlTemplates(body: body, atoken: atoken?.toString());
  }

  ///Search eql templates
  ///@param body
  @Post(path: '/EqlTemplate/search')
  Future<chopper.Response<EqlTemplateArrayRes>> _searchEqlTemplates({
    @Body() required SearchReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///Get eql templates
  ///@param body
  Future<chopper.Response<EqlTemplateArrayRes>> getEqlTemplates({
    required GetReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
      EqlTemplateArrayRes,
      () => EqlTemplateArrayRes.fromJsonFactory,
    );

    return _getEqlTemplates(body: body, atoken: atoken?.toString());
  }

  ///Get eql templates
  ///@param body
  @Post(path: '/EqlTemplate/get')
  Future<chopper.Response<EqlTemplateArrayRes>> _getEqlTemplates({
    @Body() required GetReq? body,
    @Header('ATOKEN') String? atoken,
  });

  ///get eql template by id
  ///@param eqlTemplateId
  Future<chopper.Response<EqlTemplateEntityRes>> getEqlTemplate({
    required String? eqlTemplateId,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EqlTemplateEntityRes,
      () => EqlTemplateEntityRes.fromJsonFactory,
    );

    return _getEqlTemplate(
      eqlTemplateId: eqlTemplateId,
      atoken: atoken?.toString(),
    );
  }

  ///get eql template by id
  ///@param eqlTemplateId
  @Get(path: '/EqlTemplate/one/{eqlTemplateId}')
  Future<chopper.Response<EqlTemplateEntityRes>> _getEqlTemplate({
    @Path('eqlTemplateId') required String? eqlTemplateId,
    @Header('ATOKEN') String? atoken,
  });

  ///Execute eql template
  ///@param eql
  Future<chopper.Response<QueryRes>> executeEqlTemplate({
    required EqlExecuteReq? eql,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(
      EqlExecuteReq,
      () => EqlExecuteReq.fromJsonFactory,
    );
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _executeEqlTemplate(eql: eql, atoken: atoken?.toString());
  }

  ///Execute eql template
  ///@param eql
  @Post(path: '/EqlTemplate/execute')
  Future<chopper.Response<QueryRes>> _executeEqlTemplate({
    @Body() required EqlExecuteReq? eql,
    @Header('ATOKEN') String? atoken,
  });

  ///Search eql templates
  ///@param body
  Future<chopper.Response<QueryRes>> queryEqlTemplates({
    required QueryReq? body,
    dynamic atoken,
  }) {
    generatedMapping.putIfAbsent(QueryReq, () => QueryReq.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryEqlTemplates(body: body, atoken: atoken?.toString());
  }

  ///Search eql templates
  ///@param body
  @Post(path: '/EqlTemplate/query')
  Future<chopper.Response<QueryRes>> _queryEqlTemplates({
    @Body() required QueryReq? body,
    @Header('ATOKEN') String? atoken,
  });
}

@JsonSerializable(explicitToJson: true)
class BaseResponse {
  const BaseResponse({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory BaseResponse.fromJson(Map<String, dynamic> json) =>
      _$BaseResponseFromJson(json);

  static const toJsonFactory = _$BaseResponseToJson;
  Map<String, dynamic> toJson() => _$BaseResponseToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$BaseResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseResponse &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $BaseResponseExtension on BaseResponse {
  BaseResponse copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
  }) {
    return BaseResponse(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
    );
  }

  BaseResponse copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
  }) {
    return BaseResponse(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BaseEntity {
  const BaseEntity({
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory BaseEntity.fromJson(Map<String, dynamic> json) =>
      _$BaseEntityFromJson(json);

  static const toJsonFactory = _$BaseEntityToJson;
  Map<String, dynamic> toJson() => _$BaseEntityToJson(this);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$BaseEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseEntity &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $BaseEntityExtension on BaseEntity {
  BaseEntity copyWith({
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return BaseEntity(
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  BaseEntity copyWithWrapped({
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return BaseEntity(
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayableEntity {
  const DisplayableEntity({
    this.description,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
  });

  factory DisplayableEntity.fromJson(Map<String, dynamic> json) =>
      _$DisplayableEntityFromJson(json);

  static const toJsonFactory = _$DisplayableEntityToJson;
  Map<String, dynamic> toJson() => _$DisplayableEntityToJson(this);

  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  static const fromJsonFactory = _$DisplayableEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayableEntity &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      runtimeType.hashCode;
}

extension $DisplayableEntityExtension on DisplayableEntity {
  DisplayableEntity copyWith({
    String? description,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
  }) {
    return DisplayableEntity(
      description: description ?? this.description,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
    );
  }

  DisplayableEntity copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
  }) {
    return DisplayableEntity(
      description: (description != null ? description.value : this.description),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DomainBaseInfo {
  const DomainBaseInfo({
    required this.name,
    required this.email,
    this.phone,
    this.userName,
    this.allowRegistration,
    this.properties,
    this.location,
    this.customIndexes,
  });

  factory DomainBaseInfo.fromJson(Map<String, dynamic> json) =>
      _$DomainBaseInfoFromJson(json);

  static const toJsonFactory = _$DomainBaseInfoToJson;
  Map<String, dynamic> toJson() => _$DomainBaseInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'userName', includeIfNull: false, defaultValue: '')
  final String? userName;
  @JsonKey(name: 'allowRegistration', includeIfNull: false)
  final bool? allowRegistration;
  @JsonKey(name: 'properties', includeIfNull: false)
  final Object? properties;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(
    name: 'customIndexes',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String>? customIndexes;
  static const fromJsonFactory = _$DomainBaseInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DomainBaseInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality().equals(
                  other.userName,
                  userName,
                )) &&
            (identical(other.allowRegistration, allowRegistration) ||
                const DeepCollectionEquality().equals(
                  other.allowRegistration,
                  allowRegistration,
                )) &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality().equals(
                  other.properties,
                  properties,
                )) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.customIndexes, customIndexes) ||
                const DeepCollectionEquality().equals(
                  other.customIndexes,
                  customIndexes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(allowRegistration) ^
      const DeepCollectionEquality().hash(properties) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(customIndexes) ^
      runtimeType.hashCode;
}

extension $DomainBaseInfoExtension on DomainBaseInfo {
  DomainBaseInfo copyWith({
    String? name,
    String? email,
    String? phone,
    String? userName,
    bool? allowRegistration,
    Object? properties,
    GeoLocation? location,
    List<String>? customIndexes,
  }) {
    return DomainBaseInfo(
      name: name ?? this.name,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      userName: userName ?? this.userName,
      allowRegistration: allowRegistration ?? this.allowRegistration,
      properties: properties ?? this.properties,
      location: location ?? this.location,
      customIndexes: customIndexes ?? this.customIndexes,
    );
  }

  DomainBaseInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? userName,
    Wrapped<bool?>? allowRegistration,
    Wrapped<Object?>? properties,
    Wrapped<GeoLocation?>? location,
    Wrapped<List<String>?>? customIndexes,
  }) {
    return DomainBaseInfo(
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      userName: (userName != null ? userName.value : this.userName),
      allowRegistration: (allowRegistration != null
          ? allowRegistration.value
          : this.allowRegistration),
      properties: (properties != null ? properties.value : this.properties),
      location: (location != null ? location.value : this.location),
      customIndexes: (customIndexes != null
          ? customIndexes.value
          : this.customIndexes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DomainInfo {
  const DomainInfo({
    this.description,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
    required this.name,
    required this.email,
    this.phone,
    this.userName,
    this.allowRegistration,
    this.properties,
    this.location,
    this.customIndexes,
  });

  factory DomainInfo.fromJson(Map<String, dynamic> json) =>
      _$DomainInfoFromJson(json);

  static const toJsonFactory = _$DomainInfoToJson;
  Map<String, dynamic> toJson() => _$DomainInfoToJson(this);

  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'userName', includeIfNull: false, defaultValue: '')
  final String? userName;
  @JsonKey(name: 'allowRegistration', includeIfNull: false)
  final bool? allowRegistration;
  @JsonKey(name: 'properties', includeIfNull: false)
  final Object? properties;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(
    name: 'customIndexes',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String>? customIndexes;
  static const fromJsonFactory = _$DomainInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DomainInfo &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality().equals(
                  other.userName,
                  userName,
                )) &&
            (identical(other.allowRegistration, allowRegistration) ||
                const DeepCollectionEquality().equals(
                  other.allowRegistration,
                  allowRegistration,
                )) &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality().equals(
                  other.properties,
                  properties,
                )) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.customIndexes, customIndexes) ||
                const DeepCollectionEquality().equals(
                  other.customIndexes,
                  customIndexes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(allowRegistration) ^
      const DeepCollectionEquality().hash(properties) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(customIndexes) ^
      runtimeType.hashCode;
}

extension $DomainInfoExtension on DomainInfo {
  DomainInfo copyWith({
    String? description,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
    String? name,
    String? email,
    String? phone,
    String? userName,
    bool? allowRegistration,
    Object? properties,
    GeoLocation? location,
    List<String>? customIndexes,
  }) {
    return DomainInfo(
      description: description ?? this.description,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
      name: name ?? this.name,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      userName: userName ?? this.userName,
      allowRegistration: allowRegistration ?? this.allowRegistration,
      properties: properties ?? this.properties,
      location: location ?? this.location,
      customIndexes: customIndexes ?? this.customIndexes,
    );
  }

  DomainInfo copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
    Wrapped<String>? name,
    Wrapped<String>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? userName,
    Wrapped<bool?>? allowRegistration,
    Wrapped<Object?>? properties,
    Wrapped<GeoLocation?>? location,
    Wrapped<List<String>?>? customIndexes,
  }) {
    return DomainInfo(
      description: (description != null ? description.value : this.description),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      userName: (userName != null ? userName.value : this.userName),
      allowRegistration: (allowRegistration != null
          ? allowRegistration.value
          : this.allowRegistration),
      properties: (properties != null ? properties.value : this.properties),
      location: (location != null ? location.value : this.location),
      customIndexes: (customIndexes != null
          ? customIndexes.value
          : this.customIndexes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BaseDomainEntity {
  const BaseDomainEntity({this.domainKey, this.entityState});

  factory BaseDomainEntity.fromJson(Map<String, dynamic> json) =>
      _$BaseDomainEntityFromJson(json);

  static const toJsonFactory = _$BaseDomainEntityToJson;
  Map<String, dynamic> toJson() => _$BaseDomainEntityToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(
    name: 'entityState',
    includeIfNull: false,
    toJson: baseDomainEntityEntityStateNullableToJson,
    fromJson: baseDomainEntityEntityStateNullableFromJson,
  )
  final enums.BaseDomainEntityEntityState? entityState;
  static const fromJsonFactory = _$BaseDomainEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseDomainEntity &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.entityState, entityState) ||
                const DeepCollectionEquality().equals(
                  other.entityState,
                  entityState,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(entityState) ^
      runtimeType.hashCode;
}

extension $BaseDomainEntityExtension on BaseDomainEntity {
  BaseDomainEntity copyWith({
    String? domainKey,
    enums.BaseDomainEntityEntityState? entityState,
  }) {
    return BaseDomainEntity(
      domainKey: domainKey ?? this.domainKey,
      entityState: entityState ?? this.entityState,
    );
  }

  BaseDomainEntity copyWithWrapped({
    Wrapped<String?>? domainKey,
    Wrapped<enums.BaseDomainEntityEntityState?>? entityState,
  }) {
    return BaseDomainEntity(
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      entityState: (entityState != null ? entityState.value : this.entityState),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Domain {
  const Domain({
    this.domainKey,
    this.entityState,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Domain.fromJson(Map<String, dynamic> json) => _$DomainFromJson(json);

  static const toJsonFactory = _$DomainToJson;
  Map<String, dynamic> toJson() => _$DomainToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(
    name: 'entityState',
    includeIfNull: false,
    toJson: domainEntityStateNullableToJson,
    fromJson: domainEntityStateNullableFromJson,
  )
  final enums.DomainEntityState? entityState;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$DomainFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Domain &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.entityState, entityState) ||
                const DeepCollectionEquality().equals(
                  other.entityState,
                  entityState,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(entityState) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $DomainExtension on Domain {
  Domain copyWith({
    String? domainKey,
    enums.DomainEntityState? entityState,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Domain(
      domainKey: domainKey ?? this.domainKey,
      entityState: entityState ?? this.entityState,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Domain copyWithWrapped({
    Wrapped<String?>? domainKey,
    Wrapped<enums.DomainEntityState?>? entityState,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Domain(
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      entityState: (entityState != null ? entityState.value : this.entityState),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FireReq {
  const FireReq({
    required this.deviceId,
    required this.controlId,
    required this.controlState,
    this.arguments,
  });

  factory FireReq.fromJson(Map<String, dynamic> json) =>
      _$FireReqFromJson(json);

  static const toJsonFactory = _$FireReqToJson;
  Map<String, dynamic> toJson() => _$FireReqToJson(this);

  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String controlId;
  @JsonKey(name: 'controlState', includeIfNull: false)
  final int controlState;
  @JsonKey(name: 'arguments', includeIfNull: false)
  final Object? arguments;
  static const fromJsonFactory = _$FireReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FireReq &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality().equals(
                  other.controlId,
                  controlId,
                )) &&
            (identical(other.controlState, controlState) ||
                const DeepCollectionEquality().equals(
                  other.controlState,
                  controlState,
                )) &&
            (identical(other.arguments, arguments) ||
                const DeepCollectionEquality().equals(
                  other.arguments,
                  arguments,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(controlState) ^
      const DeepCollectionEquality().hash(arguments) ^
      runtimeType.hashCode;
}

extension $FireReqExtension on FireReq {
  FireReq copyWith({
    String? deviceId,
    String? controlId,
    int? controlState,
    Object? arguments,
  }) {
    return FireReq(
      deviceId: deviceId ?? this.deviceId,
      controlId: controlId ?? this.controlId,
      controlState: controlState ?? this.controlState,
      arguments: arguments ?? this.arguments,
    );
  }

  FireReq copyWithWrapped({
    Wrapped<String>? deviceId,
    Wrapped<String>? controlId,
    Wrapped<int>? controlState,
    Wrapped<Object?>? arguments,
  }) {
    return FireReq(
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      controlId: (controlId != null ? controlId.value : this.controlId),
      controlState: (controlState != null
          ? controlState.value
          : this.controlState),
      arguments: (arguments != null ? arguments.value : this.arguments),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GetReq {
  const GetReq({required this.ids});

  factory GetReq.fromJson(Map<String, dynamic> json) => _$GetReqFromJson(json);

  static const toJsonFactory = _$GetReqToJson;
  Map<String, dynamic> toJson() => _$GetReqToJson(this);

  @JsonKey(name: 'ids', includeIfNull: false, defaultValue: <String>[])
  final List<String> ids;
  static const fromJsonFactory = _$GetReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetReq &&
            (identical(other.ids, ids) ||
                const DeepCollectionEquality().equals(other.ids, ids)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ids) ^ runtimeType.hashCode;
}

extension $GetReqExtension on GetReq {
  GetReq copyWith({List<String>? ids}) {
    return GetReq(ids: ids ?? this.ids);
  }

  GetReq copyWithWrapped({Wrapped<List<String>>? ids}) {
    return GetReq(ids: (ids != null ? ids.value : this.ids));
  }
}

@JsonSerializable(explicitToJson: true)
class ListReq {
  const ListReq({required this.page, required this.size});

  factory ListReq.fromJson(Map<String, dynamic> json) =>
      _$ListReqFromJson(json);

  static const toJsonFactory = _$ListReqToJson;
  Map<String, dynamic> toJson() => _$ListReqToJson(this);

  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  static const fromJsonFactory = _$ListReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListReq &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $ListReqExtension on ListReq {
  ListReq copyWith({int? page, int? size}) {
    return ListReq(page: page ?? this.page, size: size ?? this.size);
  }

  ListReq copyWithWrapped({Wrapped<int>? page, Wrapped<int>? size}) {
    return ListReq(
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ListRes {
  const ListRes({required this.page, required this.size, required this.total});

  factory ListRes.fromJson(Map<String, dynamic> json) =>
      _$ListResFromJson(json);

  static const toJsonFactory = _$ListResToJson;
  Map<String, dynamic> toJson() => _$ListResToJson(this);

  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  static const fromJsonFactory = _$ListResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListRes &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $ListResExtension on ListRes {
  ListRes copyWith({int? page, int? size, int? total}) {
    return ListRes(
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
    );
  }

  ListRes copyWithWrapped({
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
  }) {
    return ListRes(
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SearchReqBase {
  const SearchReqBase({required this.query});

  factory SearchReqBase.fromJson(Map<String, dynamic> json) =>
      _$SearchReqBaseFromJson(json);

  static const toJsonFactory = _$SearchReqBaseToJson;
  Map<String, dynamic> toJson() => _$SearchReqBaseToJson(this);

  @JsonKey(name: 'query', includeIfNull: false)
  final Object query;
  static const fromJsonFactory = _$SearchReqBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchReqBase &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(query) ^ runtimeType.hashCode;
}

extension $SearchReqBaseExtension on SearchReqBase {
  SearchReqBase copyWith({Object? query}) {
    return SearchReqBase(query: query ?? this.query);
  }

  SearchReqBase copyWithWrapped({Wrapped<Object>? query}) {
    return SearchReqBase(query: (query != null ? query.value : this.query));
  }
}

@JsonSerializable(explicitToJson: true)
class SearchReq {
  const SearchReq({
    required this.query,
    required this.page,
    required this.size,
  });

  factory SearchReq.fromJson(Map<String, dynamic> json) =>
      _$SearchReqFromJson(json);

  static const toJsonFactory = _$SearchReqToJson;
  Map<String, dynamic> toJson() => _$SearchReqToJson(this);

  @JsonKey(name: 'query', includeIfNull: false)
  final Object query;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  static const fromJsonFactory = _$SearchReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchReq &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $SearchReqExtension on SearchReq {
  SearchReq copyWith({Object? query, int? page, int? size}) {
    return SearchReq(
      query: query ?? this.query,
      page: page ?? this.page,
      size: size ?? this.size,
    );
  }

  SearchReq copyWithWrapped({
    Wrapped<Object>? query,
    Wrapped<int>? page,
    Wrapped<int>? size,
  }) {
    return SearchReq(
      query: (query != null ? query.value : this.query),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class QueryReq {
  const QueryReq({required this.eqlTemplateName, this.context});

  factory QueryReq.fromJson(Map<String, dynamic> json) =>
      _$QueryReqFromJson(json);

  static const toJsonFactory = _$QueryReqToJson;
  Map<String, dynamic> toJson() => _$QueryReqToJson(this);

  @JsonKey(name: 'eqlTemplateName', includeIfNull: false, defaultValue: '')
  final String eqlTemplateName;
  @JsonKey(name: 'context', includeIfNull: false)
  final Object? context;
  static const fromJsonFactory = _$QueryReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QueryReq &&
            (identical(other.eqlTemplateName, eqlTemplateName) ||
                const DeepCollectionEquality().equals(
                  other.eqlTemplateName,
                  eqlTemplateName,
                )) &&
            (identical(other.context, context) ||
                const DeepCollectionEquality().equals(other.context, context)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eqlTemplateName) ^
      const DeepCollectionEquality().hash(context) ^
      runtimeType.hashCode;
}

extension $QueryReqExtension on QueryReq {
  QueryReq copyWith({String? eqlTemplateName, Object? context}) {
    return QueryReq(
      eqlTemplateName: eqlTemplateName ?? this.eqlTemplateName,
      context: context ?? this.context,
    );
  }

  QueryReq copyWithWrapped({
    Wrapped<String>? eqlTemplateName,
    Wrapped<Object?>? context,
  }) {
    return QueryReq(
      eqlTemplateName: (eqlTemplateName != null
          ? eqlTemplateName.value
          : this.eqlTemplateName),
      context: (context != null ? context.value : this.context),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SearchTagReqBase {
  const SearchTagReqBase({required this.tags});

  factory SearchTagReqBase.fromJson(Map<String, dynamic> json) =>
      _$SearchTagReqBaseFromJson(json);

  static const toJsonFactory = _$SearchTagReqBaseToJson;
  Map<String, dynamic> toJson() => _$SearchTagReqBaseToJson(this);

  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: '')
  final String tags;
  static const fromJsonFactory = _$SearchTagReqBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchTagReqBase &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tags) ^ runtimeType.hashCode;
}

extension $SearchTagReqBaseExtension on SearchTagReqBase {
  SearchTagReqBase copyWith({String? tags}) {
    return SearchTagReqBase(tags: tags ?? this.tags);
  }

  SearchTagReqBase copyWithWrapped({Wrapped<String>? tags}) {
    return SearchTagReqBase(tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class SearchTagReq {
  const SearchTagReq({
    required this.tags,
    required this.page,
    required this.size,
  });

  factory SearchTagReq.fromJson(Map<String, dynamic> json) =>
      _$SearchTagReqFromJson(json);

  static const toJsonFactory = _$SearchTagReqToJson;
  Map<String, dynamic> toJson() => _$SearchTagReqToJson(this);

  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: '')
  final String tags;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  static const fromJsonFactory = _$SearchTagReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchTagReq &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $SearchTagReqExtension on SearchTagReq {
  SearchTagReq copyWith({String? tags, int? page, int? size}) {
    return SearchTagReq(
      tags: tags ?? this.tags,
      page: page ?? this.page,
      size: size ?? this.size,
    );
  }

  SearchTagReq copyWithWrapped({
    Wrapped<String>? tags,
    Wrapped<int>? page,
    Wrapped<int>? size,
  }) {
    return SearchTagReq(
      tags: (tags != null ? tags.value : this.tags),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RangeFilter {
  const RangeFilter({this.tz, this.filter, this.beginStamp, this.endStamp});

  factory RangeFilter.fromJson(Map<String, dynamic> json) =>
      _$RangeFilterFromJson(json);

  static const toJsonFactory = _$RangeFilterToJson;
  Map<String, dynamic> toJson() => _$RangeFilterToJson(this);

  @JsonKey(name: 'tz', includeIfNull: false, defaultValue: '')
  final String? tz;
  @JsonKey(
    name: 'filter',
    includeIfNull: false,
    toJson: rangeFilterFilterNullableToJson,
    fromJson: rangeFilterFilterNullableFromJson,
  )
  final enums.RangeFilterFilter? filter;
  @JsonKey(name: 'beginStamp', includeIfNull: false)
  final int? beginStamp;
  @JsonKey(name: 'endStamp', includeIfNull: false)
  final int? endStamp;
  static const fromJsonFactory = _$RangeFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RangeFilter &&
            (identical(other.tz, tz) ||
                const DeepCollectionEquality().equals(other.tz, tz)) &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)) &&
            (identical(other.beginStamp, beginStamp) ||
                const DeepCollectionEquality().equals(
                  other.beginStamp,
                  beginStamp,
                )) &&
            (identical(other.endStamp, endStamp) ||
                const DeepCollectionEquality().equals(
                  other.endStamp,
                  endStamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tz) ^
      const DeepCollectionEquality().hash(filter) ^
      const DeepCollectionEquality().hash(beginStamp) ^
      const DeepCollectionEquality().hash(endStamp) ^
      runtimeType.hashCode;
}

extension $RangeFilterExtension on RangeFilter {
  RangeFilter copyWith({
    String? tz,
    enums.RangeFilterFilter? filter,
    int? beginStamp,
    int? endStamp,
  }) {
    return RangeFilter(
      tz: tz ?? this.tz,
      filter: filter ?? this.filter,
      beginStamp: beginStamp ?? this.beginStamp,
      endStamp: endStamp ?? this.endStamp,
    );
  }

  RangeFilter copyWithWrapped({
    Wrapped<String?>? tz,
    Wrapped<enums.RangeFilterFilter?>? filter,
    Wrapped<int?>? beginStamp,
    Wrapped<int?>? endStamp,
  }) {
    return RangeFilter(
      tz: (tz != null ? tz.value : this.tz),
      filter: (filter != null ? filter.value : this.filter),
      beginStamp: (beginStamp != null ? beginStamp.value : this.beginStamp),
      endStamp: (endStamp != null ? endStamp.value : this.endStamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FilterReqBase {
  const FilterReqBase({this.filter});

  factory FilterReqBase.fromJson(Map<String, dynamic> json) =>
      _$FilterReqBaseFromJson(json);

  static const toJsonFactory = _$FilterReqBaseToJson;
  Map<String, dynamic> toJson() => _$FilterReqBaseToJson(this);

  @JsonKey(name: 'filter', includeIfNull: false)
  final RangeFilter? filter;
  static const fromJsonFactory = _$FilterReqBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterReqBase &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(filter) ^ runtimeType.hashCode;
}

extension $FilterReqBaseExtension on FilterReqBase {
  FilterReqBase copyWith({RangeFilter? filter}) {
    return FilterReqBase(filter: filter ?? this.filter);
  }

  FilterReqBase copyWithWrapped({Wrapped<RangeFilter?>? filter}) {
    return FilterReqBase(filter: (filter != null ? filter.value : this.filter));
  }
}

@JsonSerializable(explicitToJson: true)
class FilterSearchReq {
  const FilterSearchReq({
    required this.query,
    this.filter,
    required this.page,
    required this.size,
  });

  factory FilterSearchReq.fromJson(Map<String, dynamic> json) =>
      _$FilterSearchReqFromJson(json);

  static const toJsonFactory = _$FilterSearchReqToJson;
  Map<String, dynamic> toJson() => _$FilterSearchReqToJson(this);

  @JsonKey(name: 'query', includeIfNull: false)
  final Object query;
  @JsonKey(name: 'filter', includeIfNull: false)
  final RangeFilter? filter;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  static const fromJsonFactory = _$FilterSearchReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterSearchReq &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(filter) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $FilterSearchReqExtension on FilterSearchReq {
  FilterSearchReq copyWith({
    Object? query,
    RangeFilter? filter,
    int? page,
    int? size,
  }) {
    return FilterSearchReq(
      query: query ?? this.query,
      filter: filter ?? this.filter,
      page: page ?? this.page,
      size: size ?? this.size,
    );
  }

  FilterSearchReq copyWithWrapped({
    Wrapped<Object>? query,
    Wrapped<RangeFilter?>? filter,
    Wrapped<int>? page,
    Wrapped<int>? size,
  }) {
    return FilterSearchReq(
      query: (query != null ? query.value : this.query),
      filter: (filter != null ? filter.value : this.filter),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Parameter {
  const Parameter({
    required this.name,
    this.description,
    this.label,
    required this.parameterType,
    required this.required,
    this.defaultValue,
    this.enableTrend,
    this.enableTimeSeries,
    this.unit,
    this.icon,
    this.sensorWidget,
  });

  factory Parameter.fromJson(Map<String, dynamic> json) =>
      _$ParameterFromJson(json);

  static const toJsonFactory = _$ParameterToJson;
  Map<String, dynamic> toJson() => _$ParameterToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(
    name: 'parameterType',
    includeIfNull: false,
    toJson: parameterParameterTypeToJson,
    fromJson: parameterParameterTypeFromJson,
  )
  final enums.ParameterParameterType parameterType;
  @JsonKey(name: 'required', includeIfNull: false, defaultValue: false)
  final bool required;
  @JsonKey(name: 'defaultValue', includeIfNull: false, defaultValue: '')
  final String? defaultValue;
  @JsonKey(name: 'enableTrend', includeIfNull: false, defaultValue: false)
  final bool? enableTrend;
  @JsonKey(name: 'enableTimeSeries', includeIfNull: false, defaultValue: false)
  final bool? enableTimeSeries;
  @JsonKey(name: 'unit', includeIfNull: false, defaultValue: '')
  final String? unit;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'sensorWidget', includeIfNull: false)
  final SensorWidget? sensorWidget;
  static const fromJsonFactory = _$ParameterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Parameter &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.parameterType, parameterType) ||
                const DeepCollectionEquality().equals(
                  other.parameterType,
                  parameterType,
                )) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality().equals(
                  other.required,
                  required,
                )) &&
            (identical(other.defaultValue, defaultValue) ||
                const DeepCollectionEquality().equals(
                  other.defaultValue,
                  defaultValue,
                )) &&
            (identical(other.enableTrend, enableTrend) ||
                const DeepCollectionEquality().equals(
                  other.enableTrend,
                  enableTrend,
                )) &&
            (identical(other.enableTimeSeries, enableTimeSeries) ||
                const DeepCollectionEquality().equals(
                  other.enableTimeSeries,
                  enableTimeSeries,
                )) &&
            (identical(other.unit, unit) ||
                const DeepCollectionEquality().equals(other.unit, unit)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.sensorWidget, sensorWidget) ||
                const DeepCollectionEquality().equals(
                  other.sensorWidget,
                  sensorWidget,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(parameterType) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(defaultValue) ^
      const DeepCollectionEquality().hash(enableTrend) ^
      const DeepCollectionEquality().hash(enableTimeSeries) ^
      const DeepCollectionEquality().hash(unit) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(sensorWidget) ^
      runtimeType.hashCode;
}

extension $ParameterExtension on Parameter {
  Parameter copyWith({
    String? name,
    String? description,
    String? label,
    enums.ParameterParameterType? parameterType,
    bool? required,
    String? defaultValue,
    bool? enableTrend,
    bool? enableTimeSeries,
    String? unit,
    String? icon,
    SensorWidget? sensorWidget,
  }) {
    return Parameter(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      parameterType: parameterType ?? this.parameterType,
      required: required ?? this.required,
      defaultValue: defaultValue ?? this.defaultValue,
      enableTrend: enableTrend ?? this.enableTrend,
      enableTimeSeries: enableTimeSeries ?? this.enableTimeSeries,
      unit: unit ?? this.unit,
      icon: icon ?? this.icon,
      sensorWidget: sensorWidget ?? this.sensorWidget,
    );
  }

  Parameter copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<enums.ParameterParameterType>? parameterType,
    Wrapped<bool>? required,
    Wrapped<String?>? defaultValue,
    Wrapped<bool?>? enableTrend,
    Wrapped<bool?>? enableTimeSeries,
    Wrapped<String?>? unit,
    Wrapped<String?>? icon,
    Wrapped<SensorWidget?>? sensorWidget,
  }) {
    return Parameter(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      parameterType: (parameterType != null
          ? parameterType.value
          : this.parameterType),
      required: (required != null ? required.value : this.required),
      defaultValue: (defaultValue != null
          ? defaultValue.value
          : this.defaultValue),
      enableTrend: (enableTrend != null ? enableTrend.value : this.enableTrend),
      enableTimeSeries: (enableTimeSeries != null
          ? enableTimeSeries.value
          : this.enableTimeSeries),
      unit: (unit != null ? unit.value : this.unit),
      icon: (icon != null ? icon.value : this.icon),
      sensorWidget: (sensorWidget != null
          ? sensorWidget.value
          : this.sensorWidget),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableConfig {
  const ScrappingTableConfig({
    required this.lookupName,
    required this.scrappingTableName,
    required this.scrappingTableIds,
  });

  factory ScrappingTableConfig.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableConfigFromJson(json);

  static const toJsonFactory = _$ScrappingTableConfigToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableConfigToJson(this);

  @JsonKey(name: 'lookupName', includeIfNull: false, defaultValue: '')
  final String lookupName;
  @JsonKey(name: 'scrappingTableName', includeIfNull: false, defaultValue: '')
  final String scrappingTableName;
  @JsonKey(
    name: 'scrappingTableIds',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String> scrappingTableIds;
  static const fromJsonFactory = _$ScrappingTableConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableConfig &&
            (identical(other.lookupName, lookupName) ||
                const DeepCollectionEquality().equals(
                  other.lookupName,
                  lookupName,
                )) &&
            (identical(other.scrappingTableName, scrappingTableName) ||
                const DeepCollectionEquality().equals(
                  other.scrappingTableName,
                  scrappingTableName,
                )) &&
            (identical(other.scrappingTableIds, scrappingTableIds) ||
                const DeepCollectionEquality().equals(
                  other.scrappingTableIds,
                  scrappingTableIds,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lookupName) ^
      const DeepCollectionEquality().hash(scrappingTableName) ^
      const DeepCollectionEquality().hash(scrappingTableIds) ^
      runtimeType.hashCode;
}

extension $ScrappingTableConfigExtension on ScrappingTableConfig {
  ScrappingTableConfig copyWith({
    String? lookupName,
    String? scrappingTableName,
    List<String>? scrappingTableIds,
  }) {
    return ScrappingTableConfig(
      lookupName: lookupName ?? this.lookupName,
      scrappingTableName: scrappingTableName ?? this.scrappingTableName,
      scrappingTableIds: scrappingTableIds ?? this.scrappingTableIds,
    );
  }

  ScrappingTableConfig copyWithWrapped({
    Wrapped<String>? lookupName,
    Wrapped<String>? scrappingTableName,
    Wrapped<List<String>>? scrappingTableIds,
  }) {
    return ScrappingTableConfig(
      lookupName: (lookupName != null ? lookupName.value : this.lookupName),
      scrappingTableName: (scrappingTableName != null
          ? scrappingTableName.value
          : this.scrappingTableName),
      scrappingTableIds: (scrappingTableIds != null
          ? scrappingTableIds.value
          : this.scrappingTableIds),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelInfo {
  const DeviceModelInfo({
    required this.name,
    this.description,
    required this.make,
    required this.model,
    required this.version,
    required this.parameters,
    this.tags,
    this.metadata,
    this.defaultView,
    this.preprocessorId,
    this.hasGeoLocation,
    this.movable,
    this.customWidget,
    this.makePublic,
    this.scrappingTableConfigs,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
  });

  factory DeviceModelInfo.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelInfoFromJson(json);

  static const toJsonFactory = _$DeviceModelInfoToJson;
  Map<String, dynamic> toJson() => _$DeviceModelInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'make', includeIfNull: false, defaultValue: '')
  final String make;
  @JsonKey(name: 'model', includeIfNull: false, defaultValue: '')
  final String model;
  @JsonKey(name: 'version', includeIfNull: false, defaultValue: '')
  final String version;
  @JsonKey(
    name: 'parameters',
    includeIfNull: false,
    defaultValue: <Parameter>[],
  )
  final List<Parameter> parameters;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'defaultView', includeIfNull: false, defaultValue: '')
  final String? defaultView;
  @JsonKey(name: 'preprocessorId', includeIfNull: false, defaultValue: '')
  final String? preprocessorId;
  @JsonKey(name: 'hasGeoLocation', includeIfNull: false)
  final bool? hasGeoLocation;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(name: 'customWidget', includeIfNull: false)
  final CustomWidget? customWidget;
  @JsonKey(name: 'makePublic', includeIfNull: false, defaultValue: false)
  final bool? makePublic;
  @JsonKey(
    name: 'scrappingTableConfigs',
    includeIfNull: false,
    defaultValue: <ScrappingTableConfig>[],
  )
  final List<ScrappingTableConfig>? scrappingTableConfigs;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  static const fromJsonFactory = _$DeviceModelInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.make, make) ||
                const DeepCollectionEquality().equals(other.make, make)) &&
            (identical(other.model, model) ||
                const DeepCollectionEquality().equals(other.model, model)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(
                  other.version,
                  version,
                )) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality().equals(
                  other.parameters,
                  parameters,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.defaultView, defaultView) ||
                const DeepCollectionEquality().equals(
                  other.defaultView,
                  defaultView,
                )) &&
            (identical(other.preprocessorId, preprocessorId) ||
                const DeepCollectionEquality().equals(
                  other.preprocessorId,
                  preprocessorId,
                )) &&
            (identical(other.hasGeoLocation, hasGeoLocation) ||
                const DeepCollectionEquality().equals(
                  other.hasGeoLocation,
                  hasGeoLocation,
                )) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality().equals(
                  other.movable,
                  movable,
                )) &&
            (identical(other.customWidget, customWidget) ||
                const DeepCollectionEquality().equals(
                  other.customWidget,
                  customWidget,
                )) &&
            (identical(other.makePublic, makePublic) ||
                const DeepCollectionEquality().equals(
                  other.makePublic,
                  makePublic,
                )) &&
            (identical(other.scrappingTableConfigs, scrappingTableConfigs) ||
                const DeepCollectionEquality().equals(
                  other.scrappingTableConfigs,
                  scrappingTableConfigs,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(make) ^
      const DeepCollectionEquality().hash(model) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(defaultView) ^
      const DeepCollectionEquality().hash(preprocessorId) ^
      const DeepCollectionEquality().hash(hasGeoLocation) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(customWidget) ^
      const DeepCollectionEquality().hash(makePublic) ^
      const DeepCollectionEquality().hash(scrappingTableConfigs) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      runtimeType.hashCode;
}

extension $DeviceModelInfoExtension on DeviceModelInfo {
  DeviceModelInfo copyWith({
    String? name,
    String? description,
    String? make,
    String? model,
    String? version,
    List<Parameter>? parameters,
    List<String>? tags,
    Object? metadata,
    String? defaultView,
    String? preprocessorId,
    bool? hasGeoLocation,
    bool? movable,
    CustomWidget? customWidget,
    bool? makePublic,
    List<ScrappingTableConfig>? scrappingTableConfigs,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
  }) {
    return DeviceModelInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      make: make ?? this.make,
      model: model ?? this.model,
      version: version ?? this.version,
      parameters: parameters ?? this.parameters,
      tags: tags ?? this.tags,
      metadata: metadata ?? this.metadata,
      defaultView: defaultView ?? this.defaultView,
      preprocessorId: preprocessorId ?? this.preprocessorId,
      hasGeoLocation: hasGeoLocation ?? this.hasGeoLocation,
      movable: movable ?? this.movable,
      customWidget: customWidget ?? this.customWidget,
      makePublic: makePublic ?? this.makePublic,
      scrappingTableConfigs:
          scrappingTableConfigs ?? this.scrappingTableConfigs,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
    );
  }

  DeviceModelInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? make,
    Wrapped<String>? model,
    Wrapped<String>? version,
    Wrapped<List<Parameter>>? parameters,
    Wrapped<List<String>?>? tags,
    Wrapped<Object?>? metadata,
    Wrapped<String?>? defaultView,
    Wrapped<String?>? preprocessorId,
    Wrapped<bool?>? hasGeoLocation,
    Wrapped<bool?>? movable,
    Wrapped<CustomWidget?>? customWidget,
    Wrapped<bool?>? makePublic,
    Wrapped<List<ScrappingTableConfig>?>? scrappingTableConfigs,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
  }) {
    return DeviceModelInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      make: (make != null ? make.value : this.make),
      model: (model != null ? model.value : this.model),
      version: (version != null ? version.value : this.version),
      parameters: (parameters != null ? parameters.value : this.parameters),
      tags: (tags != null ? tags.value : this.tags),
      metadata: (metadata != null ? metadata.value : this.metadata),
      defaultView: (defaultView != null ? defaultView.value : this.defaultView),
      preprocessorId: (preprocessorId != null
          ? preprocessorId.value
          : this.preprocessorId),
      hasGeoLocation: (hasGeoLocation != null
          ? hasGeoLocation.value
          : this.hasGeoLocation),
      movable: (movable != null ? movable.value : this.movable),
      customWidget: (customWidget != null
          ? customWidget.value
          : this.customWidget),
      makePublic: (makePublic != null ? makePublic.value : this.makePublic),
      scrappingTableConfigs: (scrappingTableConfigs != null
          ? scrappingTableConfigs.value
          : this.scrappingTableConfigs),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModel {
  const DeviceModel({
    required this.name,
    this.description,
    required this.make,
    required this.model,
    required this.version,
    required this.parameters,
    this.tags,
    this.metadata,
    this.defaultView,
    this.preprocessorId,
    this.hasGeoLocation,
    this.movable,
    this.customWidget,
    this.makePublic,
    this.scrappingTableConfigs,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
  });

  factory DeviceModel.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelFromJson(json);

  static const toJsonFactory = _$DeviceModelToJson;
  Map<String, dynamic> toJson() => _$DeviceModelToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'make', includeIfNull: false, defaultValue: '')
  final String make;
  @JsonKey(name: 'model', includeIfNull: false, defaultValue: '')
  final String model;
  @JsonKey(name: 'version', includeIfNull: false, defaultValue: '')
  final String version;
  @JsonKey(
    name: 'parameters',
    includeIfNull: false,
    defaultValue: <Parameter>[],
  )
  final List<Parameter> parameters;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'defaultView', includeIfNull: false, defaultValue: '')
  final String? defaultView;
  @JsonKey(name: 'preprocessorId', includeIfNull: false, defaultValue: '')
  final String? preprocessorId;
  @JsonKey(name: 'hasGeoLocation', includeIfNull: false)
  final bool? hasGeoLocation;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(name: 'customWidget', includeIfNull: false)
  final CustomWidget? customWidget;
  @JsonKey(name: 'makePublic', includeIfNull: false, defaultValue: false)
  final bool? makePublic;
  @JsonKey(
    name: 'scrappingTableConfigs',
    includeIfNull: false,
    defaultValue: <ScrappingTableConfig>[],
  )
  final List<ScrappingTableConfig>? scrappingTableConfigs;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  static const fromJsonFactory = _$DeviceModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.make, make) ||
                const DeepCollectionEquality().equals(other.make, make)) &&
            (identical(other.model, model) ||
                const DeepCollectionEquality().equals(other.model, model)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(
                  other.version,
                  version,
                )) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality().equals(
                  other.parameters,
                  parameters,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.defaultView, defaultView) ||
                const DeepCollectionEquality().equals(
                  other.defaultView,
                  defaultView,
                )) &&
            (identical(other.preprocessorId, preprocessorId) ||
                const DeepCollectionEquality().equals(
                  other.preprocessorId,
                  preprocessorId,
                )) &&
            (identical(other.hasGeoLocation, hasGeoLocation) ||
                const DeepCollectionEquality().equals(
                  other.hasGeoLocation,
                  hasGeoLocation,
                )) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality().equals(
                  other.movable,
                  movable,
                )) &&
            (identical(other.customWidget, customWidget) ||
                const DeepCollectionEquality().equals(
                  other.customWidget,
                  customWidget,
                )) &&
            (identical(other.makePublic, makePublic) ||
                const DeepCollectionEquality().equals(
                  other.makePublic,
                  makePublic,
                )) &&
            (identical(other.scrappingTableConfigs, scrappingTableConfigs) ||
                const DeepCollectionEquality().equals(
                  other.scrappingTableConfigs,
                  scrappingTableConfigs,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(make) ^
      const DeepCollectionEquality().hash(model) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(defaultView) ^
      const DeepCollectionEquality().hash(preprocessorId) ^
      const DeepCollectionEquality().hash(hasGeoLocation) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(customWidget) ^
      const DeepCollectionEquality().hash(makePublic) ^
      const DeepCollectionEquality().hash(scrappingTableConfigs) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      runtimeType.hashCode;
}

extension $DeviceModelExtension on DeviceModel {
  DeviceModel copyWith({
    String? name,
    String? description,
    String? make,
    String? model,
    String? version,
    List<Parameter>? parameters,
    List<String>? tags,
    Object? metadata,
    String? defaultView,
    String? preprocessorId,
    bool? hasGeoLocation,
    bool? movable,
    CustomWidget? customWidget,
    bool? makePublic,
    List<ScrappingTableConfig>? scrappingTableConfigs,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
  }) {
    return DeviceModel(
      name: name ?? this.name,
      description: description ?? this.description,
      make: make ?? this.make,
      model: model ?? this.model,
      version: version ?? this.version,
      parameters: parameters ?? this.parameters,
      tags: tags ?? this.tags,
      metadata: metadata ?? this.metadata,
      defaultView: defaultView ?? this.defaultView,
      preprocessorId: preprocessorId ?? this.preprocessorId,
      hasGeoLocation: hasGeoLocation ?? this.hasGeoLocation,
      movable: movable ?? this.movable,
      customWidget: customWidget ?? this.customWidget,
      makePublic: makePublic ?? this.makePublic,
      scrappingTableConfigs:
          scrappingTableConfigs ?? this.scrappingTableConfigs,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
    );
  }

  DeviceModel copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? make,
    Wrapped<String>? model,
    Wrapped<String>? version,
    Wrapped<List<Parameter>>? parameters,
    Wrapped<List<String>?>? tags,
    Wrapped<Object?>? metadata,
    Wrapped<String?>? defaultView,
    Wrapped<String?>? preprocessorId,
    Wrapped<bool?>? hasGeoLocation,
    Wrapped<bool?>? movable,
    Wrapped<CustomWidget?>? customWidget,
    Wrapped<bool?>? makePublic,
    Wrapped<List<ScrappingTableConfig>?>? scrappingTableConfigs,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
  }) {
    return DeviceModel(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      make: (make != null ? make.value : this.make),
      model: (model != null ? model.value : this.model),
      version: (version != null ? version.value : this.version),
      parameters: (parameters != null ? parameters.value : this.parameters),
      tags: (tags != null ? tags.value : this.tags),
      metadata: (metadata != null ? metadata.value : this.metadata),
      defaultView: (defaultView != null ? defaultView.value : this.defaultView),
      preprocessorId: (preprocessorId != null
          ? preprocessorId.value
          : this.preprocessorId),
      hasGeoLocation: (hasGeoLocation != null
          ? hasGeoLocation.value
          : this.hasGeoLocation),
      movable: (movable != null ? movable.value : this.movable),
      customWidget: (customWidget != null
          ? customWidget.value
          : this.customWidget),
      makePublic: (makePublic != null ? makePublic.value : this.makePublic),
      scrappingTableConfigs: (scrappingTableConfigs != null
          ? scrappingTableConfigs.value
          : this.scrappingTableConfigs),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelEntity {
  const DeviceModelEntity({this.entity});

  factory DeviceModelEntity.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelEntityFromJson(json);

  static const toJsonFactory = _$DeviceModelEntityToJson;
  Map<String, dynamic> toJson() => _$DeviceModelEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DeviceModel? entity;
  static const fromJsonFactory = _$DeviceModelEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DeviceModelEntityExtension on DeviceModelEntity {
  DeviceModelEntity copyWith({DeviceModel? entity}) {
    return DeviceModelEntity(entity: entity ?? this.entity);
  }

  DeviceModelEntity copyWithWrapped({Wrapped<DeviceModel?>? entity}) {
    return DeviceModelEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelEntityRes {
  const DeviceModelEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DeviceModelEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelEntityResFromJson(json);

  static const toJsonFactory = _$DeviceModelEntityResToJson;
  Map<String, dynamic> toJson() => _$DeviceModelEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DeviceModel? entity;
  static const fromJsonFactory = _$DeviceModelEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DeviceModelEntityResExtension on DeviceModelEntityRes {
  DeviceModelEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    DeviceModel? entity,
  }) {
    return DeviceModelEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DeviceModelEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<DeviceModel?>? entity,
  }) {
    return DeviceModelEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelArray {
  const DeviceModelArray({this.values});

  factory DeviceModelArray.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelArrayFromJson(json);

  static const toJsonFactory = _$DeviceModelArrayToJson;
  Map<String, dynamic> toJson() => _$DeviceModelArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceModel>[])
  final List<DeviceModel>? values;
  static const fromJsonFactory = _$DeviceModelArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DeviceModelArrayExtension on DeviceModelArray {
  DeviceModelArray copyWith({List<DeviceModel>? values}) {
    return DeviceModelArray(values: values ?? this.values);
  }

  DeviceModelArray copyWithWrapped({Wrapped<List<DeviceModel>?>? values}) {
    return DeviceModelArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelArrayRes {
  const DeviceModelArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DeviceModelArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelArrayResFromJson(json);

  static const toJsonFactory = _$DeviceModelArrayResToJson;
  Map<String, dynamic> toJson() => _$DeviceModelArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceModel>[])
  final List<DeviceModel>? values;
  static const fromJsonFactory = _$DeviceModelArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DeviceModelArrayResExtension on DeviceModelArrayRes {
  DeviceModelArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<DeviceModel>? values,
  }) {
    return DeviceModelArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DeviceModelArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<DeviceModel>?>? values,
  }) {
    return DeviceModelArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceInfo {
  const DeviceInfo({
    required this.name,
    this.description,
    required this.modelId,
    required this.deviceId,
    this.tags,
    this.metadata,
    this.defaultView,
    this.hasGeoLocation,
    this.movable,
    this.geolocation,
    this.customWidget,
    this.reportedStamp,
    this.parameters,
    this.clientId,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
  });

  factory DeviceInfo.fromJson(Map<String, dynamic> json) =>
      _$DeviceInfoFromJson(json);

  static const toJsonFactory = _$DeviceInfoToJson;
  Map<String, dynamic> toJson() => _$DeviceInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'defaultView', includeIfNull: false, defaultValue: '')
  final String? defaultView;
  @JsonKey(name: 'hasGeoLocation', includeIfNull: false)
  final bool? hasGeoLocation;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(name: 'geolocation', includeIfNull: false)
  final GeoLocation? geolocation;
  @JsonKey(name: 'customWidget', includeIfNull: false)
  final CustomWidget? customWidget;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(
    name: 'parameters',
    includeIfNull: false,
    defaultValue: <Parameter>[],
  )
  final List<Parameter>? parameters;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  static const fromJsonFactory = _$DeviceInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.defaultView, defaultView) ||
                const DeepCollectionEquality().equals(
                  other.defaultView,
                  defaultView,
                )) &&
            (identical(other.hasGeoLocation, hasGeoLocation) ||
                const DeepCollectionEquality().equals(
                  other.hasGeoLocation,
                  hasGeoLocation,
                )) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality().equals(
                  other.movable,
                  movable,
                )) &&
            (identical(other.geolocation, geolocation) ||
                const DeepCollectionEquality().equals(
                  other.geolocation,
                  geolocation,
                )) &&
            (identical(other.customWidget, customWidget) ||
                const DeepCollectionEquality().equals(
                  other.customWidget,
                  customWidget,
                )) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality().equals(
                  other.parameters,
                  parameters,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(defaultView) ^
      const DeepCollectionEquality().hash(hasGeoLocation) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(geolocation) ^
      const DeepCollectionEquality().hash(customWidget) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      runtimeType.hashCode;
}

extension $DeviceInfoExtension on DeviceInfo {
  DeviceInfo copyWith({
    String? name,
    String? description,
    String? modelId,
    String? deviceId,
    List<String>? tags,
    Object? metadata,
    String? defaultView,
    bool? hasGeoLocation,
    bool? movable,
    GeoLocation? geolocation,
    CustomWidget? customWidget,
    int? reportedStamp,
    List<Parameter>? parameters,
    String? clientId,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
  }) {
    return DeviceInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      tags: tags ?? this.tags,
      metadata: metadata ?? this.metadata,
      defaultView: defaultView ?? this.defaultView,
      hasGeoLocation: hasGeoLocation ?? this.hasGeoLocation,
      movable: movable ?? this.movable,
      geolocation: geolocation ?? this.geolocation,
      customWidget: customWidget ?? this.customWidget,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      parameters: parameters ?? this.parameters,
      clientId: clientId ?? this.clientId,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
    );
  }

  DeviceInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? modelId,
    Wrapped<String>? deviceId,
    Wrapped<List<String>?>? tags,
    Wrapped<Object?>? metadata,
    Wrapped<String?>? defaultView,
    Wrapped<bool?>? hasGeoLocation,
    Wrapped<bool?>? movable,
    Wrapped<GeoLocation?>? geolocation,
    Wrapped<CustomWidget?>? customWidget,
    Wrapped<int?>? reportedStamp,
    Wrapped<List<Parameter>?>? parameters,
    Wrapped<String?>? clientId,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
  }) {
    return DeviceInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      tags: (tags != null ? tags.value : this.tags),
      metadata: (metadata != null ? metadata.value : this.metadata),
      defaultView: (defaultView != null ? defaultView.value : this.defaultView),
      hasGeoLocation: (hasGeoLocation != null
          ? hasGeoLocation.value
          : this.hasGeoLocation),
      movable: (movable != null ? movable.value : this.movable),
      geolocation: (geolocation != null ? geolocation.value : this.geolocation),
      customWidget: (customWidget != null
          ? customWidget.value
          : this.customWidget),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      parameters: (parameters != null ? parameters.value : this.parameters),
      clientId: (clientId != null ? clientId.value : this.clientId),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceBase {
  const DeviceBase({
    required this.apiKey,
    required this.reportedStamp,
    this.premiseId,
    this.facilityId,
    this.floorId,
    this.assetId,
    this.premise,
    this.facility,
    this.floor,
    this.asset,
    this.clientId,
    this.$client,
    this.currentLocation,
  });

  factory DeviceBase.fromJson(Map<String, dynamic> json) =>
      _$DeviceBaseFromJson(json);

  static const toJsonFactory = _$DeviceBaseToJson;
  Map<String, dynamic> toJson() => _$DeviceBaseToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int reportedStamp;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'premise', includeIfNull: false, defaultValue: '')
  final String? premise;
  @JsonKey(name: 'facility', includeIfNull: false, defaultValue: '')
  final String? facility;
  @JsonKey(name: 'floor', includeIfNull: false, defaultValue: '')
  final String? floor;
  @JsonKey(name: 'asset', includeIfNull: false, defaultValue: '')
  final String? asset;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'client', includeIfNull: false, defaultValue: '')
  final String? $client;
  @JsonKey(name: 'currentLocation', includeIfNull: false)
  final GeoLocation? currentLocation;
  static const fromJsonFactory = _$DeviceBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceBase &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality().equals(
                  other.floorId,
                  floorId,
                )) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality().equals(
                  other.assetId,
                  assetId,
                )) &&
            (identical(other.premise, premise) ||
                const DeepCollectionEquality().equals(
                  other.premise,
                  premise,
                )) &&
            (identical(other.facility, facility) ||
                const DeepCollectionEquality().equals(
                  other.facility,
                  facility,
                )) &&
            (identical(other.floor, floor) ||
                const DeepCollectionEquality().equals(other.floor, floor)) &&
            (identical(other.asset, asset) ||
                const DeepCollectionEquality().equals(other.asset, asset)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.$client, $client) ||
                const DeepCollectionEquality().equals(
                  other.$client,
                  $client,
                )) &&
            (identical(other.currentLocation, currentLocation) ||
                const DeepCollectionEquality().equals(
                  other.currentLocation,
                  currentLocation,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(premise) ^
      const DeepCollectionEquality().hash(facility) ^
      const DeepCollectionEquality().hash(floor) ^
      const DeepCollectionEquality().hash(asset) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash($client) ^
      const DeepCollectionEquality().hash(currentLocation) ^
      runtimeType.hashCode;
}

extension $DeviceBaseExtension on DeviceBase {
  DeviceBase copyWith({
    String? apiKey,
    int? reportedStamp,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? assetId,
    String? premise,
    String? facility,
    String? floor,
    String? asset,
    String? clientId,
    String? $client,
    GeoLocation? currentLocation,
  }) {
    return DeviceBase(
      apiKey: apiKey ?? this.apiKey,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      floorId: floorId ?? this.floorId,
      assetId: assetId ?? this.assetId,
      premise: premise ?? this.premise,
      facility: facility ?? this.facility,
      floor: floor ?? this.floor,
      asset: asset ?? this.asset,
      clientId: clientId ?? this.clientId,
      $client: $client ?? this.$client,
      currentLocation: currentLocation ?? this.currentLocation,
    );
  }

  DeviceBase copyWithWrapped({
    Wrapped<String>? apiKey,
    Wrapped<int>? reportedStamp,
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String?>? floorId,
    Wrapped<String?>? assetId,
    Wrapped<String?>? premise,
    Wrapped<String?>? facility,
    Wrapped<String?>? floor,
    Wrapped<String?>? asset,
    Wrapped<String?>? clientId,
    Wrapped<String?>? $client,
    Wrapped<GeoLocation?>? currentLocation,
  }) {
    return DeviceBase(
      apiKey: (apiKey != null ? apiKey.value : this.apiKey),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      floorId: (floorId != null ? floorId.value : this.floorId),
      assetId: (assetId != null ? assetId.value : this.assetId),
      premise: (premise != null ? premise.value : this.premise),
      facility: (facility != null ? facility.value : this.facility),
      floor: (floor != null ? floor.value : this.floor),
      asset: (asset != null ? asset.value : this.asset),
      clientId: (clientId != null ? clientId.value : this.clientId),
      $client: ($client != null ? $client.value : this.$client),
      currentLocation: (currentLocation != null
          ? currentLocation.value
          : this.currentLocation),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Device {
  const Device({
    this.domainKey,
    this.entityState,
    required this.apiKey,
    required this.reportedStamp,
    this.premiseId,
    this.facilityId,
    this.floorId,
    this.assetId,
    this.premise,
    this.facility,
    this.floor,
    this.asset,
    this.clientId,
    this.$client,
    this.currentLocation,
    required this.name,
    this.description,
    required this.modelId,
    required this.deviceId,
    this.tags,
    this.metadata,
    this.defaultView,
    this.hasGeoLocation,
    this.movable,
    this.geolocation,
    this.customWidget,
    this.parameters,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Device.fromJson(Map<String, dynamic> json) => _$DeviceFromJson(json);

  static const toJsonFactory = _$DeviceToJson;
  Map<String, dynamic> toJson() => _$DeviceToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(
    name: 'entityState',
    includeIfNull: false,
    toJson: deviceEntityStateNullableToJson,
    fromJson: deviceEntityStateNullableFromJson,
  )
  final enums.DeviceEntityState? entityState;
  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int reportedStamp;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'premise', includeIfNull: false, defaultValue: '')
  final String? premise;
  @JsonKey(name: 'facility', includeIfNull: false, defaultValue: '')
  final String? facility;
  @JsonKey(name: 'floor', includeIfNull: false, defaultValue: '')
  final String? floor;
  @JsonKey(name: 'asset', includeIfNull: false, defaultValue: '')
  final String? asset;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'client', includeIfNull: false, defaultValue: '')
  final String? $client;
  @JsonKey(name: 'currentLocation', includeIfNull: false)
  final GeoLocation? currentLocation;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'defaultView', includeIfNull: false, defaultValue: '')
  final String? defaultView;
  @JsonKey(name: 'hasGeoLocation', includeIfNull: false)
  final bool? hasGeoLocation;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(name: 'geolocation', includeIfNull: false)
  final GeoLocation? geolocation;
  @JsonKey(name: 'customWidget', includeIfNull: false)
  final CustomWidget? customWidget;
  @JsonKey(
    name: 'parameters',
    includeIfNull: false,
    defaultValue: <Parameter>[],
  )
  final List<Parameter>? parameters;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$DeviceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Device &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.entityState, entityState) ||
                const DeepCollectionEquality().equals(
                  other.entityState,
                  entityState,
                )) &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality().equals(
                  other.floorId,
                  floorId,
                )) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality().equals(
                  other.assetId,
                  assetId,
                )) &&
            (identical(other.premise, premise) ||
                const DeepCollectionEquality().equals(
                  other.premise,
                  premise,
                )) &&
            (identical(other.facility, facility) ||
                const DeepCollectionEquality().equals(
                  other.facility,
                  facility,
                )) &&
            (identical(other.floor, floor) ||
                const DeepCollectionEquality().equals(other.floor, floor)) &&
            (identical(other.asset, asset) ||
                const DeepCollectionEquality().equals(other.asset, asset)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.$client, $client) ||
                const DeepCollectionEquality().equals(
                  other.$client,
                  $client,
                )) &&
            (identical(other.currentLocation, currentLocation) ||
                const DeepCollectionEquality().equals(
                  other.currentLocation,
                  currentLocation,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.defaultView, defaultView) ||
                const DeepCollectionEquality().equals(
                  other.defaultView,
                  defaultView,
                )) &&
            (identical(other.hasGeoLocation, hasGeoLocation) ||
                const DeepCollectionEquality().equals(
                  other.hasGeoLocation,
                  hasGeoLocation,
                )) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality().equals(
                  other.movable,
                  movable,
                )) &&
            (identical(other.geolocation, geolocation) ||
                const DeepCollectionEquality().equals(
                  other.geolocation,
                  geolocation,
                )) &&
            (identical(other.customWidget, customWidget) ||
                const DeepCollectionEquality().equals(
                  other.customWidget,
                  customWidget,
                )) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality().equals(
                  other.parameters,
                  parameters,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(entityState) ^
      const DeepCollectionEquality().hash(apiKey) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(premise) ^
      const DeepCollectionEquality().hash(facility) ^
      const DeepCollectionEquality().hash(floor) ^
      const DeepCollectionEquality().hash(asset) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash($client) ^
      const DeepCollectionEquality().hash(currentLocation) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(defaultView) ^
      const DeepCollectionEquality().hash(hasGeoLocation) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(geolocation) ^
      const DeepCollectionEquality().hash(customWidget) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $DeviceExtension on Device {
  Device copyWith({
    String? domainKey,
    enums.DeviceEntityState? entityState,
    String? apiKey,
    int? reportedStamp,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? assetId,
    String? premise,
    String? facility,
    String? floor,
    String? asset,
    String? clientId,
    String? $client,
    GeoLocation? currentLocation,
    String? name,
    String? description,
    String? modelId,
    String? deviceId,
    List<String>? tags,
    Object? metadata,
    String? defaultView,
    bool? hasGeoLocation,
    bool? movable,
    GeoLocation? geolocation,
    CustomWidget? customWidget,
    List<Parameter>? parameters,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Device(
      domainKey: domainKey ?? this.domainKey,
      entityState: entityState ?? this.entityState,
      apiKey: apiKey ?? this.apiKey,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      floorId: floorId ?? this.floorId,
      assetId: assetId ?? this.assetId,
      premise: premise ?? this.premise,
      facility: facility ?? this.facility,
      floor: floor ?? this.floor,
      asset: asset ?? this.asset,
      clientId: clientId ?? this.clientId,
      $client: $client ?? this.$client,
      currentLocation: currentLocation ?? this.currentLocation,
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      tags: tags ?? this.tags,
      metadata: metadata ?? this.metadata,
      defaultView: defaultView ?? this.defaultView,
      hasGeoLocation: hasGeoLocation ?? this.hasGeoLocation,
      movable: movable ?? this.movable,
      geolocation: geolocation ?? this.geolocation,
      customWidget: customWidget ?? this.customWidget,
      parameters: parameters ?? this.parameters,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Device copyWithWrapped({
    Wrapped<String?>? domainKey,
    Wrapped<enums.DeviceEntityState?>? entityState,
    Wrapped<String>? apiKey,
    Wrapped<int>? reportedStamp,
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String?>? floorId,
    Wrapped<String?>? assetId,
    Wrapped<String?>? premise,
    Wrapped<String?>? facility,
    Wrapped<String?>? floor,
    Wrapped<String?>? asset,
    Wrapped<String?>? clientId,
    Wrapped<String?>? $client,
    Wrapped<GeoLocation?>? currentLocation,
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? modelId,
    Wrapped<String>? deviceId,
    Wrapped<List<String>?>? tags,
    Wrapped<Object?>? metadata,
    Wrapped<String?>? defaultView,
    Wrapped<bool?>? hasGeoLocation,
    Wrapped<bool?>? movable,
    Wrapped<GeoLocation?>? geolocation,
    Wrapped<CustomWidget?>? customWidget,
    Wrapped<List<Parameter>?>? parameters,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Device(
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      entityState: (entityState != null ? entityState.value : this.entityState),
      apiKey: (apiKey != null ? apiKey.value : this.apiKey),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      floorId: (floorId != null ? floorId.value : this.floorId),
      assetId: (assetId != null ? assetId.value : this.assetId),
      premise: (premise != null ? premise.value : this.premise),
      facility: (facility != null ? facility.value : this.facility),
      floor: (floor != null ? floor.value : this.floor),
      asset: (asset != null ? asset.value : this.asset),
      clientId: (clientId != null ? clientId.value : this.clientId),
      $client: ($client != null ? $client.value : this.$client),
      currentLocation: (currentLocation != null
          ? currentLocation.value
          : this.currentLocation),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      tags: (tags != null ? tags.value : this.tags),
      metadata: (metadata != null ? metadata.value : this.metadata),
      defaultView: (defaultView != null ? defaultView.value : this.defaultView),
      hasGeoLocation: (hasGeoLocation != null
          ? hasGeoLocation.value
          : this.hasGeoLocation),
      movable: (movable != null ? movable.value : this.movable),
      geolocation: (geolocation != null ? geolocation.value : this.geolocation),
      customWidget: (customWidget != null
          ? customWidget.value
          : this.customWidget),
      parameters: (parameters != null ? parameters.value : this.parameters),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceEntity {
  const DeviceEntity({this.entity});

  factory DeviceEntity.fromJson(Map<String, dynamic> json) =>
      _$DeviceEntityFromJson(json);

  static const toJsonFactory = _$DeviceEntityToJson;
  Map<String, dynamic> toJson() => _$DeviceEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Device? entity;
  static const fromJsonFactory = _$DeviceEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DeviceEntityExtension on DeviceEntity {
  DeviceEntity copyWith({Device? entity}) {
    return DeviceEntity(entity: entity ?? this.entity);
  }

  DeviceEntity copyWithWrapped({Wrapped<Device?>? entity}) {
    return DeviceEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceEntityRes {
  const DeviceEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DeviceEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceEntityResFromJson(json);

  static const toJsonFactory = _$DeviceEntityResToJson;
  Map<String, dynamic> toJson() => _$DeviceEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Device? entity;
  static const fromJsonFactory = _$DeviceEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DeviceEntityResExtension on DeviceEntityRes {
  DeviceEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Device? entity,
  }) {
    return DeviceEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DeviceEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Device?>? entity,
  }) {
    return DeviceEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceArray {
  const DeviceArray({this.values});

  factory DeviceArray.fromJson(Map<String, dynamic> json) =>
      _$DeviceArrayFromJson(json);

  static const toJsonFactory = _$DeviceArrayToJson;
  Map<String, dynamic> toJson() => _$DeviceArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Device>[])
  final List<Device>? values;
  static const fromJsonFactory = _$DeviceArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DeviceArrayExtension on DeviceArray {
  DeviceArray copyWith({List<Device>? values}) {
    return DeviceArray(values: values ?? this.values);
  }

  DeviceArray copyWithWrapped({Wrapped<List<Device>?>? values}) {
    return DeviceArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceArrayRes {
  const DeviceArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DeviceArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceArrayResFromJson(json);

  static const toJsonFactory = _$DeviceArrayResToJson;
  Map<String, dynamic> toJson() => _$DeviceArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Device>[])
  final List<Device>? values;
  static const fromJsonFactory = _$DeviceArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DeviceArrayResExtension on DeviceArrayRes {
  DeviceArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Device>? values,
  }) {
    return DeviceArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DeviceArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Device>?>? values,
  }) {
    return DeviceArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionInfo {
  const ConditionInfo({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.field,
    required this.condition,
    this.$value,
    this.leftValue,
    this.rightValue,
    this.values,
    this.tags,
  });

  factory ConditionInfo.fromJson(Map<String, dynamic> json) =>
      _$ConditionInfoFromJson(json);

  static const toJsonFactory = _$ConditionInfoToJson;
  Map<String, dynamic> toJson() => _$ConditionInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String field;
  @JsonKey(
    name: 'condition',
    includeIfNull: false,
    toJson: conditionInfoConditionToJson,
    fromJson: conditionInfoConditionFromJson,
  )
  final enums.ConditionInfoCondition condition;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'leftValue', includeIfNull: false, defaultValue: '')
  final String? leftValue;
  @JsonKey(name: 'rightValue', includeIfNull: false, defaultValue: '')
  final String? rightValue;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$ConditionInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality().equals(
                  other.condition,
                  condition,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.leftValue, leftValue) ||
                const DeepCollectionEquality().equals(
                  other.leftValue,
                  leftValue,
                )) &&
            (identical(other.rightValue, rightValue) ||
                const DeepCollectionEquality().equals(
                  other.rightValue,
                  rightValue,
                )) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(leftValue) ^
      const DeepCollectionEquality().hash(rightValue) ^
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $ConditionInfoExtension on ConditionInfo {
  ConditionInfo copyWith({
    String? name,
    String? description,
    String? modelId,
    String? icon,
    String? field,
    enums.ConditionInfoCondition? condition,
    String? $value,
    String? leftValue,
    String? rightValue,
    List<String>? values,
    List<String>? tags,
  }) {
    return ConditionInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      icon: icon ?? this.icon,
      field: field ?? this.field,
      condition: condition ?? this.condition,
      $value: $value ?? this.$value,
      leftValue: leftValue ?? this.leftValue,
      rightValue: rightValue ?? this.rightValue,
      values: values ?? this.values,
      tags: tags ?? this.tags,
    );
  }

  ConditionInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? modelId,
    Wrapped<String?>? icon,
    Wrapped<String>? field,
    Wrapped<enums.ConditionInfoCondition>? condition,
    Wrapped<String?>? $value,
    Wrapped<String?>? leftValue,
    Wrapped<String?>? rightValue,
    Wrapped<List<String>?>? values,
    Wrapped<List<String>?>? tags,
  }) {
    return ConditionInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      icon: (icon != null ? icon.value : this.icon),
      field: (field != null ? field.value : this.field),
      condition: (condition != null ? condition.value : this.condition),
      $value: ($value != null ? $value.value : this.$value),
      leftValue: (leftValue != null ? leftValue.value : this.leftValue),
      rightValue: (rightValue != null ? rightValue.value : this.rightValue),
      values: (values != null ? values.value : this.values),
      tags: (tags != null ? tags.value : this.tags),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Condition {
  const Condition({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.field,
    required this.condition,
    this.$value,
    this.leftValue,
    this.rightValue,
    this.values,
    this.tags,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Condition.fromJson(Map<String, dynamic> json) =>
      _$ConditionFromJson(json);

  static const toJsonFactory = _$ConditionToJson;
  Map<String, dynamic> toJson() => _$ConditionToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String field;
  @JsonKey(
    name: 'condition',
    includeIfNull: false,
    toJson: conditionConditionToJson,
    fromJson: conditionConditionFromJson,
  )
  final enums.ConditionCondition condition;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'leftValue', includeIfNull: false, defaultValue: '')
  final String? leftValue;
  @JsonKey(name: 'rightValue', includeIfNull: false, defaultValue: '')
  final String? rightValue;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$ConditionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Condition &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality().equals(
                  other.condition,
                  condition,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.leftValue, leftValue) ||
                const DeepCollectionEquality().equals(
                  other.leftValue,
                  leftValue,
                )) &&
            (identical(other.rightValue, rightValue) ||
                const DeepCollectionEquality().equals(
                  other.rightValue,
                  rightValue,
                )) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(leftValue) ^
      const DeepCollectionEquality().hash(rightValue) ^
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $ConditionExtension on Condition {
  Condition copyWith({
    String? name,
    String? description,
    String? modelId,
    String? icon,
    String? field,
    enums.ConditionCondition? condition,
    String? $value,
    String? leftValue,
    String? rightValue,
    List<String>? values,
    List<String>? tags,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Condition(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      icon: icon ?? this.icon,
      field: field ?? this.field,
      condition: condition ?? this.condition,
      $value: $value ?? this.$value,
      leftValue: leftValue ?? this.leftValue,
      rightValue: rightValue ?? this.rightValue,
      values: values ?? this.values,
      tags: tags ?? this.tags,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Condition copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? modelId,
    Wrapped<String?>? icon,
    Wrapped<String>? field,
    Wrapped<enums.ConditionCondition>? condition,
    Wrapped<String?>? $value,
    Wrapped<String?>? leftValue,
    Wrapped<String?>? rightValue,
    Wrapped<List<String>?>? values,
    Wrapped<List<String>?>? tags,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Condition(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      icon: (icon != null ? icon.value : this.icon),
      field: (field != null ? field.value : this.field),
      condition: (condition != null ? condition.value : this.condition),
      $value: ($value != null ? $value.value : this.$value),
      leftValue: (leftValue != null ? leftValue.value : this.leftValue),
      rightValue: (rightValue != null ? rightValue.value : this.rightValue),
      values: (values != null ? values.value : this.values),
      tags: (tags != null ? tags.value : this.tags),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionEntity {
  const ConditionEntity({this.entity});

  factory ConditionEntity.fromJson(Map<String, dynamic> json) =>
      _$ConditionEntityFromJson(json);

  static const toJsonFactory = _$ConditionEntityToJson;
  Map<String, dynamic> toJson() => _$ConditionEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Condition? entity;
  static const fromJsonFactory = _$ConditionEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ConditionEntityExtension on ConditionEntity {
  ConditionEntity copyWith({Condition? entity}) {
    return ConditionEntity(entity: entity ?? this.entity);
  }

  ConditionEntity copyWithWrapped({Wrapped<Condition?>? entity}) {
    return ConditionEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionEntityRes {
  const ConditionEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ConditionEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ConditionEntityResFromJson(json);

  static const toJsonFactory = _$ConditionEntityResToJson;
  Map<String, dynamic> toJson() => _$ConditionEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Condition? entity;
  static const fromJsonFactory = _$ConditionEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ConditionEntityResExtension on ConditionEntityRes {
  ConditionEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Condition? entity,
  }) {
    return ConditionEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  ConditionEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Condition?>? entity,
  }) {
    return ConditionEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionArray {
  const ConditionArray({this.values});

  factory ConditionArray.fromJson(Map<String, dynamic> json) =>
      _$ConditionArrayFromJson(json);

  static const toJsonFactory = _$ConditionArrayToJson;
  Map<String, dynamic> toJson() => _$ConditionArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Condition>[])
  final List<Condition>? values;
  static const fromJsonFactory = _$ConditionArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ConditionArrayExtension on ConditionArray {
  ConditionArray copyWith({List<Condition>? values}) {
    return ConditionArray(values: values ?? this.values);
  }

  ConditionArray copyWithWrapped({Wrapped<List<Condition>?>? values}) {
    return ConditionArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionArrayRes {
  const ConditionArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ConditionArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ConditionArrayResFromJson(json);

  static const toJsonFactory = _$ConditionArrayResToJson;
  Map<String, dynamic> toJson() => _$ConditionArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Condition>[])
  final List<Condition>? values;
  static const fromJsonFactory = _$ConditionArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ConditionArrayResExtension on ConditionArrayRes {
  ConditionArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Condition>? values,
  }) {
    return ConditionArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  ConditionArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Condition>?>? values,
  }) {
    return ConditionArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MatchGroup {
  const MatchGroup({required this.matchType, required this.conditions});

  factory MatchGroup.fromJson(Map<String, dynamic> json) =>
      _$MatchGroupFromJson(json);

  static const toJsonFactory = _$MatchGroupToJson;
  Map<String, dynamic> toJson() => _$MatchGroupToJson(this);

  @JsonKey(
    name: 'matchType',
    includeIfNull: false,
    toJson: matchGroupMatchTypeToJson,
    fromJson: matchGroupMatchTypeFromJson,
  )
  final enums.MatchGroupMatchType matchType;
  @JsonKey(name: 'conditions', includeIfNull: false, defaultValue: <String>[])
  final List<String> conditions;
  static const fromJsonFactory = _$MatchGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MatchGroup &&
            (identical(other.matchType, matchType) ||
                const DeepCollectionEquality().equals(
                  other.matchType,
                  matchType,
                )) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(matchType) ^
      const DeepCollectionEquality().hash(conditions) ^
      runtimeType.hashCode;
}

extension $MatchGroupExtension on MatchGroup {
  MatchGroup copyWith({
    enums.MatchGroupMatchType? matchType,
    List<String>? conditions,
  }) {
    return MatchGroup(
      matchType: matchType ?? this.matchType,
      conditions: conditions ?? this.conditions,
    );
  }

  MatchGroup copyWithWrapped({
    Wrapped<enums.MatchGroupMatchType>? matchType,
    Wrapped<List<String>>? conditions,
  }) {
    return MatchGroup(
      matchType: (matchType != null ? matchType.value : this.matchType),
      conditions: (conditions != null ? conditions.value : this.conditions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmMatchGroup {
  const AlarmMatchGroup({
    required this.matchType,
    required this.conditions,
    required this.alarmState,
    this.deviceState,
    this.tooltip,
  });

  factory AlarmMatchGroup.fromJson(Map<String, dynamic> json) =>
      _$AlarmMatchGroupFromJson(json);

  static const toJsonFactory = _$AlarmMatchGroupToJson;
  Map<String, dynamic> toJson() => _$AlarmMatchGroupToJson(this);

  @JsonKey(
    name: 'matchType',
    includeIfNull: false,
    toJson: alarmMatchGroupMatchTypeToJson,
    fromJson: alarmMatchGroupMatchTypeFromJson,
  )
  final enums.AlarmMatchGroupMatchType matchType;
  @JsonKey(name: 'conditions', includeIfNull: false, defaultValue: <String>[])
  final List<String> conditions;
  @JsonKey(name: 'alarmState', includeIfNull: false)
  final int alarmState;
  @JsonKey(name: 'deviceState', includeIfNull: false)
  final int? deviceState;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  static const fromJsonFactory = _$AlarmMatchGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmMatchGroup &&
            (identical(other.matchType, matchType) ||
                const DeepCollectionEquality().equals(
                  other.matchType,
                  matchType,
                )) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.alarmState, alarmState) ||
                const DeepCollectionEquality().equals(
                  other.alarmState,
                  alarmState,
                )) &&
            (identical(other.deviceState, deviceState) ||
                const DeepCollectionEquality().equals(
                  other.deviceState,
                  deviceState,
                )) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(other.tooltip, tooltip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(matchType) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(alarmState) ^
      const DeepCollectionEquality().hash(deviceState) ^
      const DeepCollectionEquality().hash(tooltip) ^
      runtimeType.hashCode;
}

extension $AlarmMatchGroupExtension on AlarmMatchGroup {
  AlarmMatchGroup copyWith({
    enums.AlarmMatchGroupMatchType? matchType,
    List<String>? conditions,
    int? alarmState,
    int? deviceState,
    String? tooltip,
  }) {
    return AlarmMatchGroup(
      matchType: matchType ?? this.matchType,
      conditions: conditions ?? this.conditions,
      alarmState: alarmState ?? this.alarmState,
      deviceState: deviceState ?? this.deviceState,
      tooltip: tooltip ?? this.tooltip,
    );
  }

  AlarmMatchGroup copyWithWrapped({
    Wrapped<enums.AlarmMatchGroupMatchType>? matchType,
    Wrapped<List<String>>? conditions,
    Wrapped<int>? alarmState,
    Wrapped<int?>? deviceState,
    Wrapped<String?>? tooltip,
  }) {
    return AlarmMatchGroup(
      matchType: (matchType != null ? matchType.value : this.matchType),
      conditions: (conditions != null ? conditions.value : this.conditions),
      alarmState: (alarmState != null ? alarmState.value : this.alarmState),
      deviceState: (deviceState != null ? deviceState.value : this.deviceState),
      tooltip: (tooltip != null ? tooltip.value : this.tooltip),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmInfo {
  const AlarmInfo({
    required this.name,
    this.description,
    this.label,
    this.modelId,
    this.deviceId,
    required this.state,
    this.stateIcons,
    required this.conditions,
    this.tags,
    this.showOnlyIfMatched,
  });

  factory AlarmInfo.fromJson(Map<String, dynamic> json) =>
      _$AlarmInfoFromJson(json);

  static const toJsonFactory = _$AlarmInfoToJson;
  Map<String, dynamic> toJson() => _$AlarmInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcons', includeIfNull: false, defaultValue: <String>[])
  final List<String>? stateIcons;
  @JsonKey(
    name: 'conditions',
    includeIfNull: false,
    defaultValue: <AlarmMatchGroup>[],
  )
  final List<AlarmMatchGroup> conditions;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'showOnlyIfMatched', includeIfNull: false)
  final bool? showOnlyIfMatched;
  static const fromJsonFactory = _$AlarmInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcons, stateIcons) ||
                const DeepCollectionEquality().equals(
                  other.stateIcons,
                  stateIcons,
                )) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.showOnlyIfMatched, showOnlyIfMatched) ||
                const DeepCollectionEquality().equals(
                  other.showOnlyIfMatched,
                  showOnlyIfMatched,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcons) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(showOnlyIfMatched) ^
      runtimeType.hashCode;
}

extension $AlarmInfoExtension on AlarmInfo {
  AlarmInfo copyWith({
    String? name,
    String? description,
    String? label,
    String? modelId,
    String? deviceId,
    int? state,
    List<String>? stateIcons,
    List<AlarmMatchGroup>? conditions,
    List<String>? tags,
    bool? showOnlyIfMatched,
  }) {
    return AlarmInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      state: state ?? this.state,
      stateIcons: stateIcons ?? this.stateIcons,
      conditions: conditions ?? this.conditions,
      tags: tags ?? this.tags,
      showOnlyIfMatched: showOnlyIfMatched ?? this.showOnlyIfMatched,
    );
  }

  AlarmInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<String?>? modelId,
    Wrapped<String?>? deviceId,
    Wrapped<int>? state,
    Wrapped<List<String>?>? stateIcons,
    Wrapped<List<AlarmMatchGroup>>? conditions,
    Wrapped<List<String>?>? tags,
    Wrapped<bool?>? showOnlyIfMatched,
  }) {
    return AlarmInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      state: (state != null ? state.value : this.state),
      stateIcons: (stateIcons != null ? stateIcons.value : this.stateIcons),
      conditions: (conditions != null ? conditions.value : this.conditions),
      tags: (tags != null ? tags.value : this.tags),
      showOnlyIfMatched: (showOnlyIfMatched != null
          ? showOnlyIfMatched.value
          : this.showOnlyIfMatched),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Alarm {
  const Alarm({
    required this.name,
    this.description,
    this.label,
    this.modelId,
    this.deviceId,
    required this.state,
    this.stateIcons,
    required this.conditions,
    this.tags,
    this.showOnlyIfMatched,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Alarm.fromJson(Map<String, dynamic> json) => _$AlarmFromJson(json);

  static const toJsonFactory = _$AlarmToJson;
  Map<String, dynamic> toJson() => _$AlarmToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcons', includeIfNull: false, defaultValue: <String>[])
  final List<String>? stateIcons;
  @JsonKey(
    name: 'conditions',
    includeIfNull: false,
    defaultValue: <AlarmMatchGroup>[],
  )
  final List<AlarmMatchGroup> conditions;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'showOnlyIfMatched', includeIfNull: false)
  final bool? showOnlyIfMatched;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$AlarmFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Alarm &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcons, stateIcons) ||
                const DeepCollectionEquality().equals(
                  other.stateIcons,
                  stateIcons,
                )) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.showOnlyIfMatched, showOnlyIfMatched) ||
                const DeepCollectionEquality().equals(
                  other.showOnlyIfMatched,
                  showOnlyIfMatched,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcons) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(showOnlyIfMatched) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $AlarmExtension on Alarm {
  Alarm copyWith({
    String? name,
    String? description,
    String? label,
    String? modelId,
    String? deviceId,
    int? state,
    List<String>? stateIcons,
    List<AlarmMatchGroup>? conditions,
    List<String>? tags,
    bool? showOnlyIfMatched,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Alarm(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      state: state ?? this.state,
      stateIcons: stateIcons ?? this.stateIcons,
      conditions: conditions ?? this.conditions,
      tags: tags ?? this.tags,
      showOnlyIfMatched: showOnlyIfMatched ?? this.showOnlyIfMatched,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Alarm copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<String?>? modelId,
    Wrapped<String?>? deviceId,
    Wrapped<int>? state,
    Wrapped<List<String>?>? stateIcons,
    Wrapped<List<AlarmMatchGroup>>? conditions,
    Wrapped<List<String>?>? tags,
    Wrapped<bool?>? showOnlyIfMatched,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Alarm(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      state: (state != null ? state.value : this.state),
      stateIcons: (stateIcons != null ? stateIcons.value : this.stateIcons),
      conditions: (conditions != null ? conditions.value : this.conditions),
      tags: (tags != null ? tags.value : this.tags),
      showOnlyIfMatched: (showOnlyIfMatched != null
          ? showOnlyIfMatched.value
          : this.showOnlyIfMatched),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmEntity {
  const AlarmEntity({this.entity});

  factory AlarmEntity.fromJson(Map<String, dynamic> json) =>
      _$AlarmEntityFromJson(json);

  static const toJsonFactory = _$AlarmEntityToJson;
  Map<String, dynamic> toJson() => _$AlarmEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Alarm? entity;
  static const fromJsonFactory = _$AlarmEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AlarmEntityExtension on AlarmEntity {
  AlarmEntity copyWith({Alarm? entity}) {
    return AlarmEntity(entity: entity ?? this.entity);
  }

  AlarmEntity copyWithWrapped({Wrapped<Alarm?>? entity}) {
    return AlarmEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmEntityRes {
  const AlarmEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AlarmEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AlarmEntityResFromJson(json);

  static const toJsonFactory = _$AlarmEntityResToJson;
  Map<String, dynamic> toJson() => _$AlarmEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Alarm? entity;
  static const fromJsonFactory = _$AlarmEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AlarmEntityResExtension on AlarmEntityRes {
  AlarmEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Alarm? entity,
  }) {
    return AlarmEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  AlarmEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Alarm?>? entity,
  }) {
    return AlarmEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmArray {
  const AlarmArray({this.values});

  factory AlarmArray.fromJson(Map<String, dynamic> json) =>
      _$AlarmArrayFromJson(json);

  static const toJsonFactory = _$AlarmArrayToJson;
  Map<String, dynamic> toJson() => _$AlarmArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Alarm>[])
  final List<Alarm>? values;
  static const fromJsonFactory = _$AlarmArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AlarmArrayExtension on AlarmArray {
  AlarmArray copyWith({List<Alarm>? values}) {
    return AlarmArray(values: values ?? this.values);
  }

  AlarmArray copyWithWrapped({Wrapped<List<Alarm>?>? values}) {
    return AlarmArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmArrayRes {
  const AlarmArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AlarmArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AlarmArrayResFromJson(json);

  static const toJsonFactory = _$AlarmArrayResToJson;
  Map<String, dynamic> toJson() => _$AlarmArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Alarm>[])
  final List<Alarm>? values;
  static const fromJsonFactory = _$AlarmArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AlarmArrayResExtension on AlarmArrayRes {
  AlarmArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Alarm>? values,
  }) {
    return AlarmArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  AlarmArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Alarm>?>? values,
  }) {
    return AlarmArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CommandParameter {
  const CommandParameter({
    required this.name,
    required this.label,
    this.description,
    required this.parameterType,
    required this.required,
    this.defaultValue,
  });

  factory CommandParameter.fromJson(Map<String, dynamic> json) =>
      _$CommandParameterFromJson(json);

  static const toJsonFactory = _$CommandParameterToJson;
  Map<String, dynamic> toJson() => _$CommandParameterToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(
    name: 'parameterType',
    includeIfNull: false,
    toJson: commandParameterParameterTypeToJson,
    fromJson: commandParameterParameterTypeFromJson,
  )
  final enums.CommandParameterParameterType parameterType;
  @JsonKey(name: 'required', includeIfNull: false, defaultValue: true)
  final bool required;
  @JsonKey(name: 'defaultValue', includeIfNull: false, defaultValue: '')
  final String? defaultValue;
  static const fromJsonFactory = _$CommandParameterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CommandParameter &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.parameterType, parameterType) ||
                const DeepCollectionEquality().equals(
                  other.parameterType,
                  parameterType,
                )) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality().equals(
                  other.required,
                  required,
                )) &&
            (identical(other.defaultValue, defaultValue) ||
                const DeepCollectionEquality().equals(
                  other.defaultValue,
                  defaultValue,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(parameterType) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(defaultValue) ^
      runtimeType.hashCode;
}

extension $CommandParameterExtension on CommandParameter {
  CommandParameter copyWith({
    String? name,
    String? label,
    String? description,
    enums.CommandParameterParameterType? parameterType,
    bool? required,
    String? defaultValue,
  }) {
    return CommandParameter(
      name: name ?? this.name,
      label: label ?? this.label,
      description: description ?? this.description,
      parameterType: parameterType ?? this.parameterType,
      required: required ?? this.required,
      defaultValue: defaultValue ?? this.defaultValue,
    );
  }

  CommandParameter copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? label,
    Wrapped<String?>? description,
    Wrapped<enums.CommandParameterParameterType>? parameterType,
    Wrapped<bool>? required,
    Wrapped<String?>? defaultValue,
  }) {
    return CommandParameter(
      name: (name != null ? name.value : this.name),
      label: (label != null ? label.value : this.label),
      description: (description != null ? description.value : this.description),
      parameterType: (parameterType != null
          ? parameterType.value
          : this.parameterType),
      required: (required != null ? required.value : this.required),
      defaultValue: (defaultValue != null
          ? defaultValue.value
          : this.defaultValue),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ControlCommand {
  const ControlCommand({
    required this.type,
    required this.commandType,
    this.jsonValue,
    this.textValue,
    this.binaryValue,
    this.parameters,
  });

  factory ControlCommand.fromJson(Map<String, dynamic> json) =>
      _$ControlCommandFromJson(json);

  static const toJsonFactory = _$ControlCommandToJson;
  Map<String, dynamic> toJson() => _$ControlCommandToJson(this);

  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: controlCommandTypeToJson,
    fromJson: controlCommandTypeFromJson,
  )
  final enums.ControlCommandType type;
  @JsonKey(
    name: 'commandType',
    includeIfNull: false,
    toJson: controlCommandCommandTypeToJson,
    fromJson: controlCommandCommandTypeFromJson,
  )
  final enums.ControlCommandCommandType commandType;
  @JsonKey(name: 'jsonValue', includeIfNull: false)
  final Object? jsonValue;
  @JsonKey(name: 'textValue', includeIfNull: false, defaultValue: '')
  final String? textValue;
  @JsonKey(name: 'binaryValue', includeIfNull: false, defaultValue: '')
  final String? binaryValue;
  @JsonKey(
    name: 'parameters',
    includeIfNull: false,
    defaultValue: <CommandParameter>[],
  )
  final List<CommandParameter>? parameters;
  static const fromJsonFactory = _$ControlCommandFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlCommand &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.commandType, commandType) ||
                const DeepCollectionEquality().equals(
                  other.commandType,
                  commandType,
                )) &&
            (identical(other.jsonValue, jsonValue) ||
                const DeepCollectionEquality().equals(
                  other.jsonValue,
                  jsonValue,
                )) &&
            (identical(other.textValue, textValue) ||
                const DeepCollectionEquality().equals(
                  other.textValue,
                  textValue,
                )) &&
            (identical(other.binaryValue, binaryValue) ||
                const DeepCollectionEquality().equals(
                  other.binaryValue,
                  binaryValue,
                )) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality().equals(
                  other.parameters,
                  parameters,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(commandType) ^
      const DeepCollectionEquality().hash(jsonValue) ^
      const DeepCollectionEquality().hash(textValue) ^
      const DeepCollectionEquality().hash(binaryValue) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ControlCommandExtension on ControlCommand {
  ControlCommand copyWith({
    enums.ControlCommandType? type,
    enums.ControlCommandCommandType? commandType,
    Object? jsonValue,
    String? textValue,
    String? binaryValue,
    List<CommandParameter>? parameters,
  }) {
    return ControlCommand(
      type: type ?? this.type,
      commandType: commandType ?? this.commandType,
      jsonValue: jsonValue ?? this.jsonValue,
      textValue: textValue ?? this.textValue,
      binaryValue: binaryValue ?? this.binaryValue,
      parameters: parameters ?? this.parameters,
    );
  }

  ControlCommand copyWithWrapped({
    Wrapped<enums.ControlCommandType>? type,
    Wrapped<enums.ControlCommandCommandType>? commandType,
    Wrapped<Object?>? jsonValue,
    Wrapped<String?>? textValue,
    Wrapped<String?>? binaryValue,
    Wrapped<List<CommandParameter>?>? parameters,
  }) {
    return ControlCommand(
      type: (type != null ? type.value : this.type),
      commandType: (commandType != null ? commandType.value : this.commandType),
      jsonValue: (jsonValue != null ? jsonValue.value : this.jsonValue),
      textValue: (textValue != null ? textValue.value : this.textValue),
      binaryValue: (binaryValue != null ? binaryValue.value : this.binaryValue),
      parameters: (parameters != null ? parameters.value : this.parameters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NameValue {
  const NameValue({required this.name, required this.$value});

  factory NameValue.fromJson(Map<String, dynamic> json) =>
      _$NameValueFromJson(json);

  static const toJsonFactory = _$NameValueToJson;
  Map<String, dynamic> toJson() => _$NameValueToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String $value;
  static const fromJsonFactory = _$NameValueFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NameValue &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $NameValueExtension on NameValue {
  NameValue copyWith({String? name, String? $value}) {
    return NameValue(name: name ?? this.name, $value: $value ?? this.$value);
  }

  NameValue copyWithWrapped({Wrapped<String>? name, Wrapped<String>? $value}) {
    return NameValue(
      name: (name != null ? name.value : this.name),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ControlTargetMqtt {
  const ControlTargetMqtt({
    required this.url,
    required this.topic,
    this.userName,
    this.password,
  });

  factory ControlTargetMqtt.fromJson(Map<String, dynamic> json) =>
      _$ControlTargetMqttFromJson(json);

  static const toJsonFactory = _$ControlTargetMqttToJson;
  Map<String, dynamic> toJson() => _$ControlTargetMqttToJson(this);

  @JsonKey(name: 'url', includeIfNull: false, defaultValue: '')
  final String url;
  @JsonKey(name: 'topic', includeIfNull: false, defaultValue: '')
  final String topic;
  @JsonKey(name: 'userName', includeIfNull: false, defaultValue: '')
  final String? userName;
  @JsonKey(name: 'password', includeIfNull: false, defaultValue: '')
  final String? password;
  static const fromJsonFactory = _$ControlTargetMqttFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlTargetMqtt &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.topic, topic) ||
                const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality().equals(
                  other.userName,
                  userName,
                )) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality().equals(
                  other.password,
                  password,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(password) ^
      runtimeType.hashCode;
}

extension $ControlTargetMqttExtension on ControlTargetMqtt {
  ControlTargetMqtt copyWith({
    String? url,
    String? topic,
    String? userName,
    String? password,
  }) {
    return ControlTargetMqtt(
      url: url ?? this.url,
      topic: topic ?? this.topic,
      userName: userName ?? this.userName,
      password: password ?? this.password,
    );
  }

  ControlTargetMqtt copyWithWrapped({
    Wrapped<String>? url,
    Wrapped<String>? topic,
    Wrapped<String?>? userName,
    Wrapped<String?>? password,
  }) {
    return ControlTargetMqtt(
      url: (url != null ? url.value : this.url),
      topic: (topic != null ? topic.value : this.topic),
      userName: (userName != null ? userName.value : this.userName),
      password: (password != null ? password.value : this.password),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ControlTargetHttp {
  const ControlTargetHttp({
    required this.url,
    required this.protocol,
    this.headers,
    this.queryParameters,
    this.basicAuthUserName,
    this.basicAuthPassword,
  });

  factory ControlTargetHttp.fromJson(Map<String, dynamic> json) =>
      _$ControlTargetHttpFromJson(json);

  static const toJsonFactory = _$ControlTargetHttpToJson;
  Map<String, dynamic> toJson() => _$ControlTargetHttpToJson(this);

  @JsonKey(name: 'url', includeIfNull: false, defaultValue: '')
  final String url;
  @JsonKey(
    name: 'protocol',
    includeIfNull: false,
    toJson: controlTargetHttpProtocolToJson,
    fromJson: controlTargetHttpProtocolFromJson,
  )
  final enums.ControlTargetHttpProtocol protocol;
  @JsonKey(name: 'headers', includeIfNull: false, defaultValue: <NameValue>[])
  final List<NameValue>? headers;
  @JsonKey(
    name: 'queryParameters',
    includeIfNull: false,
    defaultValue: <NameValue>[],
  )
  final List<NameValue>? queryParameters;
  @JsonKey(name: 'basicAuthUserName', includeIfNull: false, defaultValue: '')
  final String? basicAuthUserName;
  @JsonKey(name: 'basicAuthPassword', includeIfNull: false, defaultValue: '')
  final String? basicAuthPassword;
  static const fromJsonFactory = _$ControlTargetHttpFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlTargetHttp &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.protocol, protocol) ||
                const DeepCollectionEquality().equals(
                  other.protocol,
                  protocol,
                )) &&
            (identical(other.headers, headers) ||
                const DeepCollectionEquality().equals(
                  other.headers,
                  headers,
                )) &&
            (identical(other.queryParameters, queryParameters) ||
                const DeepCollectionEquality().equals(
                  other.queryParameters,
                  queryParameters,
                )) &&
            (identical(other.basicAuthUserName, basicAuthUserName) ||
                const DeepCollectionEquality().equals(
                  other.basicAuthUserName,
                  basicAuthUserName,
                )) &&
            (identical(other.basicAuthPassword, basicAuthPassword) ||
                const DeepCollectionEquality().equals(
                  other.basicAuthPassword,
                  basicAuthPassword,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(protocol) ^
      const DeepCollectionEquality().hash(headers) ^
      const DeepCollectionEquality().hash(queryParameters) ^
      const DeepCollectionEquality().hash(basicAuthUserName) ^
      const DeepCollectionEquality().hash(basicAuthPassword) ^
      runtimeType.hashCode;
}

extension $ControlTargetHttpExtension on ControlTargetHttp {
  ControlTargetHttp copyWith({
    String? url,
    enums.ControlTargetHttpProtocol? protocol,
    List<NameValue>? headers,
    List<NameValue>? queryParameters,
    String? basicAuthUserName,
    String? basicAuthPassword,
  }) {
    return ControlTargetHttp(
      url: url ?? this.url,
      protocol: protocol ?? this.protocol,
      headers: headers ?? this.headers,
      queryParameters: queryParameters ?? this.queryParameters,
      basicAuthUserName: basicAuthUserName ?? this.basicAuthUserName,
      basicAuthPassword: basicAuthPassword ?? this.basicAuthPassword,
    );
  }

  ControlTargetHttp copyWithWrapped({
    Wrapped<String>? url,
    Wrapped<enums.ControlTargetHttpProtocol>? protocol,
    Wrapped<List<NameValue>?>? headers,
    Wrapped<List<NameValue>?>? queryParameters,
    Wrapped<String?>? basicAuthUserName,
    Wrapped<String?>? basicAuthPassword,
  }) {
    return ControlTargetHttp(
      url: (url != null ? url.value : this.url),
      protocol: (protocol != null ? protocol.value : this.protocol),
      headers: (headers != null ? headers.value : this.headers),
      queryParameters: (queryParameters != null
          ? queryParameters.value
          : this.queryParameters),
      basicAuthUserName: (basicAuthUserName != null
          ? basicAuthUserName.value
          : this.basicAuthUserName),
      basicAuthPassword: (basicAuthPassword != null
          ? basicAuthPassword.value
          : this.basicAuthPassword),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ControlInfo {
  const ControlInfo({
    required this.name,
    this.description,
    required this.modelId,
    required this.command,
    this.enableIf,
    this.icon,
    this.disabledIcon,
    this.allowUsers,
    this.visibleIfDisabled,
    required this.target,
    this.targetMqtt,
    this.targetHttp,
    this.tags,
    this.roles,
  });

  factory ControlInfo.fromJson(Map<String, dynamic> json) =>
      _$ControlInfoFromJson(json);

  static const toJsonFactory = _$ControlInfoToJson;
  Map<String, dynamic> toJson() => _$ControlInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'command', includeIfNull: false)
  final ControlCommand command;
  @JsonKey(name: 'enableIf', includeIfNull: false)
  final MatchGroup? enableIf;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'disabledIcon', includeIfNull: false, defaultValue: '')
  final String? disabledIcon;
  @JsonKey(name: 'allowUsers', includeIfNull: false)
  final bool? allowUsers;
  @JsonKey(name: 'visibleIfDisabled', includeIfNull: false)
  final bool? visibleIfDisabled;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: controlInfoTargetToJson,
    fromJson: controlInfoTargetFromJson,
  )
  final enums.ControlInfoTarget target;
  @JsonKey(name: 'targetMqtt', includeIfNull: false)
  final ControlTargetMqtt? targetMqtt;
  @JsonKey(name: 'targetHttp', includeIfNull: false)
  final ControlTargetHttp? targetHttp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  static const fromJsonFactory = _$ControlInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.command, command) ||
                const DeepCollectionEquality().equals(
                  other.command,
                  command,
                )) &&
            (identical(other.enableIf, enableIf) ||
                const DeepCollectionEquality().equals(
                  other.enableIf,
                  enableIf,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.disabledIcon, disabledIcon) ||
                const DeepCollectionEquality().equals(
                  other.disabledIcon,
                  disabledIcon,
                )) &&
            (identical(other.allowUsers, allowUsers) ||
                const DeepCollectionEquality().equals(
                  other.allowUsers,
                  allowUsers,
                )) &&
            (identical(other.visibleIfDisabled, visibleIfDisabled) ||
                const DeepCollectionEquality().equals(
                  other.visibleIfDisabled,
                  visibleIfDisabled,
                )) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.targetMqtt, targetMqtt) ||
                const DeepCollectionEquality().equals(
                  other.targetMqtt,
                  targetMqtt,
                )) &&
            (identical(other.targetHttp, targetHttp) ||
                const DeepCollectionEquality().equals(
                  other.targetHttp,
                  targetHttp,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(command) ^
      const DeepCollectionEquality().hash(enableIf) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(disabledIcon) ^
      const DeepCollectionEquality().hash(allowUsers) ^
      const DeepCollectionEquality().hash(visibleIfDisabled) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(targetMqtt) ^
      const DeepCollectionEquality().hash(targetHttp) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      runtimeType.hashCode;
}

extension $ControlInfoExtension on ControlInfo {
  ControlInfo copyWith({
    String? name,
    String? description,
    String? modelId,
    ControlCommand? command,
    MatchGroup? enableIf,
    String? icon,
    String? disabledIcon,
    bool? allowUsers,
    bool? visibleIfDisabled,
    enums.ControlInfoTarget? target,
    ControlTargetMqtt? targetMqtt,
    ControlTargetHttp? targetHttp,
    List<String>? tags,
    List<String>? roles,
  }) {
    return ControlInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      command: command ?? this.command,
      enableIf: enableIf ?? this.enableIf,
      icon: icon ?? this.icon,
      disabledIcon: disabledIcon ?? this.disabledIcon,
      allowUsers: allowUsers ?? this.allowUsers,
      visibleIfDisabled: visibleIfDisabled ?? this.visibleIfDisabled,
      target: target ?? this.target,
      targetMqtt: targetMqtt ?? this.targetMqtt,
      targetHttp: targetHttp ?? this.targetHttp,
      tags: tags ?? this.tags,
      roles: roles ?? this.roles,
    );
  }

  ControlInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? modelId,
    Wrapped<ControlCommand>? command,
    Wrapped<MatchGroup?>? enableIf,
    Wrapped<String?>? icon,
    Wrapped<String?>? disabledIcon,
    Wrapped<bool?>? allowUsers,
    Wrapped<bool?>? visibleIfDisabled,
    Wrapped<enums.ControlInfoTarget>? target,
    Wrapped<ControlTargetMqtt?>? targetMqtt,
    Wrapped<ControlTargetHttp?>? targetHttp,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? roles,
  }) {
    return ControlInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      command: (command != null ? command.value : this.command),
      enableIf: (enableIf != null ? enableIf.value : this.enableIf),
      icon: (icon != null ? icon.value : this.icon),
      disabledIcon: (disabledIcon != null
          ? disabledIcon.value
          : this.disabledIcon),
      allowUsers: (allowUsers != null ? allowUsers.value : this.allowUsers),
      visibleIfDisabled: (visibleIfDisabled != null
          ? visibleIfDisabled.value
          : this.visibleIfDisabled),
      target: (target != null ? target.value : this.target),
      targetMqtt: (targetMqtt != null ? targetMqtt.value : this.targetMqtt),
      targetHttp: (targetHttp != null ? targetHttp.value : this.targetHttp),
      tags: (tags != null ? tags.value : this.tags),
      roles: (roles != null ? roles.value : this.roles),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ControlBase {
  const ControlBase({required this.enabled});

  factory ControlBase.fromJson(Map<String, dynamic> json) =>
      _$ControlBaseFromJson(json);

  static const toJsonFactory = _$ControlBaseToJson;
  Map<String, dynamic> toJson() => _$ControlBaseToJson(this);

  @JsonKey(name: 'enabled', includeIfNull: false)
  final bool enabled;
  static const fromJsonFactory = _$ControlBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlBase &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality().equals(other.enabled, enabled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enabled) ^ runtimeType.hashCode;
}

extension $ControlBaseExtension on ControlBase {
  ControlBase copyWith({bool? enabled}) {
    return ControlBase(enabled: enabled ?? this.enabled);
  }

  ControlBase copyWithWrapped({Wrapped<bool>? enabled}) {
    return ControlBase(
      enabled: (enabled != null ? enabled.value : this.enabled),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Control {
  const Control({
    required this.name,
    this.description,
    required this.modelId,
    required this.command,
    this.enableIf,
    this.icon,
    this.disabledIcon,
    this.allowUsers,
    this.visibleIfDisabled,
    required this.target,
    this.targetMqtt,
    this.targetHttp,
    this.tags,
    this.roles,
    required this.enabled,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Control.fromJson(Map<String, dynamic> json) =>
      _$ControlFromJson(json);

  static const toJsonFactory = _$ControlToJson;
  Map<String, dynamic> toJson() => _$ControlToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'command', includeIfNull: false)
  final ControlCommand command;
  @JsonKey(name: 'enableIf', includeIfNull: false)
  final MatchGroup? enableIf;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'disabledIcon', includeIfNull: false, defaultValue: '')
  final String? disabledIcon;
  @JsonKey(name: 'allowUsers', includeIfNull: false)
  final bool? allowUsers;
  @JsonKey(name: 'visibleIfDisabled', includeIfNull: false)
  final bool? visibleIfDisabled;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: controlTargetToJson,
    fromJson: controlTargetFromJson,
  )
  final enums.ControlTarget target;
  @JsonKey(name: 'targetMqtt', includeIfNull: false)
  final ControlTargetMqtt? targetMqtt;
  @JsonKey(name: 'targetHttp', includeIfNull: false)
  final ControlTargetHttp? targetHttp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'enabled', includeIfNull: false)
  final bool enabled;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$ControlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Control &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.command, command) ||
                const DeepCollectionEquality().equals(
                  other.command,
                  command,
                )) &&
            (identical(other.enableIf, enableIf) ||
                const DeepCollectionEquality().equals(
                  other.enableIf,
                  enableIf,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.disabledIcon, disabledIcon) ||
                const DeepCollectionEquality().equals(
                  other.disabledIcon,
                  disabledIcon,
                )) &&
            (identical(other.allowUsers, allowUsers) ||
                const DeepCollectionEquality().equals(
                  other.allowUsers,
                  allowUsers,
                )) &&
            (identical(other.visibleIfDisabled, visibleIfDisabled) ||
                const DeepCollectionEquality().equals(
                  other.visibleIfDisabled,
                  visibleIfDisabled,
                )) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.targetMqtt, targetMqtt) ||
                const DeepCollectionEquality().equals(
                  other.targetMqtt,
                  targetMqtt,
                )) &&
            (identical(other.targetHttp, targetHttp) ||
                const DeepCollectionEquality().equals(
                  other.targetHttp,
                  targetHttp,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality().equals(
                  other.enabled,
                  enabled,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(command) ^
      const DeepCollectionEquality().hash(enableIf) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(disabledIcon) ^
      const DeepCollectionEquality().hash(allowUsers) ^
      const DeepCollectionEquality().hash(visibleIfDisabled) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(targetMqtt) ^
      const DeepCollectionEquality().hash(targetHttp) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $ControlExtension on Control {
  Control copyWith({
    String? name,
    String? description,
    String? modelId,
    ControlCommand? command,
    MatchGroup? enableIf,
    String? icon,
    String? disabledIcon,
    bool? allowUsers,
    bool? visibleIfDisabled,
    enums.ControlTarget? target,
    ControlTargetMqtt? targetMqtt,
    ControlTargetHttp? targetHttp,
    List<String>? tags,
    List<String>? roles,
    bool? enabled,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Control(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      command: command ?? this.command,
      enableIf: enableIf ?? this.enableIf,
      icon: icon ?? this.icon,
      disabledIcon: disabledIcon ?? this.disabledIcon,
      allowUsers: allowUsers ?? this.allowUsers,
      visibleIfDisabled: visibleIfDisabled ?? this.visibleIfDisabled,
      target: target ?? this.target,
      targetMqtt: targetMqtt ?? this.targetMqtt,
      targetHttp: targetHttp ?? this.targetHttp,
      tags: tags ?? this.tags,
      roles: roles ?? this.roles,
      enabled: enabled ?? this.enabled,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Control copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? modelId,
    Wrapped<ControlCommand>? command,
    Wrapped<MatchGroup?>? enableIf,
    Wrapped<String?>? icon,
    Wrapped<String?>? disabledIcon,
    Wrapped<bool?>? allowUsers,
    Wrapped<bool?>? visibleIfDisabled,
    Wrapped<enums.ControlTarget>? target,
    Wrapped<ControlTargetMqtt?>? targetMqtt,
    Wrapped<ControlTargetHttp?>? targetHttp,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? roles,
    Wrapped<bool>? enabled,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Control(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      command: (command != null ? command.value : this.command),
      enableIf: (enableIf != null ? enableIf.value : this.enableIf),
      icon: (icon != null ? icon.value : this.icon),
      disabledIcon: (disabledIcon != null
          ? disabledIcon.value
          : this.disabledIcon),
      allowUsers: (allowUsers != null ? allowUsers.value : this.allowUsers),
      visibleIfDisabled: (visibleIfDisabled != null
          ? visibleIfDisabled.value
          : this.visibleIfDisabled),
      target: (target != null ? target.value : this.target),
      targetMqtt: (targetMqtt != null ? targetMqtt.value : this.targetMqtt),
      targetHttp: (targetHttp != null ? targetHttp.value : this.targetHttp),
      tags: (tags != null ? tags.value : this.tags),
      roles: (roles != null ? roles.value : this.roles),
      enabled: (enabled != null ? enabled.value : this.enabled),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ControlEntity {
  const ControlEntity({this.entity});

  factory ControlEntity.fromJson(Map<String, dynamic> json) =>
      _$ControlEntityFromJson(json);

  static const toJsonFactory = _$ControlEntityToJson;
  Map<String, dynamic> toJson() => _$ControlEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Control? entity;
  static const fromJsonFactory = _$ControlEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ControlEntityExtension on ControlEntity {
  ControlEntity copyWith({Control? entity}) {
    return ControlEntity(entity: entity ?? this.entity);
  }

  ControlEntity copyWithWrapped({Wrapped<Control?>? entity}) {
    return ControlEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ControlEntityRes {
  const ControlEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ControlEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ControlEntityResFromJson(json);

  static const toJsonFactory = _$ControlEntityResToJson;
  Map<String, dynamic> toJson() => _$ControlEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Control? entity;
  static const fromJsonFactory = _$ControlEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ControlEntityResExtension on ControlEntityRes {
  ControlEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Control? entity,
  }) {
    return ControlEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  ControlEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Control?>? entity,
  }) {
    return ControlEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ControlArray {
  const ControlArray({this.values});

  factory ControlArray.fromJson(Map<String, dynamic> json) =>
      _$ControlArrayFromJson(json);

  static const toJsonFactory = _$ControlArrayToJson;
  Map<String, dynamic> toJson() => _$ControlArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Control>[])
  final List<Control>? values;
  static const fromJsonFactory = _$ControlArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ControlArrayExtension on ControlArray {
  ControlArray copyWith({List<Control>? values}) {
    return ControlArray(values: values ?? this.values);
  }

  ControlArray copyWithWrapped({Wrapped<List<Control>?>? values}) {
    return ControlArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ControlArrayRes {
  const ControlArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ControlArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ControlArrayResFromJson(json);

  static const toJsonFactory = _$ControlArrayResToJson;
  Map<String, dynamic> toJson() => _$ControlArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Control>[])
  final List<Control>? values;
  static const fromJsonFactory = _$ControlArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ControlArrayResExtension on ControlArrayRes {
  ControlArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Control>? values,
  }) {
    return ControlArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  ControlArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Control>?>? values,
  }) {
    return ControlArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInfo {
  const EventInfo({
    required this.name,
    this.description,
    this.modelId,
    this.deviceId,
    this.assetId,
    this.premiseId,
    this.facilityId,
    this.floorId,
    this.icon,
    required this.conditions,
    this.notificationTemplate,
    this.emailTemplate,
    this.smsTemplate,
    this.fcmTemplate,
    this.voiceTemplate,
    this.tags,
    this.roles,
    this.sourceType,
    this.isPulseGroup,
    this.pulseGroupId,
    this.pulseTemplateId,
    this.clientId,
  });

  factory EventInfo.fromJson(Map<String, dynamic> json) =>
      _$EventInfoFromJson(json);

  static const toJsonFactory = _$EventInfoToJson;
  Map<String, dynamic> toJson() => _$EventInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
    name: 'conditions',
    includeIfNull: false,
    defaultValue: <MatchGroup>[],
  )
  final List<MatchGroup> conditions;
  @JsonKey(name: 'notificationTemplate', includeIfNull: false)
  final NotificationTemplate? notificationTemplate;
  @JsonKey(name: 'emailTemplate', includeIfNull: false)
  final EmailTemplate? emailTemplate;
  @JsonKey(name: 'smsTemplate', includeIfNull: false)
  final SMSTemplate? smsTemplate;
  @JsonKey(name: 'fcmTemplate', includeIfNull: false)
  final FCMTemplate? fcmTemplate;
  @JsonKey(name: 'voiceTemplate', includeIfNull: false)
  final VoiceTemplate? voiceTemplate;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(
    name: 'sourceType',
    includeIfNull: false,
    toJson: eventInfoSourceTypeNullableToJson,
    fromJson: eventInfoSourceTypeNullableFromJson,
  )
  final enums.EventInfoSourceType? sourceType;
  @JsonKey(name: 'isPulseGroup', includeIfNull: false)
  final bool? isPulseGroup;
  @JsonKey(name: 'pulseGroupId', includeIfNull: false, defaultValue: '')
  final String? pulseGroupId;
  @JsonKey(name: 'pulseTemplateId', includeIfNull: false, defaultValue: '')
  final String? pulseTemplateId;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$EventInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality().equals(
                  other.assetId,
                  assetId,
                )) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality().equals(
                  other.floorId,
                  floorId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.notificationTemplate, notificationTemplate) ||
                const DeepCollectionEquality().equals(
                  other.notificationTemplate,
                  notificationTemplate,
                )) &&
            (identical(other.emailTemplate, emailTemplate) ||
                const DeepCollectionEquality().equals(
                  other.emailTemplate,
                  emailTemplate,
                )) &&
            (identical(other.smsTemplate, smsTemplate) ||
                const DeepCollectionEquality().equals(
                  other.smsTemplate,
                  smsTemplate,
                )) &&
            (identical(other.fcmTemplate, fcmTemplate) ||
                const DeepCollectionEquality().equals(
                  other.fcmTemplate,
                  fcmTemplate,
                )) &&
            (identical(other.voiceTemplate, voiceTemplate) ||
                const DeepCollectionEquality().equals(
                  other.voiceTemplate,
                  voiceTemplate,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.sourceType, sourceType) ||
                const DeepCollectionEquality().equals(
                  other.sourceType,
                  sourceType,
                )) &&
            (identical(other.isPulseGroup, isPulseGroup) ||
                const DeepCollectionEquality().equals(
                  other.isPulseGroup,
                  isPulseGroup,
                )) &&
            (identical(other.pulseGroupId, pulseGroupId) ||
                const DeepCollectionEquality().equals(
                  other.pulseGroupId,
                  pulseGroupId,
                )) &&
            (identical(other.pulseTemplateId, pulseTemplateId) ||
                const DeepCollectionEquality().equals(
                  other.pulseTemplateId,
                  pulseTemplateId,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(notificationTemplate) ^
      const DeepCollectionEquality().hash(emailTemplate) ^
      const DeepCollectionEquality().hash(smsTemplate) ^
      const DeepCollectionEquality().hash(fcmTemplate) ^
      const DeepCollectionEquality().hash(voiceTemplate) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(sourceType) ^
      const DeepCollectionEquality().hash(isPulseGroup) ^
      const DeepCollectionEquality().hash(pulseGroupId) ^
      const DeepCollectionEquality().hash(pulseTemplateId) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $EventInfoExtension on EventInfo {
  EventInfo copyWith({
    String? name,
    String? description,
    String? modelId,
    String? deviceId,
    String? assetId,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? icon,
    List<MatchGroup>? conditions,
    NotificationTemplate? notificationTemplate,
    EmailTemplate? emailTemplate,
    SMSTemplate? smsTemplate,
    FCMTemplate? fcmTemplate,
    VoiceTemplate? voiceTemplate,
    List<String>? tags,
    List<String>? roles,
    enums.EventInfoSourceType? sourceType,
    bool? isPulseGroup,
    String? pulseGroupId,
    String? pulseTemplateId,
    String? clientId,
  }) {
    return EventInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      assetId: assetId ?? this.assetId,
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      floorId: floorId ?? this.floorId,
      icon: icon ?? this.icon,
      conditions: conditions ?? this.conditions,
      notificationTemplate: notificationTemplate ?? this.notificationTemplate,
      emailTemplate: emailTemplate ?? this.emailTemplate,
      smsTemplate: smsTemplate ?? this.smsTemplate,
      fcmTemplate: fcmTemplate ?? this.fcmTemplate,
      voiceTemplate: voiceTemplate ?? this.voiceTemplate,
      tags: tags ?? this.tags,
      roles: roles ?? this.roles,
      sourceType: sourceType ?? this.sourceType,
      isPulseGroup: isPulseGroup ?? this.isPulseGroup,
      pulseGroupId: pulseGroupId ?? this.pulseGroupId,
      pulseTemplateId: pulseTemplateId ?? this.pulseTemplateId,
      clientId: clientId ?? this.clientId,
    );
  }

  EventInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? modelId,
    Wrapped<String?>? deviceId,
    Wrapped<String?>? assetId,
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String?>? floorId,
    Wrapped<String?>? icon,
    Wrapped<List<MatchGroup>>? conditions,
    Wrapped<NotificationTemplate?>? notificationTemplate,
    Wrapped<EmailTemplate?>? emailTemplate,
    Wrapped<SMSTemplate?>? smsTemplate,
    Wrapped<FCMTemplate?>? fcmTemplate,
    Wrapped<VoiceTemplate?>? voiceTemplate,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? roles,
    Wrapped<enums.EventInfoSourceType?>? sourceType,
    Wrapped<bool?>? isPulseGroup,
    Wrapped<String?>? pulseGroupId,
    Wrapped<String?>? pulseTemplateId,
    Wrapped<String?>? clientId,
  }) {
    return EventInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      assetId: (assetId != null ? assetId.value : this.assetId),
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      floorId: (floorId != null ? floorId.value : this.floorId),
      icon: (icon != null ? icon.value : this.icon),
      conditions: (conditions != null ? conditions.value : this.conditions),
      notificationTemplate: (notificationTemplate != null
          ? notificationTemplate.value
          : this.notificationTemplate),
      emailTemplate: (emailTemplate != null
          ? emailTemplate.value
          : this.emailTemplate),
      smsTemplate: (smsTemplate != null ? smsTemplate.value : this.smsTemplate),
      fcmTemplate: (fcmTemplate != null ? fcmTemplate.value : this.fcmTemplate),
      voiceTemplate: (voiceTemplate != null
          ? voiceTemplate.value
          : this.voiceTemplate),
      tags: (tags != null ? tags.value : this.tags),
      roles: (roles != null ? roles.value : this.roles),
      sourceType: (sourceType != null ? sourceType.value : this.sourceType),
      isPulseGroup: (isPulseGroup != null
          ? isPulseGroup.value
          : this.isPulseGroup),
      pulseGroupId: (pulseGroupId != null
          ? pulseGroupId.value
          : this.pulseGroupId),
      pulseTemplateId: (pulseTemplateId != null
          ? pulseTemplateId.value
          : this.pulseTemplateId),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Event {
  const Event({
    required this.name,
    this.description,
    this.modelId,
    this.deviceId,
    this.assetId,
    this.premiseId,
    this.facilityId,
    this.floorId,
    this.icon,
    required this.conditions,
    this.notificationTemplate,
    this.emailTemplate,
    this.smsTemplate,
    this.fcmTemplate,
    this.voiceTemplate,
    this.tags,
    this.roles,
    this.sourceType,
    this.isPulseGroup,
    this.pulseGroupId,
    this.pulseTemplateId,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Event.fromJson(Map<String, dynamic> json) => _$EventFromJson(json);

  static const toJsonFactory = _$EventToJson;
  Map<String, dynamic> toJson() => _$EventToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
    name: 'conditions',
    includeIfNull: false,
    defaultValue: <MatchGroup>[],
  )
  final List<MatchGroup> conditions;
  @JsonKey(name: 'notificationTemplate', includeIfNull: false)
  final NotificationTemplate? notificationTemplate;
  @JsonKey(name: 'emailTemplate', includeIfNull: false)
  final EmailTemplate? emailTemplate;
  @JsonKey(name: 'smsTemplate', includeIfNull: false)
  final SMSTemplate? smsTemplate;
  @JsonKey(name: 'fcmTemplate', includeIfNull: false)
  final FCMTemplate? fcmTemplate;
  @JsonKey(name: 'voiceTemplate', includeIfNull: false)
  final VoiceTemplate? voiceTemplate;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(
    name: 'sourceType',
    includeIfNull: false,
    toJson: eventSourceTypeNullableToJson,
    fromJson: eventSourceTypeNullableFromJson,
  )
  final enums.EventSourceType? sourceType;
  @JsonKey(name: 'isPulseGroup', includeIfNull: false)
  final bool? isPulseGroup;
  @JsonKey(name: 'pulseGroupId', includeIfNull: false, defaultValue: '')
  final String? pulseGroupId;
  @JsonKey(name: 'pulseTemplateId', includeIfNull: false, defaultValue: '')
  final String? pulseTemplateId;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$EventFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Event &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality().equals(
                  other.assetId,
                  assetId,
                )) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality().equals(
                  other.floorId,
                  floorId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.notificationTemplate, notificationTemplate) ||
                const DeepCollectionEquality().equals(
                  other.notificationTemplate,
                  notificationTemplate,
                )) &&
            (identical(other.emailTemplate, emailTemplate) ||
                const DeepCollectionEquality().equals(
                  other.emailTemplate,
                  emailTemplate,
                )) &&
            (identical(other.smsTemplate, smsTemplate) ||
                const DeepCollectionEquality().equals(
                  other.smsTemplate,
                  smsTemplate,
                )) &&
            (identical(other.fcmTemplate, fcmTemplate) ||
                const DeepCollectionEquality().equals(
                  other.fcmTemplate,
                  fcmTemplate,
                )) &&
            (identical(other.voiceTemplate, voiceTemplate) ||
                const DeepCollectionEquality().equals(
                  other.voiceTemplate,
                  voiceTemplate,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.sourceType, sourceType) ||
                const DeepCollectionEquality().equals(
                  other.sourceType,
                  sourceType,
                )) &&
            (identical(other.isPulseGroup, isPulseGroup) ||
                const DeepCollectionEquality().equals(
                  other.isPulseGroup,
                  isPulseGroup,
                )) &&
            (identical(other.pulseGroupId, pulseGroupId) ||
                const DeepCollectionEquality().equals(
                  other.pulseGroupId,
                  pulseGroupId,
                )) &&
            (identical(other.pulseTemplateId, pulseTemplateId) ||
                const DeepCollectionEquality().equals(
                  other.pulseTemplateId,
                  pulseTemplateId,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(notificationTemplate) ^
      const DeepCollectionEquality().hash(emailTemplate) ^
      const DeepCollectionEquality().hash(smsTemplate) ^
      const DeepCollectionEquality().hash(fcmTemplate) ^
      const DeepCollectionEquality().hash(voiceTemplate) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(sourceType) ^
      const DeepCollectionEquality().hash(isPulseGroup) ^
      const DeepCollectionEquality().hash(pulseGroupId) ^
      const DeepCollectionEquality().hash(pulseTemplateId) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $EventExtension on Event {
  Event copyWith({
    String? name,
    String? description,
    String? modelId,
    String? deviceId,
    String? assetId,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? icon,
    List<MatchGroup>? conditions,
    NotificationTemplate? notificationTemplate,
    EmailTemplate? emailTemplate,
    SMSTemplate? smsTemplate,
    FCMTemplate? fcmTemplate,
    VoiceTemplate? voiceTemplate,
    List<String>? tags,
    List<String>? roles,
    enums.EventSourceType? sourceType,
    bool? isPulseGroup,
    String? pulseGroupId,
    String? pulseTemplateId,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Event(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      assetId: assetId ?? this.assetId,
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      floorId: floorId ?? this.floorId,
      icon: icon ?? this.icon,
      conditions: conditions ?? this.conditions,
      notificationTemplate: notificationTemplate ?? this.notificationTemplate,
      emailTemplate: emailTemplate ?? this.emailTemplate,
      smsTemplate: smsTemplate ?? this.smsTemplate,
      fcmTemplate: fcmTemplate ?? this.fcmTemplate,
      voiceTemplate: voiceTemplate ?? this.voiceTemplate,
      tags: tags ?? this.tags,
      roles: roles ?? this.roles,
      sourceType: sourceType ?? this.sourceType,
      isPulseGroup: isPulseGroup ?? this.isPulseGroup,
      pulseGroupId: pulseGroupId ?? this.pulseGroupId,
      pulseTemplateId: pulseTemplateId ?? this.pulseTemplateId,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Event copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? modelId,
    Wrapped<String?>? deviceId,
    Wrapped<String?>? assetId,
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String?>? floorId,
    Wrapped<String?>? icon,
    Wrapped<List<MatchGroup>>? conditions,
    Wrapped<NotificationTemplate?>? notificationTemplate,
    Wrapped<EmailTemplate?>? emailTemplate,
    Wrapped<SMSTemplate?>? smsTemplate,
    Wrapped<FCMTemplate?>? fcmTemplate,
    Wrapped<VoiceTemplate?>? voiceTemplate,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? roles,
    Wrapped<enums.EventSourceType?>? sourceType,
    Wrapped<bool?>? isPulseGroup,
    Wrapped<String?>? pulseGroupId,
    Wrapped<String?>? pulseTemplateId,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Event(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      assetId: (assetId != null ? assetId.value : this.assetId),
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      floorId: (floorId != null ? floorId.value : this.floorId),
      icon: (icon != null ? icon.value : this.icon),
      conditions: (conditions != null ? conditions.value : this.conditions),
      notificationTemplate: (notificationTemplate != null
          ? notificationTemplate.value
          : this.notificationTemplate),
      emailTemplate: (emailTemplate != null
          ? emailTemplate.value
          : this.emailTemplate),
      smsTemplate: (smsTemplate != null ? smsTemplate.value : this.smsTemplate),
      fcmTemplate: (fcmTemplate != null ? fcmTemplate.value : this.fcmTemplate),
      voiceTemplate: (voiceTemplate != null
          ? voiceTemplate.value
          : this.voiceTemplate),
      tags: (tags != null ? tags.value : this.tags),
      roles: (roles != null ? roles.value : this.roles),
      sourceType: (sourceType != null ? sourceType.value : this.sourceType),
      isPulseGroup: (isPulseGroup != null
          ? isPulseGroup.value
          : this.isPulseGroup),
      pulseGroupId: (pulseGroupId != null
          ? pulseGroupId.value
          : this.pulseGroupId),
      pulseTemplateId: (pulseTemplateId != null
          ? pulseTemplateId.value
          : this.pulseTemplateId),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEntity {
  const EventEntity({this.entity});

  factory EventEntity.fromJson(Map<String, dynamic> json) =>
      _$EventEntityFromJson(json);

  static const toJsonFactory = _$EventEntityToJson;
  Map<String, dynamic> toJson() => _$EventEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Event? entity;
  static const fromJsonFactory = _$EventEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $EventEntityExtension on EventEntity {
  EventEntity copyWith({Event? entity}) {
    return EventEntity(entity: entity ?? this.entity);
  }

  EventEntity copyWithWrapped({Wrapped<Event?>? entity}) {
    return EventEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class EventEntityRes {
  const EventEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory EventEntityRes.fromJson(Map<String, dynamic> json) =>
      _$EventEntityResFromJson(json);

  static const toJsonFactory = _$EventEntityResToJson;
  Map<String, dynamic> toJson() => _$EventEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Event? entity;
  static const fromJsonFactory = _$EventEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $EventEntityResExtension on EventEntityRes {
  EventEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Event? entity,
  }) {
    return EventEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  EventEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Event?>? entity,
  }) {
    return EventEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventArray {
  const EventArray({this.values});

  factory EventArray.fromJson(Map<String, dynamic> json) =>
      _$EventArrayFromJson(json);

  static const toJsonFactory = _$EventArrayToJson;
  Map<String, dynamic> toJson() => _$EventArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Event>[])
  final List<Event>? values;
  static const fromJsonFactory = _$EventArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $EventArrayExtension on EventArray {
  EventArray copyWith({List<Event>? values}) {
    return EventArray(values: values ?? this.values);
  }

  EventArray copyWithWrapped({Wrapped<List<Event>?>? values}) {
    return EventArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class EventArrayRes {
  const EventArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory EventArrayRes.fromJson(Map<String, dynamic> json) =>
      _$EventArrayResFromJson(json);

  static const toJsonFactory = _$EventArrayResToJson;
  Map<String, dynamic> toJson() => _$EventArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Event>[])
  final List<Event>? values;
  static const fromJsonFactory = _$EventArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $EventArrayResExtension on EventArrayRes {
  EventArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Event>? values,
  }) {
    return EventArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  EventArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Event>?>? values,
  }) {
    return EventArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class HttpParam {
  const HttpParam({required this.name, this.$value});

  factory HttpParam.fromJson(Map<String, dynamic> json) =>
      _$HttpParamFromJson(json);

  static const toJsonFactory = _$HttpParamToJson;
  Map<String, dynamic> toJson() => _$HttpParamToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  static const fromJsonFactory = _$HttpParamFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HttpParam &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $HttpParamExtension on HttpParam {
  HttpParam copyWith({String? name, String? $value}) {
    return HttpParam(name: name ?? this.name, $value: $value ?? this.$value);
  }

  HttpParam copyWithWrapped({Wrapped<String>? name, Wrapped<String?>? $value}) {
    return HttpParam(
      name: (name != null ? name.value : this.name),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class HttpConfig {
  const HttpConfig({
    required this.url,
    required this.protocol,
    this.headers,
    this.queryParameters,
  });

  factory HttpConfig.fromJson(Map<String, dynamic> json) =>
      _$HttpConfigFromJson(json);

  static const toJsonFactory = _$HttpConfigToJson;
  Map<String, dynamic> toJson() => _$HttpConfigToJson(this);

  @JsonKey(name: 'url', includeIfNull: false, defaultValue: '')
  final String url;
  @JsonKey(
    name: 'protocol',
    includeIfNull: false,
    toJson: httpConfigProtocolToJson,
    fromJson: httpConfigProtocolFromJson,
  )
  final enums.HttpConfigProtocol protocol;
  @JsonKey(name: 'headers', includeIfNull: false, defaultValue: <HttpParam>[])
  final List<HttpParam>? headers;
  @JsonKey(
    name: 'queryParameters',
    includeIfNull: false,
    defaultValue: <HttpParam>[],
  )
  final List<HttpParam>? queryParameters;
  static const fromJsonFactory = _$HttpConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HttpConfig &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.protocol, protocol) ||
                const DeepCollectionEquality().equals(
                  other.protocol,
                  protocol,
                )) &&
            (identical(other.headers, headers) ||
                const DeepCollectionEquality().equals(
                  other.headers,
                  headers,
                )) &&
            (identical(other.queryParameters, queryParameters) ||
                const DeepCollectionEquality().equals(
                  other.queryParameters,
                  queryParameters,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(protocol) ^
      const DeepCollectionEquality().hash(headers) ^
      const DeepCollectionEquality().hash(queryParameters) ^
      runtimeType.hashCode;
}

extension $HttpConfigExtension on HttpConfig {
  HttpConfig copyWith({
    String? url,
    enums.HttpConfigProtocol? protocol,
    List<HttpParam>? headers,
    List<HttpParam>? queryParameters,
  }) {
    return HttpConfig(
      url: url ?? this.url,
      protocol: protocol ?? this.protocol,
      headers: headers ?? this.headers,
      queryParameters: queryParameters ?? this.queryParameters,
    );
  }

  HttpConfig copyWithWrapped({
    Wrapped<String>? url,
    Wrapped<enums.HttpConfigProtocol>? protocol,
    Wrapped<List<HttpParam>?>? headers,
    Wrapped<List<HttpParam>?>? queryParameters,
  }) {
    return HttpConfig(
      url: (url != null ? url.value : this.url),
      protocol: (protocol != null ? protocol.value : this.protocol),
      headers: (headers != null ? headers.value : this.headers),
      queryParameters: (queryParameters != null
          ? queryParameters.value
          : this.queryParameters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UdpConfig {
  const UdpConfig({required this.host, required this.port});

  factory UdpConfig.fromJson(Map<String, dynamic> json) =>
      _$UdpConfigFromJson(json);

  static const toJsonFactory = _$UdpConfigToJson;
  Map<String, dynamic> toJson() => _$UdpConfigToJson(this);

  @JsonKey(name: 'host', includeIfNull: false, defaultValue: '')
  final String host;
  @JsonKey(name: 'port', includeIfNull: false)
  final int port;
  static const fromJsonFactory = _$UdpConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UdpConfig &&
            (identical(other.host, host) ||
                const DeepCollectionEquality().equals(other.host, host)) &&
            (identical(other.port, port) ||
                const DeepCollectionEquality().equals(other.port, port)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(host) ^
      const DeepCollectionEquality().hash(port) ^
      runtimeType.hashCode;
}

extension $UdpConfigExtension on UdpConfig {
  UdpConfig copyWith({String? host, int? port}) {
    return UdpConfig(host: host ?? this.host, port: port ?? this.port);
  }

  UdpConfig copyWithWrapped({Wrapped<String>? host, Wrapped<int>? port}) {
    return UdpConfig(
      host: (host != null ? host.value : this.host),
      port: (port != null ? port.value : this.port),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MqttConfig {
  const MqttConfig({
    required this.host,
    required this.port,
    required this.topic,
    this.qos,
  });

  factory MqttConfig.fromJson(Map<String, dynamic> json) =>
      _$MqttConfigFromJson(json);

  static const toJsonFactory = _$MqttConfigToJson;
  Map<String, dynamic> toJson() => _$MqttConfigToJson(this);

  @JsonKey(name: 'host', includeIfNull: false, defaultValue: '')
  final String host;
  @JsonKey(name: 'port', includeIfNull: false)
  final int port;
  @JsonKey(name: 'topic', includeIfNull: false, defaultValue: '')
  final String topic;
  @JsonKey(name: 'qos', includeIfNull: false)
  final int? qos;
  static const fromJsonFactory = _$MqttConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MqttConfig &&
            (identical(other.host, host) ||
                const DeepCollectionEquality().equals(other.host, host)) &&
            (identical(other.port, port) ||
                const DeepCollectionEquality().equals(other.port, port)) &&
            (identical(other.topic, topic) ||
                const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.qos, qos) ||
                const DeepCollectionEquality().equals(other.qos, qos)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(host) ^
      const DeepCollectionEquality().hash(port) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(qos) ^
      runtimeType.hashCode;
}

extension $MqttConfigExtension on MqttConfig {
  MqttConfig copyWith({String? host, int? port, String? topic, int? qos}) {
    return MqttConfig(
      host: host ?? this.host,
      port: port ?? this.port,
      topic: topic ?? this.topic,
      qos: qos ?? this.qos,
    );
  }

  MqttConfig copyWithWrapped({
    Wrapped<String>? host,
    Wrapped<int>? port,
    Wrapped<String>? topic,
    Wrapped<int?>? qos,
  }) {
    return MqttConfig(
      host: (host != null ? host.value : this.host),
      port: (port != null ? port.value : this.port),
      topic: (topic != null ? topic.value : this.topic),
      qos: (qos != null ? qos.value : this.qos),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerControl {
  const TriggerControl({
    required this.controlState,
    required this.triggerTarget,
    this.triggerType,
    this.deliveryTarget,
    this.controlId,
    this.otherDeviceId,
    this.otherControlId,
    this.httpConfig,
    this.mqttConfig,
    this.udpConfig,
  });

  factory TriggerControl.fromJson(Map<String, dynamic> json) =>
      _$TriggerControlFromJson(json);

  static const toJsonFactory = _$TriggerControlToJson;
  Map<String, dynamic> toJson() => _$TriggerControlToJson(this);

  @JsonKey(name: 'controlState', includeIfNull: false)
  final int controlState;
  @JsonKey(
    name: 'triggerTarget',
    includeIfNull: false,
    toJson: triggerControlTriggerTargetToJson,
    fromJson: triggerControlTriggerTargetTriggerTargetFromJson,
  )
  final enums.TriggerControlTriggerTarget triggerTarget;
  static enums.TriggerControlTriggerTarget
  triggerControlTriggerTargetTriggerTargetFromJson(Object? value) =>
      triggerControlTriggerTargetFromJson(
        value,
        enums.TriggerControlTriggerTarget.thisdevice,
      );

  @JsonKey(
    name: 'triggerType',
    includeIfNull: false,
    toJson: triggerControlTriggerTypeNullableToJson,
    fromJson: triggerControlTriggerTypeTriggerTypeNullableFromJson,
  )
  final enums.TriggerControlTriggerType? triggerType;
  static enums.TriggerControlTriggerType?
  triggerControlTriggerTypeTriggerTypeNullableFromJson(Object? value) =>
      triggerControlTriggerTypeNullableFromJson(
        value,
        enums.TriggerControlTriggerType.fire,
      );

  @JsonKey(
    name: 'deliveryTarget',
    includeIfNull: false,
    toJson: triggerControlDeliveryTargetNullableToJson,
    fromJson: triggerControlDeliveryTargetDeliveryTargetNullableFromJson,
  )
  final enums.TriggerControlDeliveryTarget? deliveryTarget;
  static enums.TriggerControlDeliveryTarget?
  triggerControlDeliveryTargetDeliveryTargetNullableFromJson(Object? value) =>
      triggerControlDeliveryTargetNullableFromJson(
        value,
        enums.TriggerControlDeliveryTarget.builtin,
      );

  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String? controlId;
  @JsonKey(name: 'otherDeviceId', includeIfNull: false, defaultValue: '')
  final String? otherDeviceId;
  @JsonKey(name: 'otherControlId', includeIfNull: false, defaultValue: '')
  final String? otherControlId;
  @JsonKey(name: 'httpConfig', includeIfNull: false)
  final HttpConfig? httpConfig;
  @JsonKey(name: 'mqttConfig', includeIfNull: false)
  final MqttConfig? mqttConfig;
  @JsonKey(name: 'udpConfig', includeIfNull: false)
  final UdpConfig? udpConfig;
  static const fromJsonFactory = _$TriggerControlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerControl &&
            (identical(other.controlState, controlState) ||
                const DeepCollectionEquality().equals(
                  other.controlState,
                  controlState,
                )) &&
            (identical(other.triggerTarget, triggerTarget) ||
                const DeepCollectionEquality().equals(
                  other.triggerTarget,
                  triggerTarget,
                )) &&
            (identical(other.triggerType, triggerType) ||
                const DeepCollectionEquality().equals(
                  other.triggerType,
                  triggerType,
                )) &&
            (identical(other.deliveryTarget, deliveryTarget) ||
                const DeepCollectionEquality().equals(
                  other.deliveryTarget,
                  deliveryTarget,
                )) &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality().equals(
                  other.controlId,
                  controlId,
                )) &&
            (identical(other.otherDeviceId, otherDeviceId) ||
                const DeepCollectionEquality().equals(
                  other.otherDeviceId,
                  otherDeviceId,
                )) &&
            (identical(other.otherControlId, otherControlId) ||
                const DeepCollectionEquality().equals(
                  other.otherControlId,
                  otherControlId,
                )) &&
            (identical(other.httpConfig, httpConfig) ||
                const DeepCollectionEquality().equals(
                  other.httpConfig,
                  httpConfig,
                )) &&
            (identical(other.mqttConfig, mqttConfig) ||
                const DeepCollectionEquality().equals(
                  other.mqttConfig,
                  mqttConfig,
                )) &&
            (identical(other.udpConfig, udpConfig) ||
                const DeepCollectionEquality().equals(
                  other.udpConfig,
                  udpConfig,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(controlState) ^
      const DeepCollectionEquality().hash(triggerTarget) ^
      const DeepCollectionEquality().hash(triggerType) ^
      const DeepCollectionEquality().hash(deliveryTarget) ^
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(otherDeviceId) ^
      const DeepCollectionEquality().hash(otherControlId) ^
      const DeepCollectionEquality().hash(httpConfig) ^
      const DeepCollectionEquality().hash(mqttConfig) ^
      const DeepCollectionEquality().hash(udpConfig) ^
      runtimeType.hashCode;
}

extension $TriggerControlExtension on TriggerControl {
  TriggerControl copyWith({
    int? controlState,
    enums.TriggerControlTriggerTarget? triggerTarget,
    enums.TriggerControlTriggerType? triggerType,
    enums.TriggerControlDeliveryTarget? deliveryTarget,
    String? controlId,
    String? otherDeviceId,
    String? otherControlId,
    HttpConfig? httpConfig,
    MqttConfig? mqttConfig,
    UdpConfig? udpConfig,
  }) {
    return TriggerControl(
      controlState: controlState ?? this.controlState,
      triggerTarget: triggerTarget ?? this.triggerTarget,
      triggerType: triggerType ?? this.triggerType,
      deliveryTarget: deliveryTarget ?? this.deliveryTarget,
      controlId: controlId ?? this.controlId,
      otherDeviceId: otherDeviceId ?? this.otherDeviceId,
      otherControlId: otherControlId ?? this.otherControlId,
      httpConfig: httpConfig ?? this.httpConfig,
      mqttConfig: mqttConfig ?? this.mqttConfig,
      udpConfig: udpConfig ?? this.udpConfig,
    );
  }

  TriggerControl copyWithWrapped({
    Wrapped<int>? controlState,
    Wrapped<enums.TriggerControlTriggerTarget>? triggerTarget,
    Wrapped<enums.TriggerControlTriggerType?>? triggerType,
    Wrapped<enums.TriggerControlDeliveryTarget?>? deliveryTarget,
    Wrapped<String?>? controlId,
    Wrapped<String?>? otherDeviceId,
    Wrapped<String?>? otherControlId,
    Wrapped<HttpConfig?>? httpConfig,
    Wrapped<MqttConfig?>? mqttConfig,
    Wrapped<UdpConfig?>? udpConfig,
  }) {
    return TriggerControl(
      controlState: (controlState != null
          ? controlState.value
          : this.controlState),
      triggerTarget: (triggerTarget != null
          ? triggerTarget.value
          : this.triggerTarget),
      triggerType: (triggerType != null ? triggerType.value : this.triggerType),
      deliveryTarget: (deliveryTarget != null
          ? deliveryTarget.value
          : this.deliveryTarget),
      controlId: (controlId != null ? controlId.value : this.controlId),
      otherDeviceId: (otherDeviceId != null
          ? otherDeviceId.value
          : this.otherDeviceId),
      otherControlId: (otherControlId != null
          ? otherControlId.value
          : this.otherControlId),
      httpConfig: (httpConfig != null ? httpConfig.value : this.httpConfig),
      mqttConfig: (mqttConfig != null ? mqttConfig.value : this.mqttConfig),
      udpConfig: (udpConfig != null ? udpConfig.value : this.udpConfig),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerInfo {
  const TriggerInfo({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.conditions,
    required this.controls,
    this.tags,
  });

  factory TriggerInfo.fromJson(Map<String, dynamic> json) =>
      _$TriggerInfoFromJson(json);

  static const toJsonFactory = _$TriggerInfoToJson;
  Map<String, dynamic> toJson() => _$TriggerInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
    name: 'conditions',
    includeIfNull: false,
    defaultValue: <MatchGroup>[],
  )
  final List<MatchGroup> conditions;
  @JsonKey(
    name: 'controls',
    includeIfNull: false,
    defaultValue: <TriggerControl>[],
  )
  final List<TriggerControl> controls;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$TriggerInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.controls, controls) ||
                const DeepCollectionEquality().equals(
                  other.controls,
                  controls,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(controls) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $TriggerInfoExtension on TriggerInfo {
  TriggerInfo copyWith({
    String? name,
    String? description,
    String? modelId,
    String? icon,
    List<MatchGroup>? conditions,
    List<TriggerControl>? controls,
    List<String>? tags,
  }) {
    return TriggerInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      icon: icon ?? this.icon,
      conditions: conditions ?? this.conditions,
      controls: controls ?? this.controls,
      tags: tags ?? this.tags,
    );
  }

  TriggerInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? modelId,
    Wrapped<String?>? icon,
    Wrapped<List<MatchGroup>>? conditions,
    Wrapped<List<TriggerControl>>? controls,
    Wrapped<List<String>?>? tags,
  }) {
    return TriggerInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      icon: (icon != null ? icon.value : this.icon),
      conditions: (conditions != null ? conditions.value : this.conditions),
      controls: (controls != null ? controls.value : this.controls),
      tags: (tags != null ? tags.value : this.tags),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Trigger {
  const Trigger({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.conditions,
    required this.controls,
    this.tags,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Trigger.fromJson(Map<String, dynamic> json) =>
      _$TriggerFromJson(json);

  static const toJsonFactory = _$TriggerToJson;
  Map<String, dynamic> toJson() => _$TriggerToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
    name: 'conditions',
    includeIfNull: false,
    defaultValue: <MatchGroup>[],
  )
  final List<MatchGroup> conditions;
  @JsonKey(
    name: 'controls',
    includeIfNull: false,
    defaultValue: <TriggerControl>[],
  )
  final List<TriggerControl> controls;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$TriggerFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Trigger &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.controls, controls) ||
                const DeepCollectionEquality().equals(
                  other.controls,
                  controls,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(controls) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $TriggerExtension on Trigger {
  Trigger copyWith({
    String? name,
    String? description,
    String? modelId,
    String? icon,
    List<MatchGroup>? conditions,
    List<TriggerControl>? controls,
    List<String>? tags,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Trigger(
      name: name ?? this.name,
      description: description ?? this.description,
      modelId: modelId ?? this.modelId,
      icon: icon ?? this.icon,
      conditions: conditions ?? this.conditions,
      controls: controls ?? this.controls,
      tags: tags ?? this.tags,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Trigger copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String>? modelId,
    Wrapped<String?>? icon,
    Wrapped<List<MatchGroup>>? conditions,
    Wrapped<List<TriggerControl>>? controls,
    Wrapped<List<String>?>? tags,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Trigger(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      modelId: (modelId != null ? modelId.value : this.modelId),
      icon: (icon != null ? icon.value : this.icon),
      conditions: (conditions != null ? conditions.value : this.conditions),
      controls: (controls != null ? controls.value : this.controls),
      tags: (tags != null ? tags.value : this.tags),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerEntity {
  const TriggerEntity({this.entity});

  factory TriggerEntity.fromJson(Map<String, dynamic> json) =>
      _$TriggerEntityFromJson(json);

  static const toJsonFactory = _$TriggerEntityToJson;
  Map<String, dynamic> toJson() => _$TriggerEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Trigger? entity;
  static const fromJsonFactory = _$TriggerEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $TriggerEntityExtension on TriggerEntity {
  TriggerEntity copyWith({Trigger? entity}) {
    return TriggerEntity(entity: entity ?? this.entity);
  }

  TriggerEntity copyWithWrapped({Wrapped<Trigger?>? entity}) {
    return TriggerEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerEntityRes {
  const TriggerEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory TriggerEntityRes.fromJson(Map<String, dynamic> json) =>
      _$TriggerEntityResFromJson(json);

  static const toJsonFactory = _$TriggerEntityResToJson;
  Map<String, dynamic> toJson() => _$TriggerEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Trigger? entity;
  static const fromJsonFactory = _$TriggerEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $TriggerEntityResExtension on TriggerEntityRes {
  TriggerEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Trigger? entity,
  }) {
    return TriggerEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  TriggerEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Trigger?>? entity,
  }) {
    return TriggerEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerArray {
  const TriggerArray({this.values});

  factory TriggerArray.fromJson(Map<String, dynamic> json) =>
      _$TriggerArrayFromJson(json);

  static const toJsonFactory = _$TriggerArrayToJson;
  Map<String, dynamic> toJson() => _$TriggerArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Trigger>[])
  final List<Trigger>? values;
  static const fromJsonFactory = _$TriggerArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TriggerArrayExtension on TriggerArray {
  TriggerArray copyWith({List<Trigger>? values}) {
    return TriggerArray(values: values ?? this.values);
  }

  TriggerArray copyWithWrapped({Wrapped<List<Trigger>?>? values}) {
    return TriggerArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerArrayRes {
  const TriggerArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TriggerArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TriggerArrayResFromJson(json);

  static const toJsonFactory = _$TriggerArrayResToJson;
  Map<String, dynamic> toJson() => _$TriggerArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Trigger>[])
  final List<Trigger>? values;
  static const fromJsonFactory = _$TriggerArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TriggerArrayResExtension on TriggerArrayRes {
  TriggerArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Trigger>? values,
  }) {
    return TriggerArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  TriggerArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Trigger>?>? values,
  }) {
    return TriggerArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationTemplate {
  const NotificationTemplate({required this.title, required this.content});

  factory NotificationTemplate.fromJson(Map<String, dynamic> json) =>
      _$NotificationTemplateFromJson(json);

  static const toJsonFactory = _$NotificationTemplateToJson;
  Map<String, dynamic> toJson() => _$NotificationTemplateToJson(this);

  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String title;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: '')
  final String content;
  static const fromJsonFactory = _$NotificationTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NotificationTemplate &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $NotificationTemplateExtension on NotificationTemplate {
  NotificationTemplate copyWith({String? title, String? content}) {
    return NotificationTemplate(
      title: title ?? this.title,
      content: content ?? this.content,
    );
  }

  NotificationTemplate copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<String>? content,
  }) {
    return NotificationTemplate(
      title: (title != null ? title.value : this.title),
      content: (content != null ? content.value : this.content),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EmailTemplate {
  const EmailTemplate({
    required this.subject,
    required this.content,
    this.isHtml,
  });

  factory EmailTemplate.fromJson(Map<String, dynamic> json) =>
      _$EmailTemplateFromJson(json);

  static const toJsonFactory = _$EmailTemplateToJson;
  Map<String, dynamic> toJson() => _$EmailTemplateToJson(this);

  @JsonKey(name: 'subject', includeIfNull: false, defaultValue: '')
  final String subject;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: '')
  final String content;
  @JsonKey(name: 'isHtml', includeIfNull: false)
  final bool? isHtml;
  static const fromJsonFactory = _$EmailTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EmailTemplate &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(
                  other.subject,
                  subject,
                )) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(
                  other.content,
                  content,
                )) &&
            (identical(other.isHtml, isHtml) ||
                const DeepCollectionEquality().equals(other.isHtml, isHtml)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(content) ^
      const DeepCollectionEquality().hash(isHtml) ^
      runtimeType.hashCode;
}

extension $EmailTemplateExtension on EmailTemplate {
  EmailTemplate copyWith({String? subject, String? content, bool? isHtml}) {
    return EmailTemplate(
      subject: subject ?? this.subject,
      content: content ?? this.content,
      isHtml: isHtml ?? this.isHtml,
    );
  }

  EmailTemplate copyWithWrapped({
    Wrapped<String>? subject,
    Wrapped<String>? content,
    Wrapped<bool?>? isHtml,
  }) {
    return EmailTemplate(
      subject: (subject != null ? subject.value : this.subject),
      content: (content != null ? content.value : this.content),
      isHtml: (isHtml != null ? isHtml.value : this.isHtml),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FCMTemplate {
  const FCMTemplate({required this.title, required this.content});

  factory FCMTemplate.fromJson(Map<String, dynamic> json) =>
      _$FCMTemplateFromJson(json);

  static const toJsonFactory = _$FCMTemplateToJson;
  Map<String, dynamic> toJson() => _$FCMTemplateToJson(this);

  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String title;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: '')
  final String content;
  static const fromJsonFactory = _$FCMTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FCMTemplate &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $FCMTemplateExtension on FCMTemplate {
  FCMTemplate copyWith({String? title, String? content}) {
    return FCMTemplate(
      title: title ?? this.title,
      content: content ?? this.content,
    );
  }

  FCMTemplate copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<String>? content,
  }) {
    return FCMTemplate(
      title: (title != null ? title.value : this.title),
      content: (content != null ? content.value : this.content),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SMSTemplate {
  const SMSTemplate({required this.message});

  factory SMSTemplate.fromJson(Map<String, dynamic> json) =>
      _$SMSTemplateFromJson(json);

  static const toJsonFactory = _$SMSTemplateToJson;
  Map<String, dynamic> toJson() => _$SMSTemplateToJson(this);

  @JsonKey(name: 'message', includeIfNull: false, defaultValue: '')
  final String message;
  static const fromJsonFactory = _$SMSTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SMSTemplate &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(message) ^ runtimeType.hashCode;
}

extension $SMSTemplateExtension on SMSTemplate {
  SMSTemplate copyWith({String? message}) {
    return SMSTemplate(message: message ?? this.message);
  }

  SMSTemplate copyWithWrapped({Wrapped<String>? message}) {
    return SMSTemplate(
      message: (message != null ? message.value : this.message),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceTemplate {
  const VoiceTemplate({required this.message});

  factory VoiceTemplate.fromJson(Map<String, dynamic> json) =>
      _$VoiceTemplateFromJson(json);

  static const toJsonFactory = _$VoiceTemplateToJson;
  Map<String, dynamic> toJson() => _$VoiceTemplateToJson(this);

  @JsonKey(name: 'message', includeIfNull: false, defaultValue: '')
  final String message;
  static const fromJsonFactory = _$VoiceTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceTemplate &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(message) ^ runtimeType.hashCode;
}

extension $VoiceTemplateExtension on VoiceTemplate {
  VoiceTemplate copyWith({String? message}) {
    return VoiceTemplate(message: message ?? this.message);
  }

  VoiceTemplate copyWithWrapped({Wrapped<String>? message}) {
    return VoiceTemplate(
      message: (message != null ? message.value : this.message),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinImageInfo {
  const TwinImageInfo({required this.name, this.tags});

  factory TwinImageInfo.fromJson(Map<String, dynamic> json) =>
      _$TwinImageInfoFromJson(json);

  static const toJsonFactory = _$TwinImageInfoToJson;
  Map<String, dynamic> toJson() => _$TwinImageInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$TwinImageInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinImageInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $TwinImageInfoExtension on TwinImageInfo {
  TwinImageInfo copyWith({String? name, List<String>? tags}) {
    return TwinImageInfo(name: name ?? this.name, tags: tags ?? this.tags);
  }

  TwinImageInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<List<String>?>? tags,
  }) {
    return TwinImageInfo(
      name: (name != null ? name.value : this.name),
      tags: (tags != null ? tags.value : this.tags),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinImageBase {
  const TwinImageBase({required this.contentType});

  factory TwinImageBase.fromJson(Map<String, dynamic> json) =>
      _$TwinImageBaseFromJson(json);

  static const toJsonFactory = _$TwinImageBaseToJson;
  Map<String, dynamic> toJson() => _$TwinImageBaseToJson(this);

  @JsonKey(name: 'contentType', includeIfNull: false, defaultValue: '')
  final String contentType;
  static const fromJsonFactory = _$TwinImageBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinImageBase &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality().equals(
                  other.contentType,
                  contentType,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(contentType) ^ runtimeType.hashCode;
}

extension $TwinImageBaseExtension on TwinImageBase {
  TwinImageBase copyWith({String? contentType}) {
    return TwinImageBase(contentType: contentType ?? this.contentType);
  }

  TwinImageBase copyWithWrapped({Wrapped<String>? contentType}) {
    return TwinImageBase(
      contentType: (contentType != null ? contentType.value : this.contentType),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinImage {
  const TwinImage({
    required this.name,
    this.tags,
    required this.contentType,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory TwinImage.fromJson(Map<String, dynamic> json) =>
      _$TwinImageFromJson(json);

  static const toJsonFactory = _$TwinImageToJson;
  Map<String, dynamic> toJson() => _$TwinImageToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'contentType', includeIfNull: false, defaultValue: '')
  final String contentType;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$TwinImageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinImage &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality().equals(
                  other.contentType,
                  contentType,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $TwinImageExtension on TwinImage {
  TwinImage copyWith({
    String? name,
    List<String>? tags,
    String? contentType,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return TwinImage(
      name: name ?? this.name,
      tags: tags ?? this.tags,
      contentType: contentType ?? this.contentType,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  TwinImage copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<List<String>?>? tags,
    Wrapped<String>? contentType,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return TwinImage(
      name: (name != null ? name.value : this.name),
      tags: (tags != null ? tags.value : this.tags),
      contentType: (contentType != null ? contentType.value : this.contentType),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinImageEntity {
  const TwinImageEntity({this.entity});

  factory TwinImageEntity.fromJson(Map<String, dynamic> json) =>
      _$TwinImageEntityFromJson(json);

  static const toJsonFactory = _$TwinImageEntityToJson;
  Map<String, dynamic> toJson() => _$TwinImageEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinImage? entity;
  static const fromJsonFactory = _$TwinImageEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinImageEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $TwinImageEntityExtension on TwinImageEntity {
  TwinImageEntity copyWith({TwinImage? entity}) {
    return TwinImageEntity(entity: entity ?? this.entity);
  }

  TwinImageEntity copyWithWrapped({Wrapped<TwinImage?>? entity}) {
    return TwinImageEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinImageEntityRes {
  const TwinImageEntityRes({
    this.entity,
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory TwinImageEntityRes.fromJson(Map<String, dynamic> json) =>
      _$TwinImageEntityResFromJson(json);

  static const toJsonFactory = _$TwinImageEntityResToJson;
  Map<String, dynamic> toJson() => _$TwinImageEntityResToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinImage? entity;
  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$TwinImageEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinImageEntityRes &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $TwinImageEntityResExtension on TwinImageEntityRes {
  TwinImageEntityRes copyWith({
    TwinImage? entity,
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
  }) {
    return TwinImageEntityRes(
      entity: entity ?? this.entity,
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
    );
  }

  TwinImageEntityRes copyWithWrapped({
    Wrapped<TwinImage?>? entity,
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
  }) {
    return TwinImageEntityRes(
      entity: (entity != null ? entity.value : this.entity),
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinImageArray {
  const TwinImageArray({this.values});

  factory TwinImageArray.fromJson(Map<String, dynamic> json) =>
      _$TwinImageArrayFromJson(json);

  static const toJsonFactory = _$TwinImageArrayToJson;
  Map<String, dynamic> toJson() => _$TwinImageArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TwinImage>[])
  final List<TwinImage>? values;
  static const fromJsonFactory = _$TwinImageArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinImageArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TwinImageArrayExtension on TwinImageArray {
  TwinImageArray copyWith({List<TwinImage>? values}) {
    return TwinImageArray(values: values ?? this.values);
  }

  TwinImageArray copyWithWrapped({Wrapped<List<TwinImage>?>? values}) {
    return TwinImageArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinImageArrayRes {
  const TwinImageArrayRes({
    this.values,
    required this.page,
    required this.size,
    required this.total,
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory TwinImageArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TwinImageArrayResFromJson(json);

  static const toJsonFactory = _$TwinImageArrayResToJson;
  Map<String, dynamic> toJson() => _$TwinImageArrayResToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TwinImage>[])
  final List<TwinImage>? values;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$TwinImageArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinImageArrayRes &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $TwinImageArrayResExtension on TwinImageArrayRes {
  TwinImageArrayRes copyWith({
    List<TwinImage>? values,
    int? page,
    int? size,
    int? total,
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
  }) {
    return TwinImageArrayRes(
      values: values ?? this.values,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
    );
  }

  TwinImageArrayRes copyWithWrapped({
    Wrapped<List<TwinImage>?>? values,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
  }) {
    return TwinImageArrayRes(
      values: (values != null ? values.value : this.values),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayMatchGroup {
  const DisplayMatchGroup({
    required this.matchType,
    required this.conditions,
    required this.font,
    required this.fontSize,
    required this.fontColor,
    this.fontStyle,
    this.fontWeight,
    this.bordorColor,
    this.borderType,
    this.$value,
    this.bgColor,
    this.prefixText,
    this.prefixFont,
    this.prefixFontSize,
    this.prefixFontColor,
    this.prefixFontStyle,
    this.prefixFontWeight,
    this.prefixPadding,
    this.suffixText,
    this.suffixFont,
    this.suffixFontSize,
    this.suffixFontColor,
    this.suffixFontStyle,
    this.suffixFontWeight,
    this.suffixPadding,
    this.topText,
    this.topFont,
    this.topFontSize,
    this.topFontColor,
    this.topFontStyle,
    this.topFontWeight,
    this.topPadding,
    this.bottomText,
    this.bottomFont,
    this.bottomFontSize,
    this.bottomFontColor,
    this.bottomFontStyle,
    this.bottomFontWeight,
    this.bottomPadding,
    required this.width,
    required this.height,
    this.field,
    this.tooltip,
  });

  factory DisplayMatchGroup.fromJson(Map<String, dynamic> json) =>
      _$DisplayMatchGroupFromJson(json);

  static const toJsonFactory = _$DisplayMatchGroupToJson;
  Map<String, dynamic> toJson() => _$DisplayMatchGroupToJson(this);

  @JsonKey(
    name: 'matchType',
    includeIfNull: false,
    toJson: displayMatchGroupMatchTypeToJson,
    fromJson: displayMatchGroupMatchTypeFromJson,
  )
  final enums.DisplayMatchGroupMatchType matchType;
  @JsonKey(name: 'conditions', includeIfNull: false, defaultValue: <String>[])
  final List<String> conditions;
  @JsonKey(name: 'font', includeIfNull: false, defaultValue: '')
  final String font;
  @JsonKey(name: 'fontSize', includeIfNull: false)
  final double fontSize;
  @JsonKey(name: 'fontColor', includeIfNull: false)
  final int fontColor;
  @JsonKey(name: 'fontStyle', includeIfNull: false, defaultValue: '')
  final String? fontStyle;
  @JsonKey(name: 'fontWeight', includeIfNull: false)
  final int? fontWeight;
  @JsonKey(name: 'bordorColor', includeIfNull: false)
  final int? bordorColor;
  @JsonKey(
    name: 'borderType',
    includeIfNull: false,
    toJson: displayMatchGroupBorderTypeNullableToJson,
    fromJson: displayMatchGroupBorderTypeNullableFromJson,
  )
  final enums.DisplayMatchGroupBorderType? borderType;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'prefixText', includeIfNull: false, defaultValue: '')
  final String? prefixText;
  @JsonKey(name: 'prefixFont', includeIfNull: false, defaultValue: '')
  final String? prefixFont;
  @JsonKey(name: 'prefixFontSize', includeIfNull: false)
  final double? prefixFontSize;
  @JsonKey(name: 'prefixFontColor', includeIfNull: false)
  final int? prefixFontColor;
  @JsonKey(name: 'prefixFontStyle', includeIfNull: false, defaultValue: '')
  final String? prefixFontStyle;
  @JsonKey(name: 'prefixFontWeight', includeIfNull: false)
  final int? prefixFontWeight;
  @JsonKey(name: 'prefixPadding', includeIfNull: false)
  final double? prefixPadding;
  @JsonKey(name: 'suffixText', includeIfNull: false, defaultValue: '')
  final String? suffixText;
  @JsonKey(name: 'suffixFont', includeIfNull: false, defaultValue: '')
  final String? suffixFont;
  @JsonKey(name: 'suffixFontSize', includeIfNull: false)
  final double? suffixFontSize;
  @JsonKey(name: 'suffixFontColor', includeIfNull: false)
  final int? suffixFontColor;
  @JsonKey(name: 'suffixFontStyle', includeIfNull: false, defaultValue: '')
  final String? suffixFontStyle;
  @JsonKey(name: 'suffixFontWeight', includeIfNull: false)
  final int? suffixFontWeight;
  @JsonKey(name: 'suffixPadding', includeIfNull: false)
  final double? suffixPadding;
  @JsonKey(name: 'topText', includeIfNull: false, defaultValue: '')
  final String? topText;
  @JsonKey(name: 'topFont', includeIfNull: false, defaultValue: '')
  final String? topFont;
  @JsonKey(name: 'topFontSize', includeIfNull: false)
  final double? topFontSize;
  @JsonKey(name: 'topFontColor', includeIfNull: false)
  final int? topFontColor;
  @JsonKey(name: 'topFontStyle', includeIfNull: false, defaultValue: '')
  final String? topFontStyle;
  @JsonKey(name: 'topFontWeight', includeIfNull: false)
  final int? topFontWeight;
  @JsonKey(name: 'topPadding', includeIfNull: false)
  final double? topPadding;
  @JsonKey(name: 'bottomText', includeIfNull: false, defaultValue: '')
  final String? bottomText;
  @JsonKey(name: 'bottomFont', includeIfNull: false, defaultValue: '')
  final String? bottomFont;
  @JsonKey(name: 'bottomFontSize', includeIfNull: false)
  final double? bottomFontSize;
  @JsonKey(name: 'bottomFontColor', includeIfNull: false)
  final int? bottomFontColor;
  @JsonKey(name: 'bottomFontStyle', includeIfNull: false, defaultValue: '')
  final String? bottomFontStyle;
  @JsonKey(name: 'bottomFontWeight', includeIfNull: false)
  final int? bottomFontWeight;
  @JsonKey(name: 'bottomPadding', includeIfNull: false)
  final double? bottomPadding;
  @JsonKey(name: 'width', includeIfNull: false)
  final double width;
  @JsonKey(name: 'height', includeIfNull: false)
  final double height;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String? field;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  static const fromJsonFactory = _$DisplayMatchGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayMatchGroup &&
            (identical(other.matchType, matchType) ||
                const DeepCollectionEquality().equals(
                  other.matchType,
                  matchType,
                )) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.font, font) ||
                const DeepCollectionEquality().equals(other.font, font)) &&
            (identical(other.fontSize, fontSize) ||
                const DeepCollectionEquality().equals(
                  other.fontSize,
                  fontSize,
                )) &&
            (identical(other.fontColor, fontColor) ||
                const DeepCollectionEquality().equals(
                  other.fontColor,
                  fontColor,
                )) &&
            (identical(other.fontStyle, fontStyle) ||
                const DeepCollectionEquality().equals(
                  other.fontStyle,
                  fontStyle,
                )) &&
            (identical(other.fontWeight, fontWeight) ||
                const DeepCollectionEquality().equals(
                  other.fontWeight,
                  fontWeight,
                )) &&
            (identical(other.bordorColor, bordorColor) ||
                const DeepCollectionEquality().equals(
                  other.bordorColor,
                  bordorColor,
                )) &&
            (identical(other.borderType, borderType) ||
                const DeepCollectionEquality().equals(
                  other.borderType,
                  borderType,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality().equals(
                  other.bgColor,
                  bgColor,
                )) &&
            (identical(other.prefixText, prefixText) ||
                const DeepCollectionEquality().equals(
                  other.prefixText,
                  prefixText,
                )) &&
            (identical(other.prefixFont, prefixFont) ||
                const DeepCollectionEquality().equals(
                  other.prefixFont,
                  prefixFont,
                )) &&
            (identical(other.prefixFontSize, prefixFontSize) ||
                const DeepCollectionEquality().equals(
                  other.prefixFontSize,
                  prefixFontSize,
                )) &&
            (identical(other.prefixFontColor, prefixFontColor) ||
                const DeepCollectionEquality().equals(
                  other.prefixFontColor,
                  prefixFontColor,
                )) &&
            (identical(other.prefixFontStyle, prefixFontStyle) ||
                const DeepCollectionEquality().equals(
                  other.prefixFontStyle,
                  prefixFontStyle,
                )) &&
            (identical(other.prefixFontWeight, prefixFontWeight) ||
                const DeepCollectionEquality().equals(
                  other.prefixFontWeight,
                  prefixFontWeight,
                )) &&
            (identical(other.prefixPadding, prefixPadding) ||
                const DeepCollectionEquality().equals(
                  other.prefixPadding,
                  prefixPadding,
                )) &&
            (identical(other.suffixText, suffixText) ||
                const DeepCollectionEquality().equals(
                  other.suffixText,
                  suffixText,
                )) &&
            (identical(other.suffixFont, suffixFont) ||
                const DeepCollectionEquality().equals(
                  other.suffixFont,
                  suffixFont,
                )) &&
            (identical(other.suffixFontSize, suffixFontSize) ||
                const DeepCollectionEquality().equals(
                  other.suffixFontSize,
                  suffixFontSize,
                )) &&
            (identical(other.suffixFontColor, suffixFontColor) ||
                const DeepCollectionEquality().equals(
                  other.suffixFontColor,
                  suffixFontColor,
                )) &&
            (identical(other.suffixFontStyle, suffixFontStyle) ||
                const DeepCollectionEquality().equals(
                  other.suffixFontStyle,
                  suffixFontStyle,
                )) &&
            (identical(other.suffixFontWeight, suffixFontWeight) ||
                const DeepCollectionEquality().equals(
                  other.suffixFontWeight,
                  suffixFontWeight,
                )) &&
            (identical(other.suffixPadding, suffixPadding) ||
                const DeepCollectionEquality().equals(
                  other.suffixPadding,
                  suffixPadding,
                )) &&
            (identical(other.topText, topText) ||
                const DeepCollectionEquality().equals(
                  other.topText,
                  topText,
                )) &&
            (identical(other.topFont, topFont) ||
                const DeepCollectionEquality().equals(
                  other.topFont,
                  topFont,
                )) &&
            (identical(other.topFontSize, topFontSize) ||
                const DeepCollectionEquality().equals(
                  other.topFontSize,
                  topFontSize,
                )) &&
            (identical(other.topFontColor, topFontColor) ||
                const DeepCollectionEquality().equals(
                  other.topFontColor,
                  topFontColor,
                )) &&
            (identical(other.topFontStyle, topFontStyle) ||
                const DeepCollectionEquality().equals(
                  other.topFontStyle,
                  topFontStyle,
                )) &&
            (identical(other.topFontWeight, topFontWeight) ||
                const DeepCollectionEquality().equals(
                  other.topFontWeight,
                  topFontWeight,
                )) &&
            (identical(other.topPadding, topPadding) ||
                const DeepCollectionEquality().equals(
                  other.topPadding,
                  topPadding,
                )) &&
            (identical(other.bottomText, bottomText) ||
                const DeepCollectionEquality().equals(
                  other.bottomText,
                  bottomText,
                )) &&
            (identical(other.bottomFont, bottomFont) ||
                const DeepCollectionEquality().equals(
                  other.bottomFont,
                  bottomFont,
                )) &&
            (identical(other.bottomFontSize, bottomFontSize) ||
                const DeepCollectionEquality().equals(
                  other.bottomFontSize,
                  bottomFontSize,
                )) &&
            (identical(other.bottomFontColor, bottomFontColor) ||
                const DeepCollectionEquality().equals(
                  other.bottomFontColor,
                  bottomFontColor,
                )) &&
            (identical(other.bottomFontStyle, bottomFontStyle) ||
                const DeepCollectionEquality().equals(
                  other.bottomFontStyle,
                  bottomFontStyle,
                )) &&
            (identical(other.bottomFontWeight, bottomFontWeight) ||
                const DeepCollectionEquality().equals(
                  other.bottomFontWeight,
                  bottomFontWeight,
                )) &&
            (identical(other.bottomPadding, bottomPadding) ||
                const DeepCollectionEquality().equals(
                  other.bottomPadding,
                  bottomPadding,
                )) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(other.tooltip, tooltip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(matchType) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(font) ^
      const DeepCollectionEquality().hash(fontSize) ^
      const DeepCollectionEquality().hash(fontColor) ^
      const DeepCollectionEquality().hash(fontStyle) ^
      const DeepCollectionEquality().hash(fontWeight) ^
      const DeepCollectionEquality().hash(bordorColor) ^
      const DeepCollectionEquality().hash(borderType) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(prefixText) ^
      const DeepCollectionEquality().hash(prefixFont) ^
      const DeepCollectionEquality().hash(prefixFontSize) ^
      const DeepCollectionEquality().hash(prefixFontColor) ^
      const DeepCollectionEquality().hash(prefixFontStyle) ^
      const DeepCollectionEquality().hash(prefixFontWeight) ^
      const DeepCollectionEquality().hash(prefixPadding) ^
      const DeepCollectionEquality().hash(suffixText) ^
      const DeepCollectionEquality().hash(suffixFont) ^
      const DeepCollectionEquality().hash(suffixFontSize) ^
      const DeepCollectionEquality().hash(suffixFontColor) ^
      const DeepCollectionEquality().hash(suffixFontStyle) ^
      const DeepCollectionEquality().hash(suffixFontWeight) ^
      const DeepCollectionEquality().hash(suffixPadding) ^
      const DeepCollectionEquality().hash(topText) ^
      const DeepCollectionEquality().hash(topFont) ^
      const DeepCollectionEquality().hash(topFontSize) ^
      const DeepCollectionEquality().hash(topFontColor) ^
      const DeepCollectionEquality().hash(topFontStyle) ^
      const DeepCollectionEquality().hash(topFontWeight) ^
      const DeepCollectionEquality().hash(topPadding) ^
      const DeepCollectionEquality().hash(bottomText) ^
      const DeepCollectionEquality().hash(bottomFont) ^
      const DeepCollectionEquality().hash(bottomFontSize) ^
      const DeepCollectionEquality().hash(bottomFontColor) ^
      const DeepCollectionEquality().hash(bottomFontStyle) ^
      const DeepCollectionEquality().hash(bottomFontWeight) ^
      const DeepCollectionEquality().hash(bottomPadding) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(tooltip) ^
      runtimeType.hashCode;
}

extension $DisplayMatchGroupExtension on DisplayMatchGroup {
  DisplayMatchGroup copyWith({
    enums.DisplayMatchGroupMatchType? matchType,
    List<String>? conditions,
    String? font,
    double? fontSize,
    int? fontColor,
    String? fontStyle,
    int? fontWeight,
    int? bordorColor,
    enums.DisplayMatchGroupBorderType? borderType,
    String? $value,
    int? bgColor,
    String? prefixText,
    String? prefixFont,
    double? prefixFontSize,
    int? prefixFontColor,
    String? prefixFontStyle,
    int? prefixFontWeight,
    double? prefixPadding,
    String? suffixText,
    String? suffixFont,
    double? suffixFontSize,
    int? suffixFontColor,
    String? suffixFontStyle,
    int? suffixFontWeight,
    double? suffixPadding,
    String? topText,
    String? topFont,
    double? topFontSize,
    int? topFontColor,
    String? topFontStyle,
    int? topFontWeight,
    double? topPadding,
    String? bottomText,
    String? bottomFont,
    double? bottomFontSize,
    int? bottomFontColor,
    String? bottomFontStyle,
    int? bottomFontWeight,
    double? bottomPadding,
    double? width,
    double? height,
    String? field,
    String? tooltip,
  }) {
    return DisplayMatchGroup(
      matchType: matchType ?? this.matchType,
      conditions: conditions ?? this.conditions,
      font: font ?? this.font,
      fontSize: fontSize ?? this.fontSize,
      fontColor: fontColor ?? this.fontColor,
      fontStyle: fontStyle ?? this.fontStyle,
      fontWeight: fontWeight ?? this.fontWeight,
      bordorColor: bordorColor ?? this.bordorColor,
      borderType: borderType ?? this.borderType,
      $value: $value ?? this.$value,
      bgColor: bgColor ?? this.bgColor,
      prefixText: prefixText ?? this.prefixText,
      prefixFont: prefixFont ?? this.prefixFont,
      prefixFontSize: prefixFontSize ?? this.prefixFontSize,
      prefixFontColor: prefixFontColor ?? this.prefixFontColor,
      prefixFontStyle: prefixFontStyle ?? this.prefixFontStyle,
      prefixFontWeight: prefixFontWeight ?? this.prefixFontWeight,
      prefixPadding: prefixPadding ?? this.prefixPadding,
      suffixText: suffixText ?? this.suffixText,
      suffixFont: suffixFont ?? this.suffixFont,
      suffixFontSize: suffixFontSize ?? this.suffixFontSize,
      suffixFontColor: suffixFontColor ?? this.suffixFontColor,
      suffixFontStyle: suffixFontStyle ?? this.suffixFontStyle,
      suffixFontWeight: suffixFontWeight ?? this.suffixFontWeight,
      suffixPadding: suffixPadding ?? this.suffixPadding,
      topText: topText ?? this.topText,
      topFont: topFont ?? this.topFont,
      topFontSize: topFontSize ?? this.topFontSize,
      topFontColor: topFontColor ?? this.topFontColor,
      topFontStyle: topFontStyle ?? this.topFontStyle,
      topFontWeight: topFontWeight ?? this.topFontWeight,
      topPadding: topPadding ?? this.topPadding,
      bottomText: bottomText ?? this.bottomText,
      bottomFont: bottomFont ?? this.bottomFont,
      bottomFontSize: bottomFontSize ?? this.bottomFontSize,
      bottomFontColor: bottomFontColor ?? this.bottomFontColor,
      bottomFontStyle: bottomFontStyle ?? this.bottomFontStyle,
      bottomFontWeight: bottomFontWeight ?? this.bottomFontWeight,
      bottomPadding: bottomPadding ?? this.bottomPadding,
      width: width ?? this.width,
      height: height ?? this.height,
      field: field ?? this.field,
      tooltip: tooltip ?? this.tooltip,
    );
  }

  DisplayMatchGroup copyWithWrapped({
    Wrapped<enums.DisplayMatchGroupMatchType>? matchType,
    Wrapped<List<String>>? conditions,
    Wrapped<String>? font,
    Wrapped<double>? fontSize,
    Wrapped<int>? fontColor,
    Wrapped<String?>? fontStyle,
    Wrapped<int?>? fontWeight,
    Wrapped<int?>? bordorColor,
    Wrapped<enums.DisplayMatchGroupBorderType?>? borderType,
    Wrapped<String?>? $value,
    Wrapped<int?>? bgColor,
    Wrapped<String?>? prefixText,
    Wrapped<String?>? prefixFont,
    Wrapped<double?>? prefixFontSize,
    Wrapped<int?>? prefixFontColor,
    Wrapped<String?>? prefixFontStyle,
    Wrapped<int?>? prefixFontWeight,
    Wrapped<double?>? prefixPadding,
    Wrapped<String?>? suffixText,
    Wrapped<String?>? suffixFont,
    Wrapped<double?>? suffixFontSize,
    Wrapped<int?>? suffixFontColor,
    Wrapped<String?>? suffixFontStyle,
    Wrapped<int?>? suffixFontWeight,
    Wrapped<double?>? suffixPadding,
    Wrapped<String?>? topText,
    Wrapped<String?>? topFont,
    Wrapped<double?>? topFontSize,
    Wrapped<int?>? topFontColor,
    Wrapped<String?>? topFontStyle,
    Wrapped<int?>? topFontWeight,
    Wrapped<double?>? topPadding,
    Wrapped<String?>? bottomText,
    Wrapped<String?>? bottomFont,
    Wrapped<double?>? bottomFontSize,
    Wrapped<int?>? bottomFontColor,
    Wrapped<String?>? bottomFontStyle,
    Wrapped<int?>? bottomFontWeight,
    Wrapped<double?>? bottomPadding,
    Wrapped<double>? width,
    Wrapped<double>? height,
    Wrapped<String?>? field,
    Wrapped<String?>? tooltip,
  }) {
    return DisplayMatchGroup(
      matchType: (matchType != null ? matchType.value : this.matchType),
      conditions: (conditions != null ? conditions.value : this.conditions),
      font: (font != null ? font.value : this.font),
      fontSize: (fontSize != null ? fontSize.value : this.fontSize),
      fontColor: (fontColor != null ? fontColor.value : this.fontColor),
      fontStyle: (fontStyle != null ? fontStyle.value : this.fontStyle),
      fontWeight: (fontWeight != null ? fontWeight.value : this.fontWeight),
      bordorColor: (bordorColor != null ? bordorColor.value : this.bordorColor),
      borderType: (borderType != null ? borderType.value : this.borderType),
      $value: ($value != null ? $value.value : this.$value),
      bgColor: (bgColor != null ? bgColor.value : this.bgColor),
      prefixText: (prefixText != null ? prefixText.value : this.prefixText),
      prefixFont: (prefixFont != null ? prefixFont.value : this.prefixFont),
      prefixFontSize: (prefixFontSize != null
          ? prefixFontSize.value
          : this.prefixFontSize),
      prefixFontColor: (prefixFontColor != null
          ? prefixFontColor.value
          : this.prefixFontColor),
      prefixFontStyle: (prefixFontStyle != null
          ? prefixFontStyle.value
          : this.prefixFontStyle),
      prefixFontWeight: (prefixFontWeight != null
          ? prefixFontWeight.value
          : this.prefixFontWeight),
      prefixPadding: (prefixPadding != null
          ? prefixPadding.value
          : this.prefixPadding),
      suffixText: (suffixText != null ? suffixText.value : this.suffixText),
      suffixFont: (suffixFont != null ? suffixFont.value : this.suffixFont),
      suffixFontSize: (suffixFontSize != null
          ? suffixFontSize.value
          : this.suffixFontSize),
      suffixFontColor: (suffixFontColor != null
          ? suffixFontColor.value
          : this.suffixFontColor),
      suffixFontStyle: (suffixFontStyle != null
          ? suffixFontStyle.value
          : this.suffixFontStyle),
      suffixFontWeight: (suffixFontWeight != null
          ? suffixFontWeight.value
          : this.suffixFontWeight),
      suffixPadding: (suffixPadding != null
          ? suffixPadding.value
          : this.suffixPadding),
      topText: (topText != null ? topText.value : this.topText),
      topFont: (topFont != null ? topFont.value : this.topFont),
      topFontSize: (topFontSize != null ? topFontSize.value : this.topFontSize),
      topFontColor: (topFontColor != null
          ? topFontColor.value
          : this.topFontColor),
      topFontStyle: (topFontStyle != null
          ? topFontStyle.value
          : this.topFontStyle),
      topFontWeight: (topFontWeight != null
          ? topFontWeight.value
          : this.topFontWeight),
      topPadding: (topPadding != null ? topPadding.value : this.topPadding),
      bottomText: (bottomText != null ? bottomText.value : this.bottomText),
      bottomFont: (bottomFont != null ? bottomFont.value : this.bottomFont),
      bottomFontSize: (bottomFontSize != null
          ? bottomFontSize.value
          : this.bottomFontSize),
      bottomFontColor: (bottomFontColor != null
          ? bottomFontColor.value
          : this.bottomFontColor),
      bottomFontStyle: (bottomFontStyle != null
          ? bottomFontStyle.value
          : this.bottomFontStyle),
      bottomFontWeight: (bottomFontWeight != null
          ? bottomFontWeight.value
          : this.bottomFontWeight),
      bottomPadding: (bottomPadding != null
          ? bottomPadding.value
          : this.bottomPadding),
      width: (width != null ? width.value : this.width),
      height: (height != null ? height.value : this.height),
      field: (field != null ? field.value : this.field),
      tooltip: (tooltip != null ? tooltip.value : this.tooltip),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayInfo {
  const DisplayInfo({
    required this.name,
    this.description,
    this.label,
    this.modelId,
    this.deviceId,
    this.icon,
    required this.conditions,
    this.tags,
  });

  factory DisplayInfo.fromJson(Map<String, dynamic> json) =>
      _$DisplayInfoFromJson(json);

  static const toJsonFactory = _$DisplayInfoToJson;
  Map<String, dynamic> toJson() => _$DisplayInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
    name: 'conditions',
    includeIfNull: false,
    defaultValue: <DisplayMatchGroup>[],
  )
  final List<DisplayMatchGroup> conditions;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$DisplayInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $DisplayInfoExtension on DisplayInfo {
  DisplayInfo copyWith({
    String? name,
    String? description,
    String? label,
    String? modelId,
    String? deviceId,
    String? icon,
    List<DisplayMatchGroup>? conditions,
    List<String>? tags,
  }) {
    return DisplayInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      icon: icon ?? this.icon,
      conditions: conditions ?? this.conditions,
      tags: tags ?? this.tags,
    );
  }

  DisplayInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<String?>? modelId,
    Wrapped<String?>? deviceId,
    Wrapped<String?>? icon,
    Wrapped<List<DisplayMatchGroup>>? conditions,
    Wrapped<List<String>?>? tags,
  }) {
    return DisplayInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      icon: (icon != null ? icon.value : this.icon),
      conditions: (conditions != null ? conditions.value : this.conditions),
      tags: (tags != null ? tags.value : this.tags),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Display {
  const Display({
    required this.name,
    this.description,
    this.label,
    this.modelId,
    this.deviceId,
    this.icon,
    required this.conditions,
    this.tags,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Display.fromJson(Map<String, dynamic> json) =>
      _$DisplayFromJson(json);

  static const toJsonFactory = _$DisplayToJson;
  Map<String, dynamic> toJson() => _$DisplayToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
    name: 'conditions',
    includeIfNull: false,
    defaultValue: <DisplayMatchGroup>[],
  )
  final List<DisplayMatchGroup> conditions;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$DisplayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Display &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality().equals(
                  other.conditions,
                  conditions,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $DisplayExtension on Display {
  Display copyWith({
    String? name,
    String? description,
    String? label,
    String? modelId,
    String? deviceId,
    String? icon,
    List<DisplayMatchGroup>? conditions,
    List<String>? tags,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Display(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      icon: icon ?? this.icon,
      conditions: conditions ?? this.conditions,
      tags: tags ?? this.tags,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Display copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<String?>? modelId,
    Wrapped<String?>? deviceId,
    Wrapped<String?>? icon,
    Wrapped<List<DisplayMatchGroup>>? conditions,
    Wrapped<List<String>?>? tags,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Display(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      icon: (icon != null ? icon.value : this.icon),
      conditions: (conditions != null ? conditions.value : this.conditions),
      tags: (tags != null ? tags.value : this.tags),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayEntity {
  const DisplayEntity({this.entity});

  factory DisplayEntity.fromJson(Map<String, dynamic> json) =>
      _$DisplayEntityFromJson(json);

  static const toJsonFactory = _$DisplayEntityToJson;
  Map<String, dynamic> toJson() => _$DisplayEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Display? entity;
  static const fromJsonFactory = _$DisplayEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DisplayEntityExtension on DisplayEntity {
  DisplayEntity copyWith({Display? entity}) {
    return DisplayEntity(entity: entity ?? this.entity);
  }

  DisplayEntity copyWithWrapped({Wrapped<Display?>? entity}) {
    return DisplayEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayEntityRes {
  const DisplayEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DisplayEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DisplayEntityResFromJson(json);

  static const toJsonFactory = _$DisplayEntityResToJson;
  Map<String, dynamic> toJson() => _$DisplayEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Display? entity;
  static const fromJsonFactory = _$DisplayEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DisplayEntityResExtension on DisplayEntityRes {
  DisplayEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Display? entity,
  }) {
    return DisplayEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DisplayEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Display?>? entity,
  }) {
    return DisplayEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayArray {
  const DisplayArray({this.values});

  factory DisplayArray.fromJson(Map<String, dynamic> json) =>
      _$DisplayArrayFromJson(json);

  static const toJsonFactory = _$DisplayArrayToJson;
  Map<String, dynamic> toJson() => _$DisplayArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Display>[])
  final List<Display>? values;
  static const fromJsonFactory = _$DisplayArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DisplayArrayExtension on DisplayArray {
  DisplayArray copyWith({List<Display>? values}) {
    return DisplayArray(values: values ?? this.values);
  }

  DisplayArray copyWithWrapped({Wrapped<List<Display>?>? values}) {
    return DisplayArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayArrayRes {
  const DisplayArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DisplayArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DisplayArrayResFromJson(json);

  static const toJsonFactory = _$DisplayArrayResToJson;
  Map<String, dynamic> toJson() => _$DisplayArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Display>[])
  final List<Display>? values;
  static const fromJsonFactory = _$DisplayArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DisplayArrayResExtension on DisplayArrayRes {
  DisplayArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Display>? values,
  }) {
    return DisplayArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DisplayArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Display>?>? values,
  }) {
    return DisplayArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Displayable {
  const Displayable({
    required this.type,
    required this.id,
    required this.width,
    required this.height,
  });

  factory Displayable.fromJson(Map<String, dynamic> json) =>
      _$DisplayableFromJson(json);

  static const toJsonFactory = _$DisplayableToJson;
  Map<String, dynamic> toJson() => _$DisplayableToJson(this);

  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: displayableTypeToJson,
    fromJson: displayableTypeFromJson,
  )
  final enums.DisplayableType type;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'width', includeIfNull: false)
  final int width;
  @JsonKey(name: 'height', includeIfNull: false)
  final int height;
  static const fromJsonFactory = _$DisplayableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Displayable &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      runtimeType.hashCode;
}

extension $DisplayableExtension on Displayable {
  Displayable copyWith({
    enums.DisplayableType? type,
    String? id,
    int? width,
    int? height,
  }) {
    return Displayable(
      type: type ?? this.type,
      id: id ?? this.id,
      width: width ?? this.width,
      height: height ?? this.height,
    );
  }

  Displayable copyWithWrapped({
    Wrapped<enums.DisplayableType>? type,
    Wrapped<String>? id,
    Wrapped<int>? width,
    Wrapped<int>? height,
  }) {
    return Displayable(
      type: (type != null ? type.value : this.type),
      id: (id != null ? id.value : this.id),
      width: (width != null ? width.value : this.width),
      height: (height != null ? height.value : this.height),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Positionable {
  const Positionable({
    required this.view,
    this.top,
    this.bottom,
    this.left,
    this.right,
  });

  factory Positionable.fromJson(Map<String, dynamic> json) =>
      _$PositionableFromJson(json);

  static const toJsonFactory = _$PositionableToJson;
  Map<String, dynamic> toJson() => _$PositionableToJson(this);

  @JsonKey(name: 'view', includeIfNull: false)
  final Displayable view;
  @JsonKey(name: 'top', includeIfNull: false)
  final int? top;
  @JsonKey(name: 'bottom', includeIfNull: false)
  final int? bottom;
  @JsonKey(name: 'left', includeIfNull: false)
  final int? left;
  @JsonKey(name: 'right', includeIfNull: false)
  final int? right;
  static const fromJsonFactory = _$PositionableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Positionable &&
            (identical(other.view, view) ||
                const DeepCollectionEquality().equals(other.view, view)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.bottom, bottom) ||
                const DeepCollectionEquality().equals(other.bottom, bottom)) &&
            (identical(other.left, left) ||
                const DeepCollectionEquality().equals(other.left, left)) &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(view) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(bottom) ^
      const DeepCollectionEquality().hash(left) ^
      const DeepCollectionEquality().hash(right) ^
      runtimeType.hashCode;
}

extension $PositionableExtension on Positionable {
  Positionable copyWith({
    Displayable? view,
    int? top,
    int? bottom,
    int? left,
    int? right,
  }) {
    return Positionable(
      view: view ?? this.view,
      top: top ?? this.top,
      bottom: bottom ?? this.bottom,
      left: left ?? this.left,
      right: right ?? this.right,
    );
  }

  Positionable copyWithWrapped({
    Wrapped<Displayable>? view,
    Wrapped<int?>? top,
    Wrapped<int?>? bottom,
    Wrapped<int?>? left,
    Wrapped<int?>? right,
  }) {
    return Positionable(
      view: (view != null ? view.value : this.view),
      top: (top != null ? top.value : this.top),
      bottom: (bottom != null ? bottom.value : this.bottom),
      left: (left != null ? left.value : this.left),
      right: (right != null ? right.value : this.right),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewInfo {
  const DeviceViewInfo({
    required this.modelId,
    required this.name,
    this.top,
    this.bottom,
    this.left,
    this.right,
    this.positioned,
    this.description,
    this.tags,
    this.width,
    this.height,
    this.topHeight,
    this.bottomHeight,
    this.leftWidth,
    this.rightWidth,
    this.showInfo,
    this.infoPosition,
    this.border,
    this.roles,
  });

  factory DeviceViewInfo.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewInfoFromJson(json);

  static const toJsonFactory = _$DeviceViewInfoToJson;
  Map<String, dynamic> toJson() => _$DeviceViewInfoToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'top', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? top;
  @JsonKey(name: 'bottom', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? bottom;
  @JsonKey(name: 'left', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? left;
  @JsonKey(name: 'right', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? right;
  @JsonKey(
    name: 'positioned',
    includeIfNull: false,
    defaultValue: <Positionable>[],
  )
  final List<Positionable>? positioned;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'width', includeIfNull: false)
  final int? width;
  @JsonKey(name: 'height', includeIfNull: false)
  final int? height;
  @JsonKey(name: 'topHeight', includeIfNull: false)
  final int? topHeight;
  @JsonKey(name: 'bottomHeight', includeIfNull: false)
  final int? bottomHeight;
  @JsonKey(name: 'leftWidth', includeIfNull: false)
  final int? leftWidth;
  @JsonKey(name: 'rightWidth', includeIfNull: false)
  final int? rightWidth;
  @JsonKey(name: 'showInfo', includeIfNull: false, defaultValue: true)
  final bool? showInfo;
  @JsonKey(
    name: 'infoPosition',
    includeIfNull: false,
    toJson: deviceViewInfoInfoPositionNullableToJson,
    fromJson: deviceViewInfoInfoPositionInfoPositionNullableFromJson,
  )
  final enums.DeviceViewInfoInfoPosition? infoPosition;
  static enums.DeviceViewInfoInfoPosition?
  deviceViewInfoInfoPositionInfoPositionNullableFromJson(Object? value) =>
      deviceViewInfoInfoPositionNullableFromJson(
        value,
        enums.DeviceViewInfoInfoPosition.bottom,
      );

  @JsonKey(
    name: 'border',
    includeIfNull: false,
    toJson: deviceViewInfoBorderNullableToJson,
    fromJson: deviceViewInfoBorderBorderNullableFromJson,
  )
  final enums.DeviceViewInfoBorder? border;
  static enums.DeviceViewInfoBorder? deviceViewInfoBorderBorderNullableFromJson(
    Object? value,
  ) => deviceViewInfoBorderNullableFromJson(
    value,
    enums.DeviceViewInfoBorder.none,
  );

  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  static const fromJsonFactory = _$DeviceViewInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewInfo &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.bottom, bottom) ||
                const DeepCollectionEquality().equals(other.bottom, bottom)) &&
            (identical(other.left, left) ||
                const DeepCollectionEquality().equals(other.left, left)) &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)) &&
            (identical(other.positioned, positioned) ||
                const DeepCollectionEquality().equals(
                  other.positioned,
                  positioned,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.topHeight, topHeight) ||
                const DeepCollectionEquality().equals(
                  other.topHeight,
                  topHeight,
                )) &&
            (identical(other.bottomHeight, bottomHeight) ||
                const DeepCollectionEquality().equals(
                  other.bottomHeight,
                  bottomHeight,
                )) &&
            (identical(other.leftWidth, leftWidth) ||
                const DeepCollectionEquality().equals(
                  other.leftWidth,
                  leftWidth,
                )) &&
            (identical(other.rightWidth, rightWidth) ||
                const DeepCollectionEquality().equals(
                  other.rightWidth,
                  rightWidth,
                )) &&
            (identical(other.showInfo, showInfo) ||
                const DeepCollectionEquality().equals(
                  other.showInfo,
                  showInfo,
                )) &&
            (identical(other.infoPosition, infoPosition) ||
                const DeepCollectionEquality().equals(
                  other.infoPosition,
                  infoPosition,
                )) &&
            (identical(other.border, border) ||
                const DeepCollectionEquality().equals(other.border, border)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(bottom) ^
      const DeepCollectionEquality().hash(left) ^
      const DeepCollectionEquality().hash(right) ^
      const DeepCollectionEquality().hash(positioned) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(topHeight) ^
      const DeepCollectionEquality().hash(bottomHeight) ^
      const DeepCollectionEquality().hash(leftWidth) ^
      const DeepCollectionEquality().hash(rightWidth) ^
      const DeepCollectionEquality().hash(showInfo) ^
      const DeepCollectionEquality().hash(infoPosition) ^
      const DeepCollectionEquality().hash(border) ^
      const DeepCollectionEquality().hash(roles) ^
      runtimeType.hashCode;
}

extension $DeviceViewInfoExtension on DeviceViewInfo {
  DeviceViewInfo copyWith({
    String? modelId,
    String? name,
    List<Displayable>? top,
    List<Displayable>? bottom,
    List<Displayable>? left,
    List<Displayable>? right,
    List<Positionable>? positioned,
    String? description,
    List<String>? tags,
    int? width,
    int? height,
    int? topHeight,
    int? bottomHeight,
    int? leftWidth,
    int? rightWidth,
    bool? showInfo,
    enums.DeviceViewInfoInfoPosition? infoPosition,
    enums.DeviceViewInfoBorder? border,
    List<String>? roles,
  }) {
    return DeviceViewInfo(
      modelId: modelId ?? this.modelId,
      name: name ?? this.name,
      top: top ?? this.top,
      bottom: bottom ?? this.bottom,
      left: left ?? this.left,
      right: right ?? this.right,
      positioned: positioned ?? this.positioned,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      width: width ?? this.width,
      height: height ?? this.height,
      topHeight: topHeight ?? this.topHeight,
      bottomHeight: bottomHeight ?? this.bottomHeight,
      leftWidth: leftWidth ?? this.leftWidth,
      rightWidth: rightWidth ?? this.rightWidth,
      showInfo: showInfo ?? this.showInfo,
      infoPosition: infoPosition ?? this.infoPosition,
      border: border ?? this.border,
      roles: roles ?? this.roles,
    );
  }

  DeviceViewInfo copyWithWrapped({
    Wrapped<String>? modelId,
    Wrapped<String>? name,
    Wrapped<List<Displayable>?>? top,
    Wrapped<List<Displayable>?>? bottom,
    Wrapped<List<Displayable>?>? left,
    Wrapped<List<Displayable>?>? right,
    Wrapped<List<Positionable>?>? positioned,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<int?>? width,
    Wrapped<int?>? height,
    Wrapped<int?>? topHeight,
    Wrapped<int?>? bottomHeight,
    Wrapped<int?>? leftWidth,
    Wrapped<int?>? rightWidth,
    Wrapped<bool?>? showInfo,
    Wrapped<enums.DeviceViewInfoInfoPosition?>? infoPosition,
    Wrapped<enums.DeviceViewInfoBorder?>? border,
    Wrapped<List<String>?>? roles,
  }) {
    return DeviceViewInfo(
      modelId: (modelId != null ? modelId.value : this.modelId),
      name: (name != null ? name.value : this.name),
      top: (top != null ? top.value : this.top),
      bottom: (bottom != null ? bottom.value : this.bottom),
      left: (left != null ? left.value : this.left),
      right: (right != null ? right.value : this.right),
      positioned: (positioned != null ? positioned.value : this.positioned),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      width: (width != null ? width.value : this.width),
      height: (height != null ? height.value : this.height),
      topHeight: (topHeight != null ? topHeight.value : this.topHeight),
      bottomHeight: (bottomHeight != null
          ? bottomHeight.value
          : this.bottomHeight),
      leftWidth: (leftWidth != null ? leftWidth.value : this.leftWidth),
      rightWidth: (rightWidth != null ? rightWidth.value : this.rightWidth),
      showInfo: (showInfo != null ? showInfo.value : this.showInfo),
      infoPosition: (infoPosition != null
          ? infoPosition.value
          : this.infoPosition),
      border: (border != null ? border.value : this.border),
      roles: (roles != null ? roles.value : this.roles),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceView {
  const DeviceView({
    required this.modelId,
    required this.name,
    this.top,
    this.bottom,
    this.left,
    this.right,
    this.positioned,
    this.description,
    this.tags,
    this.width,
    this.height,
    this.topHeight,
    this.bottomHeight,
    this.leftWidth,
    this.rightWidth,
    this.showInfo,
    this.infoPosition,
    this.border,
    this.roles,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory DeviceView.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewFromJson(json);

  static const toJsonFactory = _$DeviceViewToJson;
  Map<String, dynamic> toJson() => _$DeviceViewToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'top', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? top;
  @JsonKey(name: 'bottom', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? bottom;
  @JsonKey(name: 'left', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? left;
  @JsonKey(name: 'right', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? right;
  @JsonKey(
    name: 'positioned',
    includeIfNull: false,
    defaultValue: <Positionable>[],
  )
  final List<Positionable>? positioned;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'width', includeIfNull: false)
  final int? width;
  @JsonKey(name: 'height', includeIfNull: false)
  final int? height;
  @JsonKey(name: 'topHeight', includeIfNull: false)
  final int? topHeight;
  @JsonKey(name: 'bottomHeight', includeIfNull: false)
  final int? bottomHeight;
  @JsonKey(name: 'leftWidth', includeIfNull: false)
  final int? leftWidth;
  @JsonKey(name: 'rightWidth', includeIfNull: false)
  final int? rightWidth;
  @JsonKey(name: 'showInfo', includeIfNull: false, defaultValue: true)
  final bool? showInfo;
  @JsonKey(
    name: 'infoPosition',
    includeIfNull: false,
    toJson: deviceViewInfoPositionNullableToJson,
    fromJson: deviceViewInfoPositionInfoPositionNullableFromJson,
  )
  final enums.DeviceViewInfoPosition? infoPosition;
  static enums.DeviceViewInfoPosition?
  deviceViewInfoPositionInfoPositionNullableFromJson(Object? value) =>
      deviceViewInfoPositionNullableFromJson(
        value,
        enums.DeviceViewInfoPosition.bottom,
      );

  @JsonKey(
    name: 'border',
    includeIfNull: false,
    toJson: deviceViewBorderNullableToJson,
    fromJson: deviceViewBorderBorderNullableFromJson,
  )
  final enums.DeviceViewBorder? border;
  static enums.DeviceViewBorder? deviceViewBorderBorderNullableFromJson(
    Object? value,
  ) => deviceViewBorderNullableFromJson(value, enums.DeviceViewBorder.none);

  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$DeviceViewFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceView &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.bottom, bottom) ||
                const DeepCollectionEquality().equals(other.bottom, bottom)) &&
            (identical(other.left, left) ||
                const DeepCollectionEquality().equals(other.left, left)) &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)) &&
            (identical(other.positioned, positioned) ||
                const DeepCollectionEquality().equals(
                  other.positioned,
                  positioned,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.topHeight, topHeight) ||
                const DeepCollectionEquality().equals(
                  other.topHeight,
                  topHeight,
                )) &&
            (identical(other.bottomHeight, bottomHeight) ||
                const DeepCollectionEquality().equals(
                  other.bottomHeight,
                  bottomHeight,
                )) &&
            (identical(other.leftWidth, leftWidth) ||
                const DeepCollectionEquality().equals(
                  other.leftWidth,
                  leftWidth,
                )) &&
            (identical(other.rightWidth, rightWidth) ||
                const DeepCollectionEquality().equals(
                  other.rightWidth,
                  rightWidth,
                )) &&
            (identical(other.showInfo, showInfo) ||
                const DeepCollectionEquality().equals(
                  other.showInfo,
                  showInfo,
                )) &&
            (identical(other.infoPosition, infoPosition) ||
                const DeepCollectionEquality().equals(
                  other.infoPosition,
                  infoPosition,
                )) &&
            (identical(other.border, border) ||
                const DeepCollectionEquality().equals(other.border, border)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(bottom) ^
      const DeepCollectionEquality().hash(left) ^
      const DeepCollectionEquality().hash(right) ^
      const DeepCollectionEquality().hash(positioned) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(topHeight) ^
      const DeepCollectionEquality().hash(bottomHeight) ^
      const DeepCollectionEquality().hash(leftWidth) ^
      const DeepCollectionEquality().hash(rightWidth) ^
      const DeepCollectionEquality().hash(showInfo) ^
      const DeepCollectionEquality().hash(infoPosition) ^
      const DeepCollectionEquality().hash(border) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $DeviceViewExtension on DeviceView {
  DeviceView copyWith({
    String? modelId,
    String? name,
    List<Displayable>? top,
    List<Displayable>? bottom,
    List<Displayable>? left,
    List<Displayable>? right,
    List<Positionable>? positioned,
    String? description,
    List<String>? tags,
    int? width,
    int? height,
    int? topHeight,
    int? bottomHeight,
    int? leftWidth,
    int? rightWidth,
    bool? showInfo,
    enums.DeviceViewInfoPosition? infoPosition,
    enums.DeviceViewBorder? border,
    List<String>? roles,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return DeviceView(
      modelId: modelId ?? this.modelId,
      name: name ?? this.name,
      top: top ?? this.top,
      bottom: bottom ?? this.bottom,
      left: left ?? this.left,
      right: right ?? this.right,
      positioned: positioned ?? this.positioned,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      width: width ?? this.width,
      height: height ?? this.height,
      topHeight: topHeight ?? this.topHeight,
      bottomHeight: bottomHeight ?? this.bottomHeight,
      leftWidth: leftWidth ?? this.leftWidth,
      rightWidth: rightWidth ?? this.rightWidth,
      showInfo: showInfo ?? this.showInfo,
      infoPosition: infoPosition ?? this.infoPosition,
      border: border ?? this.border,
      roles: roles ?? this.roles,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  DeviceView copyWithWrapped({
    Wrapped<String>? modelId,
    Wrapped<String>? name,
    Wrapped<List<Displayable>?>? top,
    Wrapped<List<Displayable>?>? bottom,
    Wrapped<List<Displayable>?>? left,
    Wrapped<List<Displayable>?>? right,
    Wrapped<List<Positionable>?>? positioned,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<int?>? width,
    Wrapped<int?>? height,
    Wrapped<int?>? topHeight,
    Wrapped<int?>? bottomHeight,
    Wrapped<int?>? leftWidth,
    Wrapped<int?>? rightWidth,
    Wrapped<bool?>? showInfo,
    Wrapped<enums.DeviceViewInfoPosition?>? infoPosition,
    Wrapped<enums.DeviceViewBorder?>? border,
    Wrapped<List<String>?>? roles,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return DeviceView(
      modelId: (modelId != null ? modelId.value : this.modelId),
      name: (name != null ? name.value : this.name),
      top: (top != null ? top.value : this.top),
      bottom: (bottom != null ? bottom.value : this.bottom),
      left: (left != null ? left.value : this.left),
      right: (right != null ? right.value : this.right),
      positioned: (positioned != null ? positioned.value : this.positioned),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      width: (width != null ? width.value : this.width),
      height: (height != null ? height.value : this.height),
      topHeight: (topHeight != null ? topHeight.value : this.topHeight),
      bottomHeight: (bottomHeight != null
          ? bottomHeight.value
          : this.bottomHeight),
      leftWidth: (leftWidth != null ? leftWidth.value : this.leftWidth),
      rightWidth: (rightWidth != null ? rightWidth.value : this.rightWidth),
      showInfo: (showInfo != null ? showInfo.value : this.showInfo),
      infoPosition: (infoPosition != null
          ? infoPosition.value
          : this.infoPosition),
      border: (border != null ? border.value : this.border),
      roles: (roles != null ? roles.value : this.roles),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewEntity {
  const DeviceViewEntity({this.entity});

  factory DeviceViewEntity.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewEntityFromJson(json);

  static const toJsonFactory = _$DeviceViewEntityToJson;
  Map<String, dynamic> toJson() => _$DeviceViewEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DeviceView? entity;
  static const fromJsonFactory = _$DeviceViewEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DeviceViewEntityExtension on DeviceViewEntity {
  DeviceViewEntity copyWith({DeviceView? entity}) {
    return DeviceViewEntity(entity: entity ?? this.entity);
  }

  DeviceViewEntity copyWithWrapped({Wrapped<DeviceView?>? entity}) {
    return DeviceViewEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewEntityRes {
  const DeviceViewEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DeviceViewEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewEntityResFromJson(json);

  static const toJsonFactory = _$DeviceViewEntityResToJson;
  Map<String, dynamic> toJson() => _$DeviceViewEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DeviceView? entity;
  static const fromJsonFactory = _$DeviceViewEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DeviceViewEntityResExtension on DeviceViewEntityRes {
  DeviceViewEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    DeviceView? entity,
  }) {
    return DeviceViewEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DeviceViewEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<DeviceView?>? entity,
  }) {
    return DeviceViewEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewArray {
  const DeviceViewArray({this.values});

  factory DeviceViewArray.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewArrayFromJson(json);

  static const toJsonFactory = _$DeviceViewArrayToJson;
  Map<String, dynamic> toJson() => _$DeviceViewArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceView>[])
  final List<DeviceView>? values;
  static const fromJsonFactory = _$DeviceViewArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DeviceViewArrayExtension on DeviceViewArray {
  DeviceViewArray copyWith({List<DeviceView>? values}) {
    return DeviceViewArray(values: values ?? this.values);
  }

  DeviceViewArray copyWithWrapped({Wrapped<List<DeviceView>?>? values}) {
    return DeviceViewArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewArrayRes {
  const DeviceViewArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DeviceViewArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewArrayResFromJson(json);

  static const toJsonFactory = _$DeviceViewArrayResToJson;
  Map<String, dynamic> toJson() => _$DeviceViewArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceView>[])
  final List<DeviceView>? values;
  static const fromJsonFactory = _$DeviceViewArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DeviceViewArrayResExtension on DeviceViewArrayRes {
  DeviceViewArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<DeviceView>? values,
  }) {
    return DeviceViewArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DeviceViewArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<DeviceView>?>? values,
  }) {
    return DeviceViewArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedAlarm {
  const EvaluatedAlarm({
    required this.alarmId,
    required this.state,
    required this.stateIcon,
    this.tooltip,
    this.deviceState,
  });

  factory EvaluatedAlarm.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedAlarmFromJson(json);

  static const toJsonFactory = _$EvaluatedAlarmToJson;
  Map<String, dynamic> toJson() => _$EvaluatedAlarmToJson(this);

  @JsonKey(name: 'alarmId', includeIfNull: false, defaultValue: '')
  final String alarmId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcon', includeIfNull: false, defaultValue: '')
  final String stateIcon;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'deviceState', includeIfNull: false)
  final int? deviceState;
  static const fromJsonFactory = _$EvaluatedAlarmFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedAlarm &&
            (identical(other.alarmId, alarmId) ||
                const DeepCollectionEquality().equals(
                  other.alarmId,
                  alarmId,
                )) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcon, stateIcon) ||
                const DeepCollectionEquality().equals(
                  other.stateIcon,
                  stateIcon,
                )) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(
                  other.tooltip,
                  tooltip,
                )) &&
            (identical(other.deviceState, deviceState) ||
                const DeepCollectionEquality().equals(
                  other.deviceState,
                  deviceState,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(alarmId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcon) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(deviceState) ^
      runtimeType.hashCode;
}

extension $EvaluatedAlarmExtension on EvaluatedAlarm {
  EvaluatedAlarm copyWith({
    String? alarmId,
    int? state,
    String? stateIcon,
    String? tooltip,
    int? deviceState,
  }) {
    return EvaluatedAlarm(
      alarmId: alarmId ?? this.alarmId,
      state: state ?? this.state,
      stateIcon: stateIcon ?? this.stateIcon,
      tooltip: tooltip ?? this.tooltip,
      deviceState: deviceState ?? this.deviceState,
    );
  }

  EvaluatedAlarm copyWithWrapped({
    Wrapped<String>? alarmId,
    Wrapped<int>? state,
    Wrapped<String>? stateIcon,
    Wrapped<String?>? tooltip,
    Wrapped<int?>? deviceState,
  }) {
    return EvaluatedAlarm(
      alarmId: (alarmId != null ? alarmId.value : this.alarmId),
      state: (state != null ? state.value : this.state),
      stateIcon: (stateIcon != null ? stateIcon.value : this.stateIcon),
      tooltip: (tooltip != null ? tooltip.value : this.tooltip),
      deviceState: (deviceState != null ? deviceState.value : this.deviceState),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedDisplay {
  const EvaluatedDisplay({
    required this.displayId,
    required this.prefix,
    required this.suffix,
    required this.$value,
    required this.conditionIndex,
    this.tooltip,
  });

  factory EvaluatedDisplay.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedDisplayFromJson(json);

  static const toJsonFactory = _$EvaluatedDisplayToJson;
  Map<String, dynamic> toJson() => _$EvaluatedDisplayToJson(this);

  @JsonKey(name: 'displayId', includeIfNull: false, defaultValue: '')
  final String displayId;
  @JsonKey(name: 'prefix', includeIfNull: false, defaultValue: '')
  final String prefix;
  @JsonKey(name: 'suffix', includeIfNull: false, defaultValue: '')
  final String suffix;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String $value;
  @JsonKey(name: 'conditionIndex', includeIfNull: false)
  final int conditionIndex;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  static const fromJsonFactory = _$EvaluatedDisplayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedDisplay &&
            (identical(other.displayId, displayId) ||
                const DeepCollectionEquality().equals(
                  other.displayId,
                  displayId,
                )) &&
            (identical(other.prefix, prefix) ||
                const DeepCollectionEquality().equals(other.prefix, prefix)) &&
            (identical(other.suffix, suffix) ||
                const DeepCollectionEquality().equals(other.suffix, suffix)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.conditionIndex, conditionIndex) ||
                const DeepCollectionEquality().equals(
                  other.conditionIndex,
                  conditionIndex,
                )) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(other.tooltip, tooltip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(displayId) ^
      const DeepCollectionEquality().hash(prefix) ^
      const DeepCollectionEquality().hash(suffix) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(conditionIndex) ^
      const DeepCollectionEquality().hash(tooltip) ^
      runtimeType.hashCode;
}

extension $EvaluatedDisplayExtension on EvaluatedDisplay {
  EvaluatedDisplay copyWith({
    String? displayId,
    String? prefix,
    String? suffix,
    String? $value,
    int? conditionIndex,
    String? tooltip,
  }) {
    return EvaluatedDisplay(
      displayId: displayId ?? this.displayId,
      prefix: prefix ?? this.prefix,
      suffix: suffix ?? this.suffix,
      $value: $value ?? this.$value,
      conditionIndex: conditionIndex ?? this.conditionIndex,
      tooltip: tooltip ?? this.tooltip,
    );
  }

  EvaluatedDisplay copyWithWrapped({
    Wrapped<String>? displayId,
    Wrapped<String>? prefix,
    Wrapped<String>? suffix,
    Wrapped<String>? $value,
    Wrapped<int>? conditionIndex,
    Wrapped<String?>? tooltip,
  }) {
    return EvaluatedDisplay(
      displayId: (displayId != null ? displayId.value : this.displayId),
      prefix: (prefix != null ? prefix.value : this.prefix),
      suffix: (suffix != null ? suffix.value : this.suffix),
      $value: ($value != null ? $value.value : this.$value),
      conditionIndex: (conditionIndex != null
          ? conditionIndex.value
          : this.conditionIndex),
      tooltip: (tooltip != null ? tooltip.value : this.tooltip),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedControl {
  const EvaluatedControl({
    required this.controlId,
    required this.enabled,
    required this.icon,
    required this.name,
    required this.description,
  });

  factory EvaluatedControl.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedControlFromJson(json);

  static const toJsonFactory = _$EvaluatedControlToJson;
  Map<String, dynamic> toJson() => _$EvaluatedControlToJson(this);

  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String controlId;
  @JsonKey(name: 'enabled', includeIfNull: false)
  final int enabled;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String icon;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String description;
  static const fromJsonFactory = _$EvaluatedControlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedControl &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality().equals(
                  other.controlId,
                  controlId,
                )) &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality().equals(
                  other.enabled,
                  enabled,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $EvaluatedControlExtension on EvaluatedControl {
  EvaluatedControl copyWith({
    String? controlId,
    int? enabled,
    String? icon,
    String? name,
    String? description,
  }) {
    return EvaluatedControl(
      controlId: controlId ?? this.controlId,
      enabled: enabled ?? this.enabled,
      icon: icon ?? this.icon,
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }

  EvaluatedControl copyWithWrapped({
    Wrapped<String>? controlId,
    Wrapped<int>? enabled,
    Wrapped<String>? icon,
    Wrapped<String>? name,
    Wrapped<String>? description,
  }) {
    return EvaluatedControl(
      controlId: (controlId != null ? controlId.value : this.controlId),
      enabled: (enabled != null ? enabled.value : this.enabled),
      icon: (icon != null ? icon.value : this.icon),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedEvent {
  const EvaluatedEvent({
    required this.eventId,
    required this.icon,
    required this.name,
    required this.description,
  });

  factory EvaluatedEvent.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedEventFromJson(json);

  static const toJsonFactory = _$EvaluatedEventToJson;
  Map<String, dynamic> toJson() => _$EvaluatedEventToJson(this);

  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String eventId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String icon;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String description;
  static const fromJsonFactory = _$EvaluatedEventFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedEvent &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $EvaluatedEventExtension on EvaluatedEvent {
  EvaluatedEvent copyWith({
    String? eventId,
    String? icon,
    String? name,
    String? description,
  }) {
    return EvaluatedEvent(
      eventId: eventId ?? this.eventId,
      icon: icon ?? this.icon,
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }

  EvaluatedEvent copyWithWrapped({
    Wrapped<String>? eventId,
    Wrapped<String>? icon,
    Wrapped<String>? name,
    Wrapped<String>? description,
  }) {
    return EvaluatedEvent(
      eventId: (eventId != null ? eventId.value : this.eventId),
      icon: (icon != null ? icon.value : this.icon),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredControl {
  const TriggeredControl({
    required this.id,
    required this.controlId,
    required this.modelId,
    required this.deviceId,
    required this.triggerId,
    this.triggerIcon,
    this.hardwareDeviceId,
    this.state,
    this.stateIcon,
    this.data,
    this.rtype,
    this.name,
    this.createdStamp,
    this.createdBy,
    this.updatedBy,
    this.updatedStamp,
    this.deliveryStatus,
    this.deliveryErrors,
    this.deviceIcon,
  });

  factory TriggeredControl.fromJson(Map<String, dynamic> json) =>
      _$TriggeredControlFromJson(json);

  static const toJsonFactory = _$TriggeredControlToJson;
  Map<String, dynamic> toJson() => _$TriggeredControlToJson(this);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String controlId;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'triggerId', includeIfNull: false, defaultValue: '')
  final String triggerId;
  @JsonKey(name: 'triggerIcon', includeIfNull: false, defaultValue: '')
  final String? triggerIcon;
  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String? hardwareDeviceId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int? state;
  @JsonKey(name: 'stateIcon', includeIfNull: false, defaultValue: '')
  final String? stateIcon;
  @JsonKey(name: 'data', includeIfNull: false)
  final Object? data;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String? rtype;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int? createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String? createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String? updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int? updatedStamp;
  @JsonKey(
    name: 'deliveryStatus',
    includeIfNull: false,
    toJson: triggeredControlDeliveryStatusNullableToJson,
    fromJson: triggeredControlDeliveryStatusNullableFromJson,
  )
  final enums.TriggeredControlDeliveryStatus? deliveryStatus;
  @JsonKey(
    name: 'deliveryErrors',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String>? deliveryErrors;
  @JsonKey(name: 'deviceIcon', includeIfNull: false, defaultValue: '')
  final String? deviceIcon;
  static const fromJsonFactory = _$TriggeredControlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredControl &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality().equals(
                  other.controlId,
                  controlId,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.triggerId, triggerId) ||
                const DeepCollectionEquality().equals(
                  other.triggerId,
                  triggerId,
                )) &&
            (identical(other.triggerIcon, triggerIcon) ||
                const DeepCollectionEquality().equals(
                  other.triggerIcon,
                  triggerIcon,
                )) &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality().equals(
                  other.hardwareDeviceId,
                  hardwareDeviceId,
                )) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcon, stateIcon) ||
                const DeepCollectionEquality().equals(
                  other.stateIcon,
                  stateIcon,
                )) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.deliveryStatus, deliveryStatus) ||
                const DeepCollectionEquality().equals(
                  other.deliveryStatus,
                  deliveryStatus,
                )) &&
            (identical(other.deliveryErrors, deliveryErrors) ||
                const DeepCollectionEquality().equals(
                  other.deliveryErrors,
                  deliveryErrors,
                )) &&
            (identical(other.deviceIcon, deviceIcon) ||
                const DeepCollectionEquality().equals(
                  other.deviceIcon,
                  deviceIcon,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(triggerId) ^
      const DeepCollectionEquality().hash(triggerIcon) ^
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcon) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(deliveryStatus) ^
      const DeepCollectionEquality().hash(deliveryErrors) ^
      const DeepCollectionEquality().hash(deviceIcon) ^
      runtimeType.hashCode;
}

extension $TriggeredControlExtension on TriggeredControl {
  TriggeredControl copyWith({
    String? id,
    String? controlId,
    String? modelId,
    String? deviceId,
    String? triggerId,
    String? triggerIcon,
    String? hardwareDeviceId,
    int? state,
    String? stateIcon,
    Object? data,
    String? rtype,
    String? name,
    int? createdStamp,
    String? createdBy,
    String? updatedBy,
    int? updatedStamp,
    enums.TriggeredControlDeliveryStatus? deliveryStatus,
    List<String>? deliveryErrors,
    String? deviceIcon,
  }) {
    return TriggeredControl(
      id: id ?? this.id,
      controlId: controlId ?? this.controlId,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      triggerId: triggerId ?? this.triggerId,
      triggerIcon: triggerIcon ?? this.triggerIcon,
      hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId,
      state: state ?? this.state,
      stateIcon: stateIcon ?? this.stateIcon,
      data: data ?? this.data,
      rtype: rtype ?? this.rtype,
      name: name ?? this.name,
      createdStamp: createdStamp ?? this.createdStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      deliveryStatus: deliveryStatus ?? this.deliveryStatus,
      deliveryErrors: deliveryErrors ?? this.deliveryErrors,
      deviceIcon: deviceIcon ?? this.deviceIcon,
    );
  }

  TriggeredControl copyWithWrapped({
    Wrapped<String>? id,
    Wrapped<String>? controlId,
    Wrapped<String>? modelId,
    Wrapped<String>? deviceId,
    Wrapped<String>? triggerId,
    Wrapped<String?>? triggerIcon,
    Wrapped<String?>? hardwareDeviceId,
    Wrapped<int?>? state,
    Wrapped<String?>? stateIcon,
    Wrapped<Object?>? data,
    Wrapped<String?>? rtype,
    Wrapped<String?>? name,
    Wrapped<int?>? createdStamp,
    Wrapped<String?>? createdBy,
    Wrapped<String?>? updatedBy,
    Wrapped<int?>? updatedStamp,
    Wrapped<enums.TriggeredControlDeliveryStatus?>? deliveryStatus,
    Wrapped<List<String>?>? deliveryErrors,
    Wrapped<String?>? deviceIcon,
  }) {
    return TriggeredControl(
      id: (id != null ? id.value : this.id),
      controlId: (controlId != null ? controlId.value : this.controlId),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      triggerId: (triggerId != null ? triggerId.value : this.triggerId),
      triggerIcon: (triggerIcon != null ? triggerIcon.value : this.triggerIcon),
      hardwareDeviceId: (hardwareDeviceId != null
          ? hardwareDeviceId.value
          : this.hardwareDeviceId),
      state: (state != null ? state.value : this.state),
      stateIcon: (stateIcon != null ? stateIcon.value : this.stateIcon),
      data: (data != null ? data.value : this.data),
      rtype: (rtype != null ? rtype.value : this.rtype),
      name: (name != null ? name.value : this.name),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      deliveryStatus: (deliveryStatus != null
          ? deliveryStatus.value
          : this.deliveryStatus),
      deliveryErrors: (deliveryErrors != null
          ? deliveryErrors.value
          : this.deliveryErrors),
      deviceIcon: (deviceIcon != null ? deviceIcon.value : this.deviceIcon),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedTrigger {
  const EvaluatedTrigger({required this.triggerId, this.icon});

  factory EvaluatedTrigger.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedTriggerFromJson(json);

  static const toJsonFactory = _$EvaluatedTriggerToJson;
  Map<String, dynamic> toJson() => _$EvaluatedTriggerToJson(this);

  @JsonKey(name: 'triggerId', includeIfNull: false, defaultValue: '')
  final String triggerId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  static const fromJsonFactory = _$EvaluatedTriggerFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedTrigger &&
            (identical(other.triggerId, triggerId) ||
                const DeepCollectionEquality().equals(
                  other.triggerId,
                  triggerId,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(triggerId) ^
      const DeepCollectionEquality().hash(icon) ^
      runtimeType.hashCode;
}

extension $EvaluatedTriggerExtension on EvaluatedTrigger {
  EvaluatedTrigger copyWith({String? triggerId, String? icon}) {
    return EvaluatedTrigger(
      triggerId: triggerId ?? this.triggerId,
      icon: icon ?? this.icon,
    );
  }

  EvaluatedTrigger copyWithWrapped({
    Wrapped<String>? triggerId,
    Wrapped<String?>? icon,
  }) {
    return EvaluatedTrigger(
      triggerId: (triggerId != null ? triggerId.value : this.triggerId),
      icon: (icon != null ? icon.value : this.icon),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceData {
  const DeviceData({
    required this.domainKey,
    required this.deviceId,
    this.subType,
    required this.modelId,
    required this.hardwareDeviceId,
    this.reportedStamp,
    this.processedStamp,
    required this.data,
    this.deviceName,
    this.modelName,
    this.deviceDescription,
    this.modelDescription,
    this.deviceIcon,
    this.modelIcon,
    this.rtype,
    this.name,
    this.id,
    required this.createdStamp,
    this.createdBy,
    this.updatedBy,
    required this.updatedStamp,
    this.controls,
    required this.alarms,
    required this.displays,
    required this.events,
    required this.triggers,
    this.evaluationErrors,
    this.series,
    this.trends,
    this.geolocation,
    this.geocoded,
    this.premise,
    this.facility,
    this.floor,
    this.asset,
    this.premiseId,
    this.facilityId,
    this.floorId,
    this.assetId,
    this.roles,
    this.clientId,
    this.$client,
    this.assetModel,
    this.assetModelId,
  });

  factory DeviceData.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataFromJson(json);

  static const toJsonFactory = _$DeviceDataToJson;
  Map<String, dynamic> toJson() => _$DeviceDataToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'subType', includeIfNull: false, defaultValue: '')
  final String? subType;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String hardwareDeviceId;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'processedStamp', includeIfNull: false)
  final int? processedStamp;
  @JsonKey(name: 'data', includeIfNull: false)
  final Object data;
  @JsonKey(name: 'deviceName', includeIfNull: false, defaultValue: '')
  final String? deviceName;
  @JsonKey(name: 'modelName', includeIfNull: false, defaultValue: '')
  final String? modelName;
  @JsonKey(name: 'deviceDescription', includeIfNull: false, defaultValue: '')
  final String? deviceDescription;
  @JsonKey(name: 'modelDescription', includeIfNull: false, defaultValue: '')
  final String? modelDescription;
  @JsonKey(name: 'deviceIcon', includeIfNull: false, defaultValue: '')
  final String? deviceIcon;
  @JsonKey(name: 'modelIcon', includeIfNull: false, defaultValue: '')
  final String? modelIcon;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String? rtype;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String? createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String? updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(
    name: 'controls',
    includeIfNull: false,
    defaultValue: <EvaluatedControl>[],
  )
  final List<EvaluatedControl>? controls;
  @JsonKey(
    name: 'alarms',
    includeIfNull: false,
    defaultValue: <EvaluatedAlarm>[],
  )
  final List<EvaluatedAlarm> alarms;
  @JsonKey(
    name: 'displays',
    includeIfNull: false,
    defaultValue: <EvaluatedDisplay>[],
  )
  final List<EvaluatedDisplay> displays;
  @JsonKey(
    name: 'events',
    includeIfNull: false,
    defaultValue: <EvaluatedEvent>[],
  )
  final List<EvaluatedEvent> events;
  @JsonKey(
    name: 'triggers',
    includeIfNull: false,
    defaultValue: <EvaluatedTrigger>[],
  )
  final List<EvaluatedTrigger> triggers;
  @JsonKey(
    name: 'evaluationErrors',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String>? evaluationErrors;
  @JsonKey(name: 'series', includeIfNull: false, defaultValue: <String>[])
  final List<String>? series;
  @JsonKey(name: 'trends', includeIfNull: false, defaultValue: <String>[])
  final List<String>? trends;
  @JsonKey(name: 'geolocation', includeIfNull: false)
  final GeoLocation? geolocation;
  @JsonKey(name: 'geocoded', includeIfNull: false)
  final Object? geocoded;
  @JsonKey(name: 'premise', includeIfNull: false, defaultValue: '')
  final String? premise;
  @JsonKey(name: 'facility', includeIfNull: false, defaultValue: '')
  final String? facility;
  @JsonKey(name: 'floor', includeIfNull: false, defaultValue: '')
  final String? floor;
  @JsonKey(name: 'asset', includeIfNull: false, defaultValue: '')
  final String? asset;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'client', includeIfNull: false, defaultValue: '')
  final String? $client;
  @JsonKey(name: 'assetModel', includeIfNull: false, defaultValue: '')
  final String? assetModel;
  @JsonKey(name: 'assetModelId', includeIfNull: false, defaultValue: '')
  final String? assetModelId;
  static const fromJsonFactory = _$DeviceDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceData &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.subType, subType) ||
                const DeepCollectionEquality().equals(
                  other.subType,
                  subType,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality().equals(
                  other.hardwareDeviceId,
                  hardwareDeviceId,
                )) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.processedStamp, processedStamp) ||
                const DeepCollectionEquality().equals(
                  other.processedStamp,
                  processedStamp,
                )) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.deviceName, deviceName) ||
                const DeepCollectionEquality().equals(
                  other.deviceName,
                  deviceName,
                )) &&
            (identical(other.modelName, modelName) ||
                const DeepCollectionEquality().equals(
                  other.modelName,
                  modelName,
                )) &&
            (identical(other.deviceDescription, deviceDescription) ||
                const DeepCollectionEquality().equals(
                  other.deviceDescription,
                  deviceDescription,
                )) &&
            (identical(other.modelDescription, modelDescription) ||
                const DeepCollectionEquality().equals(
                  other.modelDescription,
                  modelDescription,
                )) &&
            (identical(other.deviceIcon, deviceIcon) ||
                const DeepCollectionEquality().equals(
                  other.deviceIcon,
                  deviceIcon,
                )) &&
            (identical(other.modelIcon, modelIcon) ||
                const DeepCollectionEquality().equals(
                  other.modelIcon,
                  modelIcon,
                )) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.controls, controls) ||
                const DeepCollectionEquality().equals(
                  other.controls,
                  controls,
                )) &&
            (identical(other.alarms, alarms) ||
                const DeepCollectionEquality().equals(other.alarms, alarms)) &&
            (identical(other.displays, displays) ||
                const DeepCollectionEquality().equals(
                  other.displays,
                  displays,
                )) &&
            (identical(other.events, events) ||
                const DeepCollectionEquality().equals(other.events, events)) &&
            (identical(other.triggers, triggers) ||
                const DeepCollectionEquality().equals(
                  other.triggers,
                  triggers,
                )) &&
            (identical(other.evaluationErrors, evaluationErrors) ||
                const DeepCollectionEquality().equals(
                  other.evaluationErrors,
                  evaluationErrors,
                )) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.trends, trends) ||
                const DeepCollectionEquality().equals(other.trends, trends)) &&
            (identical(other.geolocation, geolocation) ||
                const DeepCollectionEquality().equals(
                  other.geolocation,
                  geolocation,
                )) &&
            (identical(other.geocoded, geocoded) ||
                const DeepCollectionEquality().equals(
                  other.geocoded,
                  geocoded,
                )) &&
            (identical(other.premise, premise) ||
                const DeepCollectionEquality().equals(
                  other.premise,
                  premise,
                )) &&
            (identical(other.facility, facility) ||
                const DeepCollectionEquality().equals(
                  other.facility,
                  facility,
                )) &&
            (identical(other.floor, floor) ||
                const DeepCollectionEquality().equals(other.floor, floor)) &&
            (identical(other.asset, asset) ||
                const DeepCollectionEquality().equals(other.asset, asset)) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality().equals(
                  other.floorId,
                  floorId,
                )) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality().equals(
                  other.assetId,
                  assetId,
                )) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.$client, $client) ||
                const DeepCollectionEquality().equals(
                  other.$client,
                  $client,
                )) &&
            (identical(other.assetModel, assetModel) ||
                const DeepCollectionEquality().equals(
                  other.assetModel,
                  assetModel,
                )) &&
            (identical(other.assetModelId, assetModelId) ||
                const DeepCollectionEquality().equals(
                  other.assetModelId,
                  assetModelId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(subType) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(processedStamp) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(deviceName) ^
      const DeepCollectionEquality().hash(modelName) ^
      const DeepCollectionEquality().hash(deviceDescription) ^
      const DeepCollectionEquality().hash(modelDescription) ^
      const DeepCollectionEquality().hash(deviceIcon) ^
      const DeepCollectionEquality().hash(modelIcon) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(controls) ^
      const DeepCollectionEquality().hash(alarms) ^
      const DeepCollectionEquality().hash(displays) ^
      const DeepCollectionEquality().hash(events) ^
      const DeepCollectionEquality().hash(triggers) ^
      const DeepCollectionEquality().hash(evaluationErrors) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(trends) ^
      const DeepCollectionEquality().hash(geolocation) ^
      const DeepCollectionEquality().hash(geocoded) ^
      const DeepCollectionEquality().hash(premise) ^
      const DeepCollectionEquality().hash(facility) ^
      const DeepCollectionEquality().hash(floor) ^
      const DeepCollectionEquality().hash(asset) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash($client) ^
      const DeepCollectionEquality().hash(assetModel) ^
      const DeepCollectionEquality().hash(assetModelId) ^
      runtimeType.hashCode;
}

extension $DeviceDataExtension on DeviceData {
  DeviceData copyWith({
    String? domainKey,
    String? deviceId,
    String? subType,
    String? modelId,
    String? hardwareDeviceId,
    int? reportedStamp,
    int? processedStamp,
    Object? data,
    String? deviceName,
    String? modelName,
    String? deviceDescription,
    String? modelDescription,
    String? deviceIcon,
    String? modelIcon,
    String? rtype,
    String? name,
    String? id,
    int? createdStamp,
    String? createdBy,
    String? updatedBy,
    int? updatedStamp,
    List<EvaluatedControl>? controls,
    List<EvaluatedAlarm>? alarms,
    List<EvaluatedDisplay>? displays,
    List<EvaluatedEvent>? events,
    List<EvaluatedTrigger>? triggers,
    List<String>? evaluationErrors,
    List<String>? series,
    List<String>? trends,
    GeoLocation? geolocation,
    Object? geocoded,
    String? premise,
    String? facility,
    String? floor,
    String? asset,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? assetId,
    List<String>? roles,
    String? clientId,
    String? $client,
    String? assetModel,
    String? assetModelId,
  }) {
    return DeviceData(
      domainKey: domainKey ?? this.domainKey,
      deviceId: deviceId ?? this.deviceId,
      subType: subType ?? this.subType,
      modelId: modelId ?? this.modelId,
      hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      processedStamp: processedStamp ?? this.processedStamp,
      data: data ?? this.data,
      deviceName: deviceName ?? this.deviceName,
      modelName: modelName ?? this.modelName,
      deviceDescription: deviceDescription ?? this.deviceDescription,
      modelDescription: modelDescription ?? this.modelDescription,
      deviceIcon: deviceIcon ?? this.deviceIcon,
      modelIcon: modelIcon ?? this.modelIcon,
      rtype: rtype ?? this.rtype,
      name: name ?? this.name,
      id: id ?? this.id,
      createdStamp: createdStamp ?? this.createdStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      controls: controls ?? this.controls,
      alarms: alarms ?? this.alarms,
      displays: displays ?? this.displays,
      events: events ?? this.events,
      triggers: triggers ?? this.triggers,
      evaluationErrors: evaluationErrors ?? this.evaluationErrors,
      series: series ?? this.series,
      trends: trends ?? this.trends,
      geolocation: geolocation ?? this.geolocation,
      geocoded: geocoded ?? this.geocoded,
      premise: premise ?? this.premise,
      facility: facility ?? this.facility,
      floor: floor ?? this.floor,
      asset: asset ?? this.asset,
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      floorId: floorId ?? this.floorId,
      assetId: assetId ?? this.assetId,
      roles: roles ?? this.roles,
      clientId: clientId ?? this.clientId,
      $client: $client ?? this.$client,
      assetModel: assetModel ?? this.assetModel,
      assetModelId: assetModelId ?? this.assetModelId,
    );
  }

  DeviceData copyWithWrapped({
    Wrapped<String>? domainKey,
    Wrapped<String>? deviceId,
    Wrapped<String?>? subType,
    Wrapped<String>? modelId,
    Wrapped<String>? hardwareDeviceId,
    Wrapped<int?>? reportedStamp,
    Wrapped<int?>? processedStamp,
    Wrapped<Object>? data,
    Wrapped<String?>? deviceName,
    Wrapped<String?>? modelName,
    Wrapped<String?>? deviceDescription,
    Wrapped<String?>? modelDescription,
    Wrapped<String?>? deviceIcon,
    Wrapped<String?>? modelIcon,
    Wrapped<String?>? rtype,
    Wrapped<String?>? name,
    Wrapped<String?>? id,
    Wrapped<int>? createdStamp,
    Wrapped<String?>? createdBy,
    Wrapped<String?>? updatedBy,
    Wrapped<int>? updatedStamp,
    Wrapped<List<EvaluatedControl>?>? controls,
    Wrapped<List<EvaluatedAlarm>>? alarms,
    Wrapped<List<EvaluatedDisplay>>? displays,
    Wrapped<List<EvaluatedEvent>>? events,
    Wrapped<List<EvaluatedTrigger>>? triggers,
    Wrapped<List<String>?>? evaluationErrors,
    Wrapped<List<String>?>? series,
    Wrapped<List<String>?>? trends,
    Wrapped<GeoLocation?>? geolocation,
    Wrapped<Object?>? geocoded,
    Wrapped<String?>? premise,
    Wrapped<String?>? facility,
    Wrapped<String?>? floor,
    Wrapped<String?>? asset,
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String?>? floorId,
    Wrapped<String?>? assetId,
    Wrapped<List<String>?>? roles,
    Wrapped<String?>? clientId,
    Wrapped<String?>? $client,
    Wrapped<String?>? assetModel,
    Wrapped<String?>? assetModelId,
  }) {
    return DeviceData(
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      subType: (subType != null ? subType.value : this.subType),
      modelId: (modelId != null ? modelId.value : this.modelId),
      hardwareDeviceId: (hardwareDeviceId != null
          ? hardwareDeviceId.value
          : this.hardwareDeviceId),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      processedStamp: (processedStamp != null
          ? processedStamp.value
          : this.processedStamp),
      data: (data != null ? data.value : this.data),
      deviceName: (deviceName != null ? deviceName.value : this.deviceName),
      modelName: (modelName != null ? modelName.value : this.modelName),
      deviceDescription: (deviceDescription != null
          ? deviceDescription.value
          : this.deviceDescription),
      modelDescription: (modelDescription != null
          ? modelDescription.value
          : this.modelDescription),
      deviceIcon: (deviceIcon != null ? deviceIcon.value : this.deviceIcon),
      modelIcon: (modelIcon != null ? modelIcon.value : this.modelIcon),
      rtype: (rtype != null ? rtype.value : this.rtype),
      name: (name != null ? name.value : this.name),
      id: (id != null ? id.value : this.id),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      controls: (controls != null ? controls.value : this.controls),
      alarms: (alarms != null ? alarms.value : this.alarms),
      displays: (displays != null ? displays.value : this.displays),
      events: (events != null ? events.value : this.events),
      triggers: (triggers != null ? triggers.value : this.triggers),
      evaluationErrors: (evaluationErrors != null
          ? evaluationErrors.value
          : this.evaluationErrors),
      series: (series != null ? series.value : this.series),
      trends: (trends != null ? trends.value : this.trends),
      geolocation: (geolocation != null ? geolocation.value : this.geolocation),
      geocoded: (geocoded != null ? geocoded.value : this.geocoded),
      premise: (premise != null ? premise.value : this.premise),
      facility: (facility != null ? facility.value : this.facility),
      floor: (floor != null ? floor.value : this.floor),
      asset: (asset != null ? asset.value : this.asset),
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      floorId: (floorId != null ? floorId.value : this.floorId),
      assetId: (assetId != null ? assetId.value : this.assetId),
      roles: (roles != null ? roles.value : this.roles),
      clientId: (clientId != null ? clientId.value : this.clientId),
      $client: ($client != null ? $client.value : this.$client),
      assetModel: (assetModel != null ? assetModel.value : this.assetModel),
      assetModelId: (assetModelId != null
          ? assetModelId.value
          : this.assetModelId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDataArray {
  const DeviceDataArray({this.values});

  factory DeviceDataArray.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataArrayFromJson(json);

  static const toJsonFactory = _$DeviceDataArrayToJson;
  Map<String, dynamic> toJson() => _$DeviceDataArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceData>[])
  final List<DeviceData>? values;
  static const fromJsonFactory = _$DeviceDataArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDataArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DeviceDataArrayExtension on DeviceDataArray {
  DeviceDataArray copyWith({List<DeviceData>? values}) {
    return DeviceDataArray(values: values ?? this.values);
  }

  DeviceDataArray copyWithWrapped({Wrapped<List<DeviceData>?>? values}) {
    return DeviceDataArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDataArrayRes {
  const DeviceDataArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DeviceDataArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataArrayResFromJson(json);

  static const toJsonFactory = _$DeviceDataArrayResToJson;
  Map<String, dynamic> toJson() => _$DeviceDataArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceData>[])
  final List<DeviceData>? values;
  static const fromJsonFactory = _$DeviceDataArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDataArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DeviceDataArrayResExtension on DeviceDataArrayRes {
  DeviceDataArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<DeviceData>? values,
  }) {
    return DeviceDataArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DeviceDataArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<DeviceData>?>? values,
  }) {
    return DeviceDataArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenu {
  const DashboardMenu({
    required this.displayName,
    this.icon,
    required this.webSupported,
    required this.tabletSupported,
    required this.mobileSupported,
    required this.screenId,
  });

  factory DashboardMenu.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuFromJson(json);

  static const toJsonFactory = _$DashboardMenuToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuToJson(this);

  @JsonKey(name: 'displayName', includeIfNull: false, defaultValue: '')
  final String displayName;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'webSupported', includeIfNull: false, defaultValue: true)
  final bool webSupported;
  @JsonKey(name: 'tabletSupported', includeIfNull: false, defaultValue: true)
  final bool tabletSupported;
  @JsonKey(name: 'mobileSupported', includeIfNull: false, defaultValue: true)
  final bool mobileSupported;
  @JsonKey(name: 'screenId', includeIfNull: false, defaultValue: '')
  final String screenId;
  static const fromJsonFactory = _$DashboardMenuFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenu &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality().equals(
                  other.displayName,
                  displayName,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.webSupported, webSupported) ||
                const DeepCollectionEquality().equals(
                  other.webSupported,
                  webSupported,
                )) &&
            (identical(other.tabletSupported, tabletSupported) ||
                const DeepCollectionEquality().equals(
                  other.tabletSupported,
                  tabletSupported,
                )) &&
            (identical(other.mobileSupported, mobileSupported) ||
                const DeepCollectionEquality().equals(
                  other.mobileSupported,
                  mobileSupported,
                )) &&
            (identical(other.screenId, screenId) ||
                const DeepCollectionEquality().equals(
                  other.screenId,
                  screenId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(webSupported) ^
      const DeepCollectionEquality().hash(tabletSupported) ^
      const DeepCollectionEquality().hash(mobileSupported) ^
      const DeepCollectionEquality().hash(screenId) ^
      runtimeType.hashCode;
}

extension $DashboardMenuExtension on DashboardMenu {
  DashboardMenu copyWith({
    String? displayName,
    String? icon,
    bool? webSupported,
    bool? tabletSupported,
    bool? mobileSupported,
    String? screenId,
  }) {
    return DashboardMenu(
      displayName: displayName ?? this.displayName,
      icon: icon ?? this.icon,
      webSupported: webSupported ?? this.webSupported,
      tabletSupported: tabletSupported ?? this.tabletSupported,
      mobileSupported: mobileSupported ?? this.mobileSupported,
      screenId: screenId ?? this.screenId,
    );
  }

  DashboardMenu copyWithWrapped({
    Wrapped<String>? displayName,
    Wrapped<String?>? icon,
    Wrapped<bool>? webSupported,
    Wrapped<bool>? tabletSupported,
    Wrapped<bool>? mobileSupported,
    Wrapped<String>? screenId,
  }) {
    return DashboardMenu(
      displayName: (displayName != null ? displayName.value : this.displayName),
      icon: (icon != null ? icon.value : this.icon),
      webSupported: (webSupported != null
          ? webSupported.value
          : this.webSupported),
      tabletSupported: (tabletSupported != null
          ? tabletSupported.value
          : this.tabletSupported),
      mobileSupported: (mobileSupported != null
          ? mobileSupported.value
          : this.mobileSupported),
      screenId: (screenId != null ? screenId.value : this.screenId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupInfo {
  const DashboardMenuGroupInfo({
    required this.name,
    required this.displayName,
    this.description,
    this.icon,
    this.order,
    required this.webSupported,
    required this.tabletSupported,
    required this.mobileSupported,
    this.tags,
    this.roles,
    required this.menus,
  });

  factory DashboardMenuGroupInfo.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupInfoFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupInfoToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'displayName', includeIfNull: false, defaultValue: '')
  final String displayName;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'webSupported', includeIfNull: false, defaultValue: true)
  final bool webSupported;
  @JsonKey(name: 'tabletSupported', includeIfNull: false, defaultValue: true)
  final bool tabletSupported;
  @JsonKey(name: 'mobileSupported', includeIfNull: false, defaultValue: true)
  final bool mobileSupported;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'menus', includeIfNull: false, defaultValue: <DashboardMenu>[])
  final List<DashboardMenu> menus;
  static const fromJsonFactory = _$DashboardMenuGroupInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality().equals(
                  other.displayName,
                  displayName,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.webSupported, webSupported) ||
                const DeepCollectionEquality().equals(
                  other.webSupported,
                  webSupported,
                )) &&
            (identical(other.tabletSupported, tabletSupported) ||
                const DeepCollectionEquality().equals(
                  other.tabletSupported,
                  tabletSupported,
                )) &&
            (identical(other.mobileSupported, mobileSupported) ||
                const DeepCollectionEquality().equals(
                  other.mobileSupported,
                  mobileSupported,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.menus, menus) ||
                const DeepCollectionEquality().equals(other.menus, menus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(webSupported) ^
      const DeepCollectionEquality().hash(tabletSupported) ^
      const DeepCollectionEquality().hash(mobileSupported) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(menus) ^
      runtimeType.hashCode;
}

extension $DashboardMenuGroupInfoExtension on DashboardMenuGroupInfo {
  DashboardMenuGroupInfo copyWith({
    String? name,
    String? displayName,
    String? description,
    String? icon,
    int? order,
    bool? webSupported,
    bool? tabletSupported,
    bool? mobileSupported,
    List<String>? tags,
    List<String>? roles,
    List<DashboardMenu>? menus,
  }) {
    return DashboardMenuGroupInfo(
      name: name ?? this.name,
      displayName: displayName ?? this.displayName,
      description: description ?? this.description,
      icon: icon ?? this.icon,
      order: order ?? this.order,
      webSupported: webSupported ?? this.webSupported,
      tabletSupported: tabletSupported ?? this.tabletSupported,
      mobileSupported: mobileSupported ?? this.mobileSupported,
      tags: tags ?? this.tags,
      roles: roles ?? this.roles,
      menus: menus ?? this.menus,
    );
  }

  DashboardMenuGroupInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? displayName,
    Wrapped<String?>? description,
    Wrapped<String?>? icon,
    Wrapped<int?>? order,
    Wrapped<bool>? webSupported,
    Wrapped<bool>? tabletSupported,
    Wrapped<bool>? mobileSupported,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? roles,
    Wrapped<List<DashboardMenu>>? menus,
  }) {
    return DashboardMenuGroupInfo(
      name: (name != null ? name.value : this.name),
      displayName: (displayName != null ? displayName.value : this.displayName),
      description: (description != null ? description.value : this.description),
      icon: (icon != null ? icon.value : this.icon),
      order: (order != null ? order.value : this.order),
      webSupported: (webSupported != null
          ? webSupported.value
          : this.webSupported),
      tabletSupported: (tabletSupported != null
          ? tabletSupported.value
          : this.tabletSupported),
      mobileSupported: (mobileSupported != null
          ? mobileSupported.value
          : this.mobileSupported),
      tags: (tags != null ? tags.value : this.tags),
      roles: (roles != null ? roles.value : this.roles),
      menus: (menus != null ? menus.value : this.menus),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroup {
  const DashboardMenuGroup({
    required this.name,
    required this.displayName,
    this.description,
    this.icon,
    this.order,
    required this.webSupported,
    required this.tabletSupported,
    required this.mobileSupported,
    this.tags,
    this.roles,
    required this.menus,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory DashboardMenuGroup.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'displayName', includeIfNull: false, defaultValue: '')
  final String displayName;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'webSupported', includeIfNull: false, defaultValue: true)
  final bool webSupported;
  @JsonKey(name: 'tabletSupported', includeIfNull: false, defaultValue: true)
  final bool tabletSupported;
  @JsonKey(name: 'mobileSupported', includeIfNull: false, defaultValue: true)
  final bool mobileSupported;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'menus', includeIfNull: false, defaultValue: <DashboardMenu>[])
  final List<DashboardMenu> menus;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$DashboardMenuGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroup &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality().equals(
                  other.displayName,
                  displayName,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.webSupported, webSupported) ||
                const DeepCollectionEquality().equals(
                  other.webSupported,
                  webSupported,
                )) &&
            (identical(other.tabletSupported, tabletSupported) ||
                const DeepCollectionEquality().equals(
                  other.tabletSupported,
                  tabletSupported,
                )) &&
            (identical(other.mobileSupported, mobileSupported) ||
                const DeepCollectionEquality().equals(
                  other.mobileSupported,
                  mobileSupported,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.menus, menus) ||
                const DeepCollectionEquality().equals(other.menus, menus)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(webSupported) ^
      const DeepCollectionEquality().hash(tabletSupported) ^
      const DeepCollectionEquality().hash(mobileSupported) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(menus) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $DashboardMenuGroupExtension on DashboardMenuGroup {
  DashboardMenuGroup copyWith({
    String? name,
    String? displayName,
    String? description,
    String? icon,
    int? order,
    bool? webSupported,
    bool? tabletSupported,
    bool? mobileSupported,
    List<String>? tags,
    List<String>? roles,
    List<DashboardMenu>? menus,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return DashboardMenuGroup(
      name: name ?? this.name,
      displayName: displayName ?? this.displayName,
      description: description ?? this.description,
      icon: icon ?? this.icon,
      order: order ?? this.order,
      webSupported: webSupported ?? this.webSupported,
      tabletSupported: tabletSupported ?? this.tabletSupported,
      mobileSupported: mobileSupported ?? this.mobileSupported,
      tags: tags ?? this.tags,
      roles: roles ?? this.roles,
      menus: menus ?? this.menus,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  DashboardMenuGroup copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? displayName,
    Wrapped<String?>? description,
    Wrapped<String?>? icon,
    Wrapped<int?>? order,
    Wrapped<bool>? webSupported,
    Wrapped<bool>? tabletSupported,
    Wrapped<bool>? mobileSupported,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? roles,
    Wrapped<List<DashboardMenu>>? menus,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return DashboardMenuGroup(
      name: (name != null ? name.value : this.name),
      displayName: (displayName != null ? displayName.value : this.displayName),
      description: (description != null ? description.value : this.description),
      icon: (icon != null ? icon.value : this.icon),
      order: (order != null ? order.value : this.order),
      webSupported: (webSupported != null
          ? webSupported.value
          : this.webSupported),
      tabletSupported: (tabletSupported != null
          ? tabletSupported.value
          : this.tabletSupported),
      mobileSupported: (mobileSupported != null
          ? mobileSupported.value
          : this.mobileSupported),
      tags: (tags != null ? tags.value : this.tags),
      roles: (roles != null ? roles.value : this.roles),
      menus: (menus != null ? menus.value : this.menus),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupEntity {
  const DashboardMenuGroupEntity({this.entity});

  factory DashboardMenuGroupEntity.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupEntityFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupEntityToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DashboardMenuGroup? entity;
  static const fromJsonFactory = _$DashboardMenuGroupEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DashboardMenuGroupEntityExtension on DashboardMenuGroupEntity {
  DashboardMenuGroupEntity copyWith({DashboardMenuGroup? entity}) {
    return DashboardMenuGroupEntity(entity: entity ?? this.entity);
  }

  DashboardMenuGroupEntity copyWithWrapped({
    Wrapped<DashboardMenuGroup?>? entity,
  }) {
    return DashboardMenuGroupEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupEntityRes {
  const DashboardMenuGroupEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DashboardMenuGroupEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupEntityResFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupEntityResToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DashboardMenuGroup? entity;
  static const fromJsonFactory = _$DashboardMenuGroupEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DashboardMenuGroupEntityResExtension on DashboardMenuGroupEntityRes {
  DashboardMenuGroupEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    DashboardMenuGroup? entity,
  }) {
    return DashboardMenuGroupEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DashboardMenuGroupEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<DashboardMenuGroup?>? entity,
  }) {
    return DashboardMenuGroupEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupArray {
  const DashboardMenuGroupArray({this.values});

  factory DashboardMenuGroupArray.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupArrayFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupArrayToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <DashboardMenuGroup>[],
  )
  final List<DashboardMenuGroup>? values;
  static const fromJsonFactory = _$DashboardMenuGroupArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DashboardMenuGroupArrayExtension on DashboardMenuGroupArray {
  DashboardMenuGroupArray copyWith({List<DashboardMenuGroup>? values}) {
    return DashboardMenuGroupArray(values: values ?? this.values);
  }

  DashboardMenuGroupArray copyWithWrapped({
    Wrapped<List<DashboardMenuGroup>?>? values,
  }) {
    return DashboardMenuGroupArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupArrayRes {
  const DashboardMenuGroupArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DashboardMenuGroupArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupArrayResFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupArrayResToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <DashboardMenuGroup>[],
  )
  final List<DashboardMenuGroup>? values;
  static const fromJsonFactory = _$DashboardMenuGroupArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DashboardMenuGroupArrayResExtension on DashboardMenuGroupArrayRes {
  DashboardMenuGroupArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<DashboardMenuGroup>? values,
  }) {
    return DashboardMenuGroupArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DashboardMenuGroupArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<DashboardMenuGroup>?>? values,
  }) {
    return DashboardMenuGroupArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PaddingConfig {
  const PaddingConfig({this.left, this.top, this.right, this.bottom});

  factory PaddingConfig.fromJson(Map<String, dynamic> json) =>
      _$PaddingConfigFromJson(json);

  static const toJsonFactory = _$PaddingConfigToJson;
  Map<String, dynamic> toJson() => _$PaddingConfigToJson(this);

  @JsonKey(name: 'left', includeIfNull: false)
  final double? left;
  @JsonKey(name: 'top', includeIfNull: false)
  final double? top;
  @JsonKey(name: 'right', includeIfNull: false)
  final double? right;
  @JsonKey(name: 'bottom', includeIfNull: false)
  final double? bottom;
  static const fromJsonFactory = _$PaddingConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PaddingConfig &&
            (identical(other.left, left) ||
                const DeepCollectionEquality().equals(other.left, left)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)) &&
            (identical(other.bottom, bottom) ||
                const DeepCollectionEquality().equals(other.bottom, bottom)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(left) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(right) ^
      const DeepCollectionEquality().hash(bottom) ^
      runtimeType.hashCode;
}

extension $PaddingConfigExtension on PaddingConfig {
  PaddingConfig copyWith({
    double? left,
    double? top,
    double? right,
    double? bottom,
  }) {
    return PaddingConfig(
      left: left ?? this.left,
      top: top ?? this.top,
      right: right ?? this.right,
      bottom: bottom ?? this.bottom,
    );
  }

  PaddingConfig copyWithWrapped({
    Wrapped<double?>? left,
    Wrapped<double?>? top,
    Wrapped<double?>? right,
    Wrapped<double?>? bottom,
  }) {
    return PaddingConfig(
      left: (left != null ? left.value : this.left),
      top: (top != null ? top.value : this.top),
      right: (right != null ? right.value : this.right),
      bottom: (bottom != null ? bottom.value : this.bottom),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RadiusConfig {
  const RadiusConfig({required this.radType, this.rad, this.xRad, this.yRad});

  factory RadiusConfig.fromJson(Map<String, dynamic> json) =>
      _$RadiusConfigFromJson(json);

  static const toJsonFactory = _$RadiusConfigToJson;
  Map<String, dynamic> toJson() => _$RadiusConfigToJson(this);

  @JsonKey(
    name: 'radType',
    includeIfNull: false,
    toJson: radiusConfigRadTypeToJson,
    fromJson: radiusConfigRadTypeFromJson,
  )
  final enums.RadiusConfigRadType radType;
  @JsonKey(name: 'rad', includeIfNull: false)
  final double? rad;
  @JsonKey(name: 'xRad', includeIfNull: false)
  final double? xRad;
  @JsonKey(name: 'yRad', includeIfNull: false)
  final double? yRad;
  static const fromJsonFactory = _$RadiusConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RadiusConfig &&
            (identical(other.radType, radType) ||
                const DeepCollectionEquality().equals(
                  other.radType,
                  radType,
                )) &&
            (identical(other.rad, rad) ||
                const DeepCollectionEquality().equals(other.rad, rad)) &&
            (identical(other.xRad, xRad) ||
                const DeepCollectionEquality().equals(other.xRad, xRad)) &&
            (identical(other.yRad, yRad) ||
                const DeepCollectionEquality().equals(other.yRad, yRad)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(radType) ^
      const DeepCollectionEquality().hash(rad) ^
      const DeepCollectionEquality().hash(xRad) ^
      const DeepCollectionEquality().hash(yRad) ^
      runtimeType.hashCode;
}

extension $RadiusConfigExtension on RadiusConfig {
  RadiusConfig copyWith({
    enums.RadiusConfigRadType? radType,
    double? rad,
    double? xRad,
    double? yRad,
  }) {
    return RadiusConfig(
      radType: radType ?? this.radType,
      rad: rad ?? this.rad,
      xRad: xRad ?? this.xRad,
      yRad: yRad ?? this.yRad,
    );
  }

  RadiusConfig copyWithWrapped({
    Wrapped<enums.RadiusConfigRadType>? radType,
    Wrapped<double?>? rad,
    Wrapped<double?>? xRad,
    Wrapped<double?>? yRad,
  }) {
    return RadiusConfig(
      radType: (radType != null ? radType.value : this.radType),
      rad: (rad != null ? rad.value : this.rad),
      xRad: (xRad != null ? xRad.value : this.xRad),
      yRad: (yRad != null ? yRad.value : this.yRad),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFitConfig {
  const ImageFitConfig({required this.fit});

  factory ImageFitConfig.fromJson(Map<String, dynamic> json) =>
      _$ImageFitConfigFromJson(json);

  static const toJsonFactory = _$ImageFitConfigToJson;
  Map<String, dynamic> toJson() => _$ImageFitConfigToJson(this);

  @JsonKey(
    name: 'fit',
    includeIfNull: false,
    toJson: imageFitConfigFitToJson,
    fromJson: imageFitConfigFitFromJson,
  )
  final enums.ImageFitConfigFit fit;
  static const fromJsonFactory = _$ImageFitConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFitConfig &&
            (identical(other.fit, fit) ||
                const DeepCollectionEquality().equals(other.fit, fit)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fit) ^ runtimeType.hashCode;
}

extension $ImageFitConfigExtension on ImageFitConfig {
  ImageFitConfig copyWith({enums.ImageFitConfigFit? fit}) {
    return ImageFitConfig(fit: fit ?? this.fit);
  }

  ImageFitConfig copyWithWrapped({Wrapped<enums.ImageFitConfigFit>? fit}) {
    return ImageFitConfig(fit: (fit != null ? fit.value : this.fit));
  }
}

@JsonSerializable(explicitToJson: true)
class AlignmentConfig {
  const AlignmentConfig({required this.alignment});

  factory AlignmentConfig.fromJson(Map<String, dynamic> json) =>
      _$AlignmentConfigFromJson(json);

  static const toJsonFactory = _$AlignmentConfigToJson;
  Map<String, dynamic> toJson() => _$AlignmentConfigToJson(this);

  @JsonKey(
    name: 'alignment',
    includeIfNull: false,
    toJson: alignmentConfigAlignmentToJson,
    fromJson: alignmentConfigAlignmentFromJson,
  )
  final enums.AlignmentConfigAlignment alignment;
  static const fromJsonFactory = _$AlignmentConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlignmentConfig &&
            (identical(other.alignment, alignment) ||
                const DeepCollectionEquality().equals(
                  other.alignment,
                  alignment,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(alignment) ^ runtimeType.hashCode;
}

extension $AlignmentConfigExtension on AlignmentConfig {
  AlignmentConfig copyWith({enums.AlignmentConfigAlignment? alignment}) {
    return AlignmentConfig(alignment: alignment ?? this.alignment);
  }

  AlignmentConfig copyWithWrapped({
    Wrapped<enums.AlignmentConfigAlignment>? alignment,
  }) {
    return AlignmentConfig(
      alignment: (alignment != null ? alignment.value : this.alignment),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BorderConfig {
  const BorderConfig({
    required this.type,
    this.color,
    this.width,
    this.allRadius,
    this.leftRadius,
    this.rightRadius,
    this.topRadius,
    this.bottomRadius,
    this.topLeftRadius,
    this.bottomLeftRadius,
    this.topRightRadius,
    this.bottomRightRadius,
    this.circularRadius,
  });

  factory BorderConfig.fromJson(Map<String, dynamic> json) =>
      _$BorderConfigFromJson(json);

  static const toJsonFactory = _$BorderConfigToJson;
  Map<String, dynamic> toJson() => _$BorderConfigToJson(this);

  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: borderConfigTypeToJson,
    fromJson: borderConfigTypeFromJson,
  )
  final enums.BorderConfigType type;
  @JsonKey(name: 'color', includeIfNull: false)
  final int? color;
  @JsonKey(name: 'width', includeIfNull: false)
  final double? width;
  @JsonKey(name: 'allRadius', includeIfNull: false)
  final RadiusConfig? allRadius;
  @JsonKey(name: 'leftRadius', includeIfNull: false)
  final RadiusConfig? leftRadius;
  @JsonKey(name: 'rightRadius', includeIfNull: false)
  final RadiusConfig? rightRadius;
  @JsonKey(name: 'topRadius', includeIfNull: false)
  final RadiusConfig? topRadius;
  @JsonKey(name: 'bottomRadius', includeIfNull: false)
  final RadiusConfig? bottomRadius;
  @JsonKey(name: 'topLeftRadius', includeIfNull: false)
  final RadiusConfig? topLeftRadius;
  @JsonKey(name: 'bottomLeftRadius', includeIfNull: false)
  final RadiusConfig? bottomLeftRadius;
  @JsonKey(name: 'topRightRadius', includeIfNull: false)
  final RadiusConfig? topRightRadius;
  @JsonKey(name: 'bottomRightRadius', includeIfNull: false)
  final RadiusConfig? bottomRightRadius;
  @JsonKey(name: 'circularRadius', includeIfNull: false)
  final double? circularRadius;
  static const fromJsonFactory = _$BorderConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BorderConfig &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.color, color) ||
                const DeepCollectionEquality().equals(other.color, color)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.allRadius, allRadius) ||
                const DeepCollectionEquality().equals(
                  other.allRadius,
                  allRadius,
                )) &&
            (identical(other.leftRadius, leftRadius) ||
                const DeepCollectionEquality().equals(
                  other.leftRadius,
                  leftRadius,
                )) &&
            (identical(other.rightRadius, rightRadius) ||
                const DeepCollectionEquality().equals(
                  other.rightRadius,
                  rightRadius,
                )) &&
            (identical(other.topRadius, topRadius) ||
                const DeepCollectionEquality().equals(
                  other.topRadius,
                  topRadius,
                )) &&
            (identical(other.bottomRadius, bottomRadius) ||
                const DeepCollectionEquality().equals(
                  other.bottomRadius,
                  bottomRadius,
                )) &&
            (identical(other.topLeftRadius, topLeftRadius) ||
                const DeepCollectionEquality().equals(
                  other.topLeftRadius,
                  topLeftRadius,
                )) &&
            (identical(other.bottomLeftRadius, bottomLeftRadius) ||
                const DeepCollectionEquality().equals(
                  other.bottomLeftRadius,
                  bottomLeftRadius,
                )) &&
            (identical(other.topRightRadius, topRightRadius) ||
                const DeepCollectionEquality().equals(
                  other.topRightRadius,
                  topRightRadius,
                )) &&
            (identical(other.bottomRightRadius, bottomRightRadius) ||
                const DeepCollectionEquality().equals(
                  other.bottomRightRadius,
                  bottomRightRadius,
                )) &&
            (identical(other.circularRadius, circularRadius) ||
                const DeepCollectionEquality().equals(
                  other.circularRadius,
                  circularRadius,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(color) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(allRadius) ^
      const DeepCollectionEquality().hash(leftRadius) ^
      const DeepCollectionEquality().hash(rightRadius) ^
      const DeepCollectionEquality().hash(topRadius) ^
      const DeepCollectionEquality().hash(bottomRadius) ^
      const DeepCollectionEquality().hash(topLeftRadius) ^
      const DeepCollectionEquality().hash(bottomLeftRadius) ^
      const DeepCollectionEquality().hash(topRightRadius) ^
      const DeepCollectionEquality().hash(bottomRightRadius) ^
      const DeepCollectionEquality().hash(circularRadius) ^
      runtimeType.hashCode;
}

extension $BorderConfigExtension on BorderConfig {
  BorderConfig copyWith({
    enums.BorderConfigType? type,
    int? color,
    double? width,
    RadiusConfig? allRadius,
    RadiusConfig? leftRadius,
    RadiusConfig? rightRadius,
    RadiusConfig? topRadius,
    RadiusConfig? bottomRadius,
    RadiusConfig? topLeftRadius,
    RadiusConfig? bottomLeftRadius,
    RadiusConfig? topRightRadius,
    RadiusConfig? bottomRightRadius,
    double? circularRadius,
  }) {
    return BorderConfig(
      type: type ?? this.type,
      color: color ?? this.color,
      width: width ?? this.width,
      allRadius: allRadius ?? this.allRadius,
      leftRadius: leftRadius ?? this.leftRadius,
      rightRadius: rightRadius ?? this.rightRadius,
      topRadius: topRadius ?? this.topRadius,
      bottomRadius: bottomRadius ?? this.bottomRadius,
      topLeftRadius: topLeftRadius ?? this.topLeftRadius,
      bottomLeftRadius: bottomLeftRadius ?? this.bottomLeftRadius,
      topRightRadius: topRightRadius ?? this.topRightRadius,
      bottomRightRadius: bottomRightRadius ?? this.bottomRightRadius,
      circularRadius: circularRadius ?? this.circularRadius,
    );
  }

  BorderConfig copyWithWrapped({
    Wrapped<enums.BorderConfigType>? type,
    Wrapped<int?>? color,
    Wrapped<double?>? width,
    Wrapped<RadiusConfig?>? allRadius,
    Wrapped<RadiusConfig?>? leftRadius,
    Wrapped<RadiusConfig?>? rightRadius,
    Wrapped<RadiusConfig?>? topRadius,
    Wrapped<RadiusConfig?>? bottomRadius,
    Wrapped<RadiusConfig?>? topLeftRadius,
    Wrapped<RadiusConfig?>? bottomLeftRadius,
    Wrapped<RadiusConfig?>? topRightRadius,
    Wrapped<RadiusConfig?>? bottomRightRadius,
    Wrapped<double?>? circularRadius,
  }) {
    return BorderConfig(
      type: (type != null ? type.value : this.type),
      color: (color != null ? color.value : this.color),
      width: (width != null ? width.value : this.width),
      allRadius: (allRadius != null ? allRadius.value : this.allRadius),
      leftRadius: (leftRadius != null ? leftRadius.value : this.leftRadius),
      rightRadius: (rightRadius != null ? rightRadius.value : this.rightRadius),
      topRadius: (topRadius != null ? topRadius.value : this.topRadius),
      bottomRadius: (bottomRadius != null
          ? bottomRadius.value
          : this.bottomRadius),
      topLeftRadius: (topLeftRadius != null
          ? topLeftRadius.value
          : this.topLeftRadius),
      bottomLeftRadius: (bottomLeftRadius != null
          ? bottomLeftRadius.value
          : this.bottomLeftRadius),
      topRightRadius: (topRightRadius != null
          ? topRightRadius.value
          : this.topRightRadius),
      bottomRightRadius: (bottomRightRadius != null
          ? bottomRightRadius.value
          : this.bottomRightRadius),
      circularRadius: (circularRadius != null
          ? circularRadius.value
          : this.circularRadius),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinFontConfig {
  const TwinFontConfig({
    this.fontFamily,
    this.fontColor,
    this.fontSize,
    this.fontBold,
  });

  factory TwinFontConfig.fromJson(Map<String, dynamic> json) =>
      _$TwinFontConfigFromJson(json);

  static const toJsonFactory = _$TwinFontConfigToJson;
  Map<String, dynamic> toJson() => _$TwinFontConfigToJson(this);

  @JsonKey(name: 'fontFamily', includeIfNull: false, defaultValue: '')
  final String? fontFamily;
  @JsonKey(name: 'fontColor', includeIfNull: false)
  final int? fontColor;
  @JsonKey(name: 'fontSize', includeIfNull: false)
  final double? fontSize;
  @JsonKey(name: 'fontBold', includeIfNull: false)
  final bool? fontBold;
  static const fromJsonFactory = _$TwinFontConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinFontConfig &&
            (identical(other.fontFamily, fontFamily) ||
                const DeepCollectionEquality().equals(
                  other.fontFamily,
                  fontFamily,
                )) &&
            (identical(other.fontColor, fontColor) ||
                const DeepCollectionEquality().equals(
                  other.fontColor,
                  fontColor,
                )) &&
            (identical(other.fontSize, fontSize) ||
                const DeepCollectionEquality().equals(
                  other.fontSize,
                  fontSize,
                )) &&
            (identical(other.fontBold, fontBold) ||
                const DeepCollectionEquality().equals(
                  other.fontBold,
                  fontBold,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fontFamily) ^
      const DeepCollectionEquality().hash(fontColor) ^
      const DeepCollectionEquality().hash(fontSize) ^
      const DeepCollectionEquality().hash(fontBold) ^
      runtimeType.hashCode;
}

extension $TwinFontConfigExtension on TwinFontConfig {
  TwinFontConfig copyWith({
    String? fontFamily,
    int? fontColor,
    double? fontSize,
    bool? fontBold,
  }) {
    return TwinFontConfig(
      fontFamily: fontFamily ?? this.fontFamily,
      fontColor: fontColor ?? this.fontColor,
      fontSize: fontSize ?? this.fontSize,
      fontBold: fontBold ?? this.fontBold,
    );
  }

  TwinFontConfig copyWithWrapped({
    Wrapped<String?>? fontFamily,
    Wrapped<int?>? fontColor,
    Wrapped<double?>? fontSize,
    Wrapped<bool?>? fontBold,
  }) {
    return TwinFontConfig(
      fontFamily: (fontFamily != null ? fontFamily.value : this.fontFamily),
      fontColor: (fontColor != null ? fontColor.value : this.fontColor),
      fontSize: (fontSize != null ? fontSize.value : this.fontSize),
      fontBold: (fontBold != null ? fontBold.value : this.fontBold),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TitleConfig {
  const TitleConfig({
    this.title,
    this.bgColor,
    this.titleFont,
    this.titleAlignment,
  });

  factory TitleConfig.fromJson(Map<String, dynamic> json) =>
      _$TitleConfigFromJson(json);

  static const toJsonFactory = _$TitleConfigToJson;
  Map<String, dynamic> toJson() => _$TitleConfigToJson(this);

  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'titleFont', includeIfNull: false)
  final TwinFontConfig? titleFont;
  @JsonKey(name: 'titleAlignment', includeIfNull: false)
  final AlignmentConfig? titleAlignment;
  static const fromJsonFactory = _$TitleConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TitleConfig &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality().equals(
                  other.bgColor,
                  bgColor,
                )) &&
            (identical(other.titleFont, titleFont) ||
                const DeepCollectionEquality().equals(
                  other.titleFont,
                  titleFont,
                )) &&
            (identical(other.titleAlignment, titleAlignment) ||
                const DeepCollectionEquality().equals(
                  other.titleAlignment,
                  titleAlignment,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(titleFont) ^
      const DeepCollectionEquality().hash(titleAlignment) ^
      runtimeType.hashCode;
}

extension $TitleConfigExtension on TitleConfig {
  TitleConfig copyWith({
    String? title,
    int? bgColor,
    TwinFontConfig? titleFont,
    AlignmentConfig? titleAlignment,
  }) {
    return TitleConfig(
      title: title ?? this.title,
      bgColor: bgColor ?? this.bgColor,
      titleFont: titleFont ?? this.titleFont,
      titleAlignment: titleAlignment ?? this.titleAlignment,
    );
  }

  TitleConfig copyWithWrapped({
    Wrapped<String?>? title,
    Wrapped<int?>? bgColor,
    Wrapped<TwinFontConfig?>? titleFont,
    Wrapped<AlignmentConfig?>? titleAlignment,
  }) {
    return TitleConfig(
      title: (title != null ? title.value : this.title),
      bgColor: (bgColor != null ? bgColor.value : this.bgColor),
      titleFont: (titleFont != null ? titleFont.value : this.titleFont),
      titleAlignment: (titleAlignment != null
          ? titleAlignment.value
          : this.titleAlignment),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenChild {
  const ScreenChild({
    required this.widgetId,
    required this.config,
    this.width,
    this.height,
    this.bgColor,
    this.bgImage,
    this.expanded,
    this.flex,
    this.titleConfig,
    this.titleAlignment,
    this.bgImageFit,
    this.paddingConfig,
    this.marginConfig,
    this.childBorderConfig,
    this.alignment,
  });

  factory ScreenChild.fromJson(Map<String, dynamic> json) =>
      _$ScreenChildFromJson(json);

  static const toJsonFactory = _$ScreenChildToJson;
  Map<String, dynamic> toJson() => _$ScreenChildToJson(this);

  @JsonKey(name: 'widgetId', includeIfNull: false, defaultValue: '')
  final String widgetId;
  @JsonKey(name: 'config', includeIfNull: false)
  final Object config;
  @JsonKey(name: 'width', includeIfNull: false)
  final double? width;
  @JsonKey(name: 'height', includeIfNull: false)
  final double? height;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'bgImage', includeIfNull: false, defaultValue: '')
  final String? bgImage;
  @JsonKey(name: 'expanded', includeIfNull: false)
  final bool? expanded;
  @JsonKey(name: 'flex', includeIfNull: false)
  final int? flex;
  @JsonKey(name: 'titleConfig', includeIfNull: false)
  final TitleConfig? titleConfig;
  @JsonKey(name: 'titleAlignment', includeIfNull: false)
  final AlignmentConfig? titleAlignment;
  @JsonKey(name: 'bgImageFit', includeIfNull: false)
  final ImageFitConfig? bgImageFit;
  @JsonKey(name: 'paddingConfig', includeIfNull: false)
  final PaddingConfig? paddingConfig;
  @JsonKey(name: 'marginConfig', includeIfNull: false)
  final PaddingConfig? marginConfig;
  @JsonKey(name: 'childBorderConfig', includeIfNull: false)
  final BorderConfig? childBorderConfig;
  @JsonKey(name: 'alignment', includeIfNull: false)
  final AlignmentConfig? alignment;
  static const fromJsonFactory = _$ScreenChildFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenChild &&
            (identical(other.widgetId, widgetId) ||
                const DeepCollectionEquality().equals(
                  other.widgetId,
                  widgetId,
                )) &&
            (identical(other.config, config) ||
                const DeepCollectionEquality().equals(other.config, config)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality().equals(
                  other.bgColor,
                  bgColor,
                )) &&
            (identical(other.bgImage, bgImage) ||
                const DeepCollectionEquality().equals(
                  other.bgImage,
                  bgImage,
                )) &&
            (identical(other.expanded, expanded) ||
                const DeepCollectionEquality().equals(
                  other.expanded,
                  expanded,
                )) &&
            (identical(other.flex, flex) ||
                const DeepCollectionEquality().equals(other.flex, flex)) &&
            (identical(other.titleConfig, titleConfig) ||
                const DeepCollectionEquality().equals(
                  other.titleConfig,
                  titleConfig,
                )) &&
            (identical(other.titleAlignment, titleAlignment) ||
                const DeepCollectionEquality().equals(
                  other.titleAlignment,
                  titleAlignment,
                )) &&
            (identical(other.bgImageFit, bgImageFit) ||
                const DeepCollectionEquality().equals(
                  other.bgImageFit,
                  bgImageFit,
                )) &&
            (identical(other.paddingConfig, paddingConfig) ||
                const DeepCollectionEquality().equals(
                  other.paddingConfig,
                  paddingConfig,
                )) &&
            (identical(other.marginConfig, marginConfig) ||
                const DeepCollectionEquality().equals(
                  other.marginConfig,
                  marginConfig,
                )) &&
            (identical(other.childBorderConfig, childBorderConfig) ||
                const DeepCollectionEquality().equals(
                  other.childBorderConfig,
                  childBorderConfig,
                )) &&
            (identical(other.alignment, alignment) ||
                const DeepCollectionEquality().equals(
                  other.alignment,
                  alignment,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(widgetId) ^
      const DeepCollectionEquality().hash(config) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(bgImage) ^
      const DeepCollectionEquality().hash(expanded) ^
      const DeepCollectionEquality().hash(flex) ^
      const DeepCollectionEquality().hash(titleConfig) ^
      const DeepCollectionEquality().hash(titleAlignment) ^
      const DeepCollectionEquality().hash(bgImageFit) ^
      const DeepCollectionEquality().hash(paddingConfig) ^
      const DeepCollectionEquality().hash(marginConfig) ^
      const DeepCollectionEquality().hash(childBorderConfig) ^
      const DeepCollectionEquality().hash(alignment) ^
      runtimeType.hashCode;
}

extension $ScreenChildExtension on ScreenChild {
  ScreenChild copyWith({
    String? widgetId,
    Object? config,
    double? width,
    double? height,
    int? bgColor,
    String? bgImage,
    bool? expanded,
    int? flex,
    TitleConfig? titleConfig,
    AlignmentConfig? titleAlignment,
    ImageFitConfig? bgImageFit,
    PaddingConfig? paddingConfig,
    PaddingConfig? marginConfig,
    BorderConfig? childBorderConfig,
    AlignmentConfig? alignment,
  }) {
    return ScreenChild(
      widgetId: widgetId ?? this.widgetId,
      config: config ?? this.config,
      width: width ?? this.width,
      height: height ?? this.height,
      bgColor: bgColor ?? this.bgColor,
      bgImage: bgImage ?? this.bgImage,
      expanded: expanded ?? this.expanded,
      flex: flex ?? this.flex,
      titleConfig: titleConfig ?? this.titleConfig,
      titleAlignment: titleAlignment ?? this.titleAlignment,
      bgImageFit: bgImageFit ?? this.bgImageFit,
      paddingConfig: paddingConfig ?? this.paddingConfig,
      marginConfig: marginConfig ?? this.marginConfig,
      childBorderConfig: childBorderConfig ?? this.childBorderConfig,
      alignment: alignment ?? this.alignment,
    );
  }

  ScreenChild copyWithWrapped({
    Wrapped<String>? widgetId,
    Wrapped<Object>? config,
    Wrapped<double?>? width,
    Wrapped<double?>? height,
    Wrapped<int?>? bgColor,
    Wrapped<String?>? bgImage,
    Wrapped<bool?>? expanded,
    Wrapped<int?>? flex,
    Wrapped<TitleConfig?>? titleConfig,
    Wrapped<AlignmentConfig?>? titleAlignment,
    Wrapped<ImageFitConfig?>? bgImageFit,
    Wrapped<PaddingConfig?>? paddingConfig,
    Wrapped<PaddingConfig?>? marginConfig,
    Wrapped<BorderConfig?>? childBorderConfig,
    Wrapped<AlignmentConfig?>? alignment,
  }) {
    return ScreenChild(
      widgetId: (widgetId != null ? widgetId.value : this.widgetId),
      config: (config != null ? config.value : this.config),
      width: (width != null ? width.value : this.width),
      height: (height != null ? height.value : this.height),
      bgColor: (bgColor != null ? bgColor.value : this.bgColor),
      bgImage: (bgImage != null ? bgImage.value : this.bgImage),
      expanded: (expanded != null ? expanded.value : this.expanded),
      flex: (flex != null ? flex.value : this.flex),
      titleConfig: (titleConfig != null ? titleConfig.value : this.titleConfig),
      titleAlignment: (titleAlignment != null
          ? titleAlignment.value
          : this.titleAlignment),
      bgImageFit: (bgImageFit != null ? bgImageFit.value : this.bgImageFit),
      paddingConfig: (paddingConfig != null
          ? paddingConfig.value
          : this.paddingConfig),
      marginConfig: (marginConfig != null
          ? marginConfig.value
          : this.marginConfig),
      childBorderConfig: (childBorderConfig != null
          ? childBorderConfig.value
          : this.childBorderConfig),
      alignment: (alignment != null ? alignment.value : this.alignment),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenRow {
  const ScreenRow({
    this.height,
    this.spacing,
    this.bgColor,
    this.bgImage,
    this.mainAxisAlignment,
    this.crossAxisAlignment,
    this.mainAxisSize,
    this.scrollDirection,
    this.titleConfig,
    this.bgImageFit,
    this.paddingConfig,
    this.marginConfig,
    this.rowBorderConfig,
    required this.children,
  });

  factory ScreenRow.fromJson(Map<String, dynamic> json) =>
      _$ScreenRowFromJson(json);

  static const toJsonFactory = _$ScreenRowToJson;
  Map<String, dynamic> toJson() => _$ScreenRowToJson(this);

  @JsonKey(name: 'height', includeIfNull: false)
  final double? height;
  @JsonKey(name: 'spacing', includeIfNull: false)
  final double? spacing;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'bgImage', includeIfNull: false, defaultValue: '')
  final String? bgImage;
  @JsonKey(name: 'mainAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? mainAxisAlignment;
  @JsonKey(name: 'crossAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? crossAxisAlignment;
  @JsonKey(name: 'mainAxisSize', includeIfNull: false, defaultValue: '')
  final String? mainAxisSize;
  @JsonKey(name: 'scrollDirection', includeIfNull: false, defaultValue: '')
  final String? scrollDirection;
  @JsonKey(name: 'titleConfig', includeIfNull: false)
  final TitleConfig? titleConfig;
  @JsonKey(name: 'bgImageFit', includeIfNull: false)
  final ImageFitConfig? bgImageFit;
  @JsonKey(name: 'paddingConfig', includeIfNull: false)
  final PaddingConfig? paddingConfig;
  @JsonKey(name: 'marginConfig', includeIfNull: false)
  final PaddingConfig? marginConfig;
  @JsonKey(name: 'rowBorderConfig', includeIfNull: false)
  final BorderConfig? rowBorderConfig;
  @JsonKey(
    name: 'children',
    includeIfNull: false,
    defaultValue: <ScreenChild>[],
  )
  final List<ScreenChild> children;
  static const fromJsonFactory = _$ScreenRowFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenRow &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.spacing, spacing) ||
                const DeepCollectionEquality().equals(
                  other.spacing,
                  spacing,
                )) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality().equals(
                  other.bgColor,
                  bgColor,
                )) &&
            (identical(other.bgImage, bgImage) ||
                const DeepCollectionEquality().equals(
                  other.bgImage,
                  bgImage,
                )) &&
            (identical(other.mainAxisAlignment, mainAxisAlignment) ||
                const DeepCollectionEquality().equals(
                  other.mainAxisAlignment,
                  mainAxisAlignment,
                )) &&
            (identical(other.crossAxisAlignment, crossAxisAlignment) ||
                const DeepCollectionEquality().equals(
                  other.crossAxisAlignment,
                  crossAxisAlignment,
                )) &&
            (identical(other.mainAxisSize, mainAxisSize) ||
                const DeepCollectionEquality().equals(
                  other.mainAxisSize,
                  mainAxisSize,
                )) &&
            (identical(other.scrollDirection, scrollDirection) ||
                const DeepCollectionEquality().equals(
                  other.scrollDirection,
                  scrollDirection,
                )) &&
            (identical(other.titleConfig, titleConfig) ||
                const DeepCollectionEquality().equals(
                  other.titleConfig,
                  titleConfig,
                )) &&
            (identical(other.bgImageFit, bgImageFit) ||
                const DeepCollectionEquality().equals(
                  other.bgImageFit,
                  bgImageFit,
                )) &&
            (identical(other.paddingConfig, paddingConfig) ||
                const DeepCollectionEquality().equals(
                  other.paddingConfig,
                  paddingConfig,
                )) &&
            (identical(other.marginConfig, marginConfig) ||
                const DeepCollectionEquality().equals(
                  other.marginConfig,
                  marginConfig,
                )) &&
            (identical(other.rowBorderConfig, rowBorderConfig) ||
                const DeepCollectionEquality().equals(
                  other.rowBorderConfig,
                  rowBorderConfig,
                )) &&
            (identical(other.children, children) ||
                const DeepCollectionEquality().equals(
                  other.children,
                  children,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(spacing) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(bgImage) ^
      const DeepCollectionEquality().hash(mainAxisAlignment) ^
      const DeepCollectionEquality().hash(crossAxisAlignment) ^
      const DeepCollectionEquality().hash(mainAxisSize) ^
      const DeepCollectionEquality().hash(scrollDirection) ^
      const DeepCollectionEquality().hash(titleConfig) ^
      const DeepCollectionEquality().hash(bgImageFit) ^
      const DeepCollectionEquality().hash(paddingConfig) ^
      const DeepCollectionEquality().hash(marginConfig) ^
      const DeepCollectionEquality().hash(rowBorderConfig) ^
      const DeepCollectionEquality().hash(children) ^
      runtimeType.hashCode;
}

extension $ScreenRowExtension on ScreenRow {
  ScreenRow copyWith({
    double? height,
    double? spacing,
    int? bgColor,
    String? bgImage,
    String? mainAxisAlignment,
    String? crossAxisAlignment,
    String? mainAxisSize,
    String? scrollDirection,
    TitleConfig? titleConfig,
    ImageFitConfig? bgImageFit,
    PaddingConfig? paddingConfig,
    PaddingConfig? marginConfig,
    BorderConfig? rowBorderConfig,
    List<ScreenChild>? children,
  }) {
    return ScreenRow(
      height: height ?? this.height,
      spacing: spacing ?? this.spacing,
      bgColor: bgColor ?? this.bgColor,
      bgImage: bgImage ?? this.bgImage,
      mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
      crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
      mainAxisSize: mainAxisSize ?? this.mainAxisSize,
      scrollDirection: scrollDirection ?? this.scrollDirection,
      titleConfig: titleConfig ?? this.titleConfig,
      bgImageFit: bgImageFit ?? this.bgImageFit,
      paddingConfig: paddingConfig ?? this.paddingConfig,
      marginConfig: marginConfig ?? this.marginConfig,
      rowBorderConfig: rowBorderConfig ?? this.rowBorderConfig,
      children: children ?? this.children,
    );
  }

  ScreenRow copyWithWrapped({
    Wrapped<double?>? height,
    Wrapped<double?>? spacing,
    Wrapped<int?>? bgColor,
    Wrapped<String?>? bgImage,
    Wrapped<String?>? mainAxisAlignment,
    Wrapped<String?>? crossAxisAlignment,
    Wrapped<String?>? mainAxisSize,
    Wrapped<String?>? scrollDirection,
    Wrapped<TitleConfig?>? titleConfig,
    Wrapped<ImageFitConfig?>? bgImageFit,
    Wrapped<PaddingConfig?>? paddingConfig,
    Wrapped<PaddingConfig?>? marginConfig,
    Wrapped<BorderConfig?>? rowBorderConfig,
    Wrapped<List<ScreenChild>>? children,
  }) {
    return ScreenRow(
      height: (height != null ? height.value : this.height),
      spacing: (spacing != null ? spacing.value : this.spacing),
      bgColor: (bgColor != null ? bgColor.value : this.bgColor),
      bgImage: (bgImage != null ? bgImage.value : this.bgImage),
      mainAxisAlignment: (mainAxisAlignment != null
          ? mainAxisAlignment.value
          : this.mainAxisAlignment),
      crossAxisAlignment: (crossAxisAlignment != null
          ? crossAxisAlignment.value
          : this.crossAxisAlignment),
      mainAxisSize: (mainAxisSize != null
          ? mainAxisSize.value
          : this.mainAxisSize),
      scrollDirection: (scrollDirection != null
          ? scrollDirection.value
          : this.scrollDirection),
      titleConfig: (titleConfig != null ? titleConfig.value : this.titleConfig),
      bgImageFit: (bgImageFit != null ? bgImageFit.value : this.bgImageFit),
      paddingConfig: (paddingConfig != null
          ? paddingConfig.value
          : this.paddingConfig),
      marginConfig: (marginConfig != null
          ? marginConfig.value
          : this.marginConfig),
      rowBorderConfig: (rowBorderConfig != null
          ? rowBorderConfig.value
          : this.rowBorderConfig),
      children: (children != null ? children.value : this.children),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenInfo {
  const DashboardScreenInfo({
    required this.name,
    this.description,
    this.bannerImage,
    this.spacing,
    this.tags,
    this.bgColor,
    this.bgImage,
    this.mainAxisAlignment,
    this.crossAxisAlignment,
    this.mainAxisSize,
    this.scrollDirection,
    this.bannerHeight,
    this.titleConfig,
    this.bannerImageFit,
    this.bgImageFit,
    this.screenBorderConfig,
    this.paddingConfig,
    this.marginConfig,
    required this.rows,
    this.roles,
    this.priority,
  });

  factory DashboardScreenInfo.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenInfoFromJson(json);

  static const toJsonFactory = _$DashboardScreenInfoToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'bannerImage', includeIfNull: false, defaultValue: '')
  final String? bannerImage;
  @JsonKey(name: 'spacing', includeIfNull: false)
  final double? spacing;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'bgImage', includeIfNull: false, defaultValue: '')
  final String? bgImage;
  @JsonKey(name: 'mainAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? mainAxisAlignment;
  @JsonKey(name: 'crossAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? crossAxisAlignment;
  @JsonKey(name: 'mainAxisSize', includeIfNull: false, defaultValue: '')
  final String? mainAxisSize;
  @JsonKey(name: 'scrollDirection', includeIfNull: false, defaultValue: '')
  final String? scrollDirection;
  @JsonKey(name: 'bannerHeight', includeIfNull: false)
  final double? bannerHeight;
  @JsonKey(name: 'titleConfig', includeIfNull: false)
  final TitleConfig? titleConfig;
  @JsonKey(name: 'bannerImageFit', includeIfNull: false)
  final ImageFitConfig? bannerImageFit;
  @JsonKey(name: 'bgImageFit', includeIfNull: false)
  final ImageFitConfig? bgImageFit;
  @JsonKey(name: 'screenBorderConfig', includeIfNull: false)
  final BorderConfig? screenBorderConfig;
  @JsonKey(name: 'paddingConfig', includeIfNull: false)
  final PaddingConfig? paddingConfig;
  @JsonKey(name: 'marginConfig', includeIfNull: false)
  final PaddingConfig? marginConfig;
  @JsonKey(name: 'rows', includeIfNull: false, defaultValue: <ScreenRow>[])
  final List<ScreenRow> rows;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'priority', includeIfNull: false)
  final int? priority;
  static const fromJsonFactory = _$DashboardScreenInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.bannerImage, bannerImage) ||
                const DeepCollectionEquality().equals(
                  other.bannerImage,
                  bannerImage,
                )) &&
            (identical(other.spacing, spacing) ||
                const DeepCollectionEquality().equals(
                  other.spacing,
                  spacing,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality().equals(
                  other.bgColor,
                  bgColor,
                )) &&
            (identical(other.bgImage, bgImage) ||
                const DeepCollectionEquality().equals(
                  other.bgImage,
                  bgImage,
                )) &&
            (identical(other.mainAxisAlignment, mainAxisAlignment) ||
                const DeepCollectionEquality().equals(
                  other.mainAxisAlignment,
                  mainAxisAlignment,
                )) &&
            (identical(other.crossAxisAlignment, crossAxisAlignment) ||
                const DeepCollectionEquality().equals(
                  other.crossAxisAlignment,
                  crossAxisAlignment,
                )) &&
            (identical(other.mainAxisSize, mainAxisSize) ||
                const DeepCollectionEquality().equals(
                  other.mainAxisSize,
                  mainAxisSize,
                )) &&
            (identical(other.scrollDirection, scrollDirection) ||
                const DeepCollectionEquality().equals(
                  other.scrollDirection,
                  scrollDirection,
                )) &&
            (identical(other.bannerHeight, bannerHeight) ||
                const DeepCollectionEquality().equals(
                  other.bannerHeight,
                  bannerHeight,
                )) &&
            (identical(other.titleConfig, titleConfig) ||
                const DeepCollectionEquality().equals(
                  other.titleConfig,
                  titleConfig,
                )) &&
            (identical(other.bannerImageFit, bannerImageFit) ||
                const DeepCollectionEquality().equals(
                  other.bannerImageFit,
                  bannerImageFit,
                )) &&
            (identical(other.bgImageFit, bgImageFit) ||
                const DeepCollectionEquality().equals(
                  other.bgImageFit,
                  bgImageFit,
                )) &&
            (identical(other.screenBorderConfig, screenBorderConfig) ||
                const DeepCollectionEquality().equals(
                  other.screenBorderConfig,
                  screenBorderConfig,
                )) &&
            (identical(other.paddingConfig, paddingConfig) ||
                const DeepCollectionEquality().equals(
                  other.paddingConfig,
                  paddingConfig,
                )) &&
            (identical(other.marginConfig, marginConfig) ||
                const DeepCollectionEquality().equals(
                  other.marginConfig,
                  marginConfig,
                )) &&
            (identical(other.rows, rows) ||
                const DeepCollectionEquality().equals(other.rows, rows)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality().equals(
                  other.priority,
                  priority,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(bannerImage) ^
      const DeepCollectionEquality().hash(spacing) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(bgImage) ^
      const DeepCollectionEquality().hash(mainAxisAlignment) ^
      const DeepCollectionEquality().hash(crossAxisAlignment) ^
      const DeepCollectionEquality().hash(mainAxisSize) ^
      const DeepCollectionEquality().hash(scrollDirection) ^
      const DeepCollectionEquality().hash(bannerHeight) ^
      const DeepCollectionEquality().hash(titleConfig) ^
      const DeepCollectionEquality().hash(bannerImageFit) ^
      const DeepCollectionEquality().hash(bgImageFit) ^
      const DeepCollectionEquality().hash(screenBorderConfig) ^
      const DeepCollectionEquality().hash(paddingConfig) ^
      const DeepCollectionEquality().hash(marginConfig) ^
      const DeepCollectionEquality().hash(rows) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(priority) ^
      runtimeType.hashCode;
}

extension $DashboardScreenInfoExtension on DashboardScreenInfo {
  DashboardScreenInfo copyWith({
    String? name,
    String? description,
    String? bannerImage,
    double? spacing,
    List<String>? tags,
    int? bgColor,
    String? bgImage,
    String? mainAxisAlignment,
    String? crossAxisAlignment,
    String? mainAxisSize,
    String? scrollDirection,
    double? bannerHeight,
    TitleConfig? titleConfig,
    ImageFitConfig? bannerImageFit,
    ImageFitConfig? bgImageFit,
    BorderConfig? screenBorderConfig,
    PaddingConfig? paddingConfig,
    PaddingConfig? marginConfig,
    List<ScreenRow>? rows,
    List<String>? roles,
    int? priority,
  }) {
    return DashboardScreenInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      bannerImage: bannerImage ?? this.bannerImage,
      spacing: spacing ?? this.spacing,
      tags: tags ?? this.tags,
      bgColor: bgColor ?? this.bgColor,
      bgImage: bgImage ?? this.bgImage,
      mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
      crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
      mainAxisSize: mainAxisSize ?? this.mainAxisSize,
      scrollDirection: scrollDirection ?? this.scrollDirection,
      bannerHeight: bannerHeight ?? this.bannerHeight,
      titleConfig: titleConfig ?? this.titleConfig,
      bannerImageFit: bannerImageFit ?? this.bannerImageFit,
      bgImageFit: bgImageFit ?? this.bgImageFit,
      screenBorderConfig: screenBorderConfig ?? this.screenBorderConfig,
      paddingConfig: paddingConfig ?? this.paddingConfig,
      marginConfig: marginConfig ?? this.marginConfig,
      rows: rows ?? this.rows,
      roles: roles ?? this.roles,
      priority: priority ?? this.priority,
    );
  }

  DashboardScreenInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? bannerImage,
    Wrapped<double?>? spacing,
    Wrapped<List<String>?>? tags,
    Wrapped<int?>? bgColor,
    Wrapped<String?>? bgImage,
    Wrapped<String?>? mainAxisAlignment,
    Wrapped<String?>? crossAxisAlignment,
    Wrapped<String?>? mainAxisSize,
    Wrapped<String?>? scrollDirection,
    Wrapped<double?>? bannerHeight,
    Wrapped<TitleConfig?>? titleConfig,
    Wrapped<ImageFitConfig?>? bannerImageFit,
    Wrapped<ImageFitConfig?>? bgImageFit,
    Wrapped<BorderConfig?>? screenBorderConfig,
    Wrapped<PaddingConfig?>? paddingConfig,
    Wrapped<PaddingConfig?>? marginConfig,
    Wrapped<List<ScreenRow>>? rows,
    Wrapped<List<String>?>? roles,
    Wrapped<int?>? priority,
  }) {
    return DashboardScreenInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      bannerImage: (bannerImage != null ? bannerImage.value : this.bannerImage),
      spacing: (spacing != null ? spacing.value : this.spacing),
      tags: (tags != null ? tags.value : this.tags),
      bgColor: (bgColor != null ? bgColor.value : this.bgColor),
      bgImage: (bgImage != null ? bgImage.value : this.bgImage),
      mainAxisAlignment: (mainAxisAlignment != null
          ? mainAxisAlignment.value
          : this.mainAxisAlignment),
      crossAxisAlignment: (crossAxisAlignment != null
          ? crossAxisAlignment.value
          : this.crossAxisAlignment),
      mainAxisSize: (mainAxisSize != null
          ? mainAxisSize.value
          : this.mainAxisSize),
      scrollDirection: (scrollDirection != null
          ? scrollDirection.value
          : this.scrollDirection),
      bannerHeight: (bannerHeight != null
          ? bannerHeight.value
          : this.bannerHeight),
      titleConfig: (titleConfig != null ? titleConfig.value : this.titleConfig),
      bannerImageFit: (bannerImageFit != null
          ? bannerImageFit.value
          : this.bannerImageFit),
      bgImageFit: (bgImageFit != null ? bgImageFit.value : this.bgImageFit),
      screenBorderConfig: (screenBorderConfig != null
          ? screenBorderConfig.value
          : this.screenBorderConfig),
      paddingConfig: (paddingConfig != null
          ? paddingConfig.value
          : this.paddingConfig),
      marginConfig: (marginConfig != null
          ? marginConfig.value
          : this.marginConfig),
      rows: (rows != null ? rows.value : this.rows),
      roles: (roles != null ? roles.value : this.roles),
      priority: (priority != null ? priority.value : this.priority),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreen {
  const DashboardScreen({
    required this.name,
    this.description,
    this.bannerImage,
    this.spacing,
    this.tags,
    this.bgColor,
    this.bgImage,
    this.mainAxisAlignment,
    this.crossAxisAlignment,
    this.mainAxisSize,
    this.scrollDirection,
    this.bannerHeight,
    this.titleConfig,
    this.bannerImageFit,
    this.bgImageFit,
    this.screenBorderConfig,
    this.paddingConfig,
    this.marginConfig,
    required this.rows,
    this.roles,
    this.priority,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory DashboardScreen.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenFromJson(json);

  static const toJsonFactory = _$DashboardScreenToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'bannerImage', includeIfNull: false, defaultValue: '')
  final String? bannerImage;
  @JsonKey(name: 'spacing', includeIfNull: false)
  final double? spacing;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'bgImage', includeIfNull: false, defaultValue: '')
  final String? bgImage;
  @JsonKey(name: 'mainAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? mainAxisAlignment;
  @JsonKey(name: 'crossAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? crossAxisAlignment;
  @JsonKey(name: 'mainAxisSize', includeIfNull: false, defaultValue: '')
  final String? mainAxisSize;
  @JsonKey(name: 'scrollDirection', includeIfNull: false, defaultValue: '')
  final String? scrollDirection;
  @JsonKey(name: 'bannerHeight', includeIfNull: false)
  final double? bannerHeight;
  @JsonKey(name: 'titleConfig', includeIfNull: false)
  final TitleConfig? titleConfig;
  @JsonKey(name: 'bannerImageFit', includeIfNull: false)
  final ImageFitConfig? bannerImageFit;
  @JsonKey(name: 'bgImageFit', includeIfNull: false)
  final ImageFitConfig? bgImageFit;
  @JsonKey(name: 'screenBorderConfig', includeIfNull: false)
  final BorderConfig? screenBorderConfig;
  @JsonKey(name: 'paddingConfig', includeIfNull: false)
  final PaddingConfig? paddingConfig;
  @JsonKey(name: 'marginConfig', includeIfNull: false)
  final PaddingConfig? marginConfig;
  @JsonKey(name: 'rows', includeIfNull: false, defaultValue: <ScreenRow>[])
  final List<ScreenRow> rows;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'priority', includeIfNull: false)
  final int? priority;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$DashboardScreenFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreen &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.bannerImage, bannerImage) ||
                const DeepCollectionEquality().equals(
                  other.bannerImage,
                  bannerImage,
                )) &&
            (identical(other.spacing, spacing) ||
                const DeepCollectionEquality().equals(
                  other.spacing,
                  spacing,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality().equals(
                  other.bgColor,
                  bgColor,
                )) &&
            (identical(other.bgImage, bgImage) ||
                const DeepCollectionEquality().equals(
                  other.bgImage,
                  bgImage,
                )) &&
            (identical(other.mainAxisAlignment, mainAxisAlignment) ||
                const DeepCollectionEquality().equals(
                  other.mainAxisAlignment,
                  mainAxisAlignment,
                )) &&
            (identical(other.crossAxisAlignment, crossAxisAlignment) ||
                const DeepCollectionEquality().equals(
                  other.crossAxisAlignment,
                  crossAxisAlignment,
                )) &&
            (identical(other.mainAxisSize, mainAxisSize) ||
                const DeepCollectionEquality().equals(
                  other.mainAxisSize,
                  mainAxisSize,
                )) &&
            (identical(other.scrollDirection, scrollDirection) ||
                const DeepCollectionEquality().equals(
                  other.scrollDirection,
                  scrollDirection,
                )) &&
            (identical(other.bannerHeight, bannerHeight) ||
                const DeepCollectionEquality().equals(
                  other.bannerHeight,
                  bannerHeight,
                )) &&
            (identical(other.titleConfig, titleConfig) ||
                const DeepCollectionEquality().equals(
                  other.titleConfig,
                  titleConfig,
                )) &&
            (identical(other.bannerImageFit, bannerImageFit) ||
                const DeepCollectionEquality().equals(
                  other.bannerImageFit,
                  bannerImageFit,
                )) &&
            (identical(other.bgImageFit, bgImageFit) ||
                const DeepCollectionEquality().equals(
                  other.bgImageFit,
                  bgImageFit,
                )) &&
            (identical(other.screenBorderConfig, screenBorderConfig) ||
                const DeepCollectionEquality().equals(
                  other.screenBorderConfig,
                  screenBorderConfig,
                )) &&
            (identical(other.paddingConfig, paddingConfig) ||
                const DeepCollectionEquality().equals(
                  other.paddingConfig,
                  paddingConfig,
                )) &&
            (identical(other.marginConfig, marginConfig) ||
                const DeepCollectionEquality().equals(
                  other.marginConfig,
                  marginConfig,
                )) &&
            (identical(other.rows, rows) ||
                const DeepCollectionEquality().equals(other.rows, rows)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality().equals(
                  other.priority,
                  priority,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(bannerImage) ^
      const DeepCollectionEquality().hash(spacing) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(bgImage) ^
      const DeepCollectionEquality().hash(mainAxisAlignment) ^
      const DeepCollectionEquality().hash(crossAxisAlignment) ^
      const DeepCollectionEquality().hash(mainAxisSize) ^
      const DeepCollectionEquality().hash(scrollDirection) ^
      const DeepCollectionEquality().hash(bannerHeight) ^
      const DeepCollectionEquality().hash(titleConfig) ^
      const DeepCollectionEquality().hash(bannerImageFit) ^
      const DeepCollectionEquality().hash(bgImageFit) ^
      const DeepCollectionEquality().hash(screenBorderConfig) ^
      const DeepCollectionEquality().hash(paddingConfig) ^
      const DeepCollectionEquality().hash(marginConfig) ^
      const DeepCollectionEquality().hash(rows) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $DashboardScreenExtension on DashboardScreen {
  DashboardScreen copyWith({
    String? name,
    String? description,
    String? bannerImage,
    double? spacing,
    List<String>? tags,
    int? bgColor,
    String? bgImage,
    String? mainAxisAlignment,
    String? crossAxisAlignment,
    String? mainAxisSize,
    String? scrollDirection,
    double? bannerHeight,
    TitleConfig? titleConfig,
    ImageFitConfig? bannerImageFit,
    ImageFitConfig? bgImageFit,
    BorderConfig? screenBorderConfig,
    PaddingConfig? paddingConfig,
    PaddingConfig? marginConfig,
    List<ScreenRow>? rows,
    List<String>? roles,
    int? priority,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return DashboardScreen(
      name: name ?? this.name,
      description: description ?? this.description,
      bannerImage: bannerImage ?? this.bannerImage,
      spacing: spacing ?? this.spacing,
      tags: tags ?? this.tags,
      bgColor: bgColor ?? this.bgColor,
      bgImage: bgImage ?? this.bgImage,
      mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
      crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
      mainAxisSize: mainAxisSize ?? this.mainAxisSize,
      scrollDirection: scrollDirection ?? this.scrollDirection,
      bannerHeight: bannerHeight ?? this.bannerHeight,
      titleConfig: titleConfig ?? this.titleConfig,
      bannerImageFit: bannerImageFit ?? this.bannerImageFit,
      bgImageFit: bgImageFit ?? this.bgImageFit,
      screenBorderConfig: screenBorderConfig ?? this.screenBorderConfig,
      paddingConfig: paddingConfig ?? this.paddingConfig,
      marginConfig: marginConfig ?? this.marginConfig,
      rows: rows ?? this.rows,
      roles: roles ?? this.roles,
      priority: priority ?? this.priority,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  DashboardScreen copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? bannerImage,
    Wrapped<double?>? spacing,
    Wrapped<List<String>?>? tags,
    Wrapped<int?>? bgColor,
    Wrapped<String?>? bgImage,
    Wrapped<String?>? mainAxisAlignment,
    Wrapped<String?>? crossAxisAlignment,
    Wrapped<String?>? mainAxisSize,
    Wrapped<String?>? scrollDirection,
    Wrapped<double?>? bannerHeight,
    Wrapped<TitleConfig?>? titleConfig,
    Wrapped<ImageFitConfig?>? bannerImageFit,
    Wrapped<ImageFitConfig?>? bgImageFit,
    Wrapped<BorderConfig?>? screenBorderConfig,
    Wrapped<PaddingConfig?>? paddingConfig,
    Wrapped<PaddingConfig?>? marginConfig,
    Wrapped<List<ScreenRow>>? rows,
    Wrapped<List<String>?>? roles,
    Wrapped<int?>? priority,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return DashboardScreen(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      bannerImage: (bannerImage != null ? bannerImage.value : this.bannerImage),
      spacing: (spacing != null ? spacing.value : this.spacing),
      tags: (tags != null ? tags.value : this.tags),
      bgColor: (bgColor != null ? bgColor.value : this.bgColor),
      bgImage: (bgImage != null ? bgImage.value : this.bgImage),
      mainAxisAlignment: (mainAxisAlignment != null
          ? mainAxisAlignment.value
          : this.mainAxisAlignment),
      crossAxisAlignment: (crossAxisAlignment != null
          ? crossAxisAlignment.value
          : this.crossAxisAlignment),
      mainAxisSize: (mainAxisSize != null
          ? mainAxisSize.value
          : this.mainAxisSize),
      scrollDirection: (scrollDirection != null
          ? scrollDirection.value
          : this.scrollDirection),
      bannerHeight: (bannerHeight != null
          ? bannerHeight.value
          : this.bannerHeight),
      titleConfig: (titleConfig != null ? titleConfig.value : this.titleConfig),
      bannerImageFit: (bannerImageFit != null
          ? bannerImageFit.value
          : this.bannerImageFit),
      bgImageFit: (bgImageFit != null ? bgImageFit.value : this.bgImageFit),
      screenBorderConfig: (screenBorderConfig != null
          ? screenBorderConfig.value
          : this.screenBorderConfig),
      paddingConfig: (paddingConfig != null
          ? paddingConfig.value
          : this.paddingConfig),
      marginConfig: (marginConfig != null
          ? marginConfig.value
          : this.marginConfig),
      rows: (rows != null ? rows.value : this.rows),
      roles: (roles != null ? roles.value : this.roles),
      priority: (priority != null ? priority.value : this.priority),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenEntity {
  const DashboardScreenEntity({this.entity});

  factory DashboardScreenEntity.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenEntityFromJson(json);

  static const toJsonFactory = _$DashboardScreenEntityToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DashboardScreen? entity;
  static const fromJsonFactory = _$DashboardScreenEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DashboardScreenEntityExtension on DashboardScreenEntity {
  DashboardScreenEntity copyWith({DashboardScreen? entity}) {
    return DashboardScreenEntity(entity: entity ?? this.entity);
  }

  DashboardScreenEntity copyWithWrapped({Wrapped<DashboardScreen?>? entity}) {
    return DashboardScreenEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenEntityRes {
  const DashboardScreenEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DashboardScreenEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenEntityResFromJson(json);

  static const toJsonFactory = _$DashboardScreenEntityResToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DashboardScreen? entity;
  static const fromJsonFactory = _$DashboardScreenEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DashboardScreenEntityResExtension on DashboardScreenEntityRes {
  DashboardScreenEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    DashboardScreen? entity,
  }) {
    return DashboardScreenEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DashboardScreenEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<DashboardScreen?>? entity,
  }) {
    return DashboardScreenEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenArray {
  const DashboardScreenArray({this.values});

  factory DashboardScreenArray.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenArrayFromJson(json);

  static const toJsonFactory = _$DashboardScreenArrayToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <DashboardScreen>[],
  )
  final List<DashboardScreen>? values;
  static const fromJsonFactory = _$DashboardScreenArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DashboardScreenArrayExtension on DashboardScreenArray {
  DashboardScreenArray copyWith({List<DashboardScreen>? values}) {
    return DashboardScreenArray(values: values ?? this.values);
  }

  DashboardScreenArray copyWithWrapped({
    Wrapped<List<DashboardScreen>?>? values,
  }) {
    return DashboardScreenArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenArrayRes {
  const DashboardScreenArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DashboardScreenArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenArrayResFromJson(json);

  static const toJsonFactory = _$DashboardScreenArrayResToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <DashboardScreen>[],
  )
  final List<DashboardScreen>? values;
  static const fromJsonFactory = _$DashboardScreenArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DashboardScreenArrayResExtension on DashboardScreenArrayRes {
  DashboardScreenArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<DashboardScreen>? values,
  }) {
    return DashboardScreenArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DashboardScreenArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<DashboardScreen>?>? values,
  }) {
    return DashboardScreenArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDataBase {
  const DeviceDataBase({this.data});

  factory DeviceDataBase.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataBaseFromJson(json);

  static const toJsonFactory = _$DeviceDataBaseToJson;
  Map<String, dynamic> toJson() => _$DeviceDataBaseToJson(this);

  @JsonKey(name: 'data', includeIfNull: false)
  final DeviceData? data;
  static const fromJsonFactory = _$DeviceDataBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDataBase &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^ runtimeType.hashCode;
}

extension $DeviceDataBaseExtension on DeviceDataBase {
  DeviceDataBase copyWith({DeviceData? data}) {
    return DeviceDataBase(data: data ?? this.data);
  }

  DeviceDataBase copyWithWrapped({Wrapped<DeviceData?>? data}) {
    return DeviceDataBase(data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDataEntityRes {
  const DeviceDataEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.data,
  });

  factory DeviceDataEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataEntityResFromJson(json);

  static const toJsonFactory = _$DeviceDataEntityResToJson;
  Map<String, dynamic> toJson() => _$DeviceDataEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'data', includeIfNull: false)
  final DeviceData? data;
  static const fromJsonFactory = _$DeviceDataEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDataEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $DeviceDataEntityResExtension on DeviceDataEntityRes {
  DeviceDataEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    DeviceData? data,
  }) {
    return DeviceDataEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      data: data ?? this.data,
    );
  }

  DeviceDataEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<DeviceData?>? data,
  }) {
    return DeviceDataEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationInfo {
  const EventRegistrationInfo({
    required this.eventId,
    this.notification,
    this.email,
    this.sms,
    this.voice,
    this.fcm,
    this.emailId,
    this.countryCode,
    this.phoneNumber,
    this.name,
    this.targetDeviceIds,
    this.tags,
    this.roles,
  });

  factory EventRegistrationInfo.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationInfoFromJson(json);

  static const toJsonFactory = _$EventRegistrationInfoToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationInfoToJson(this);

  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String eventId;
  @JsonKey(name: 'notification', includeIfNull: false)
  final bool? notification;
  @JsonKey(name: 'email', includeIfNull: false)
  final bool? email;
  @JsonKey(name: 'sms', includeIfNull: false)
  final bool? sms;
  @JsonKey(name: 'voice', includeIfNull: false)
  final bool? voice;
  @JsonKey(name: 'fcm', includeIfNull: false)
  final bool? fcm;
  @JsonKey(name: 'emailId', includeIfNull: false, defaultValue: '')
  final String? emailId;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'phoneNumber', includeIfNull: false, defaultValue: '')
  final String? phoneNumber;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(
    name: 'targetDeviceIds',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String>? targetDeviceIds;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  static const fromJsonFactory = _$EventRegistrationInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationInfo &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.notification, notification) ||
                const DeepCollectionEquality().equals(
                  other.notification,
                  notification,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.sms, sms) ||
                const DeepCollectionEquality().equals(other.sms, sms)) &&
            (identical(other.voice, voice) ||
                const DeepCollectionEquality().equals(other.voice, voice)) &&
            (identical(other.fcm, fcm) ||
                const DeepCollectionEquality().equals(other.fcm, fcm)) &&
            (identical(other.emailId, emailId) ||
                const DeepCollectionEquality().equals(
                  other.emailId,
                  emailId,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality().equals(
                  other.phoneNumber,
                  phoneNumber,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.targetDeviceIds, targetDeviceIds) ||
                const DeepCollectionEquality().equals(
                  other.targetDeviceIds,
                  targetDeviceIds,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(notification) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(sms) ^
      const DeepCollectionEquality().hash(voice) ^
      const DeepCollectionEquality().hash(fcm) ^
      const DeepCollectionEquality().hash(emailId) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(targetDeviceIds) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      runtimeType.hashCode;
}

extension $EventRegistrationInfoExtension on EventRegistrationInfo {
  EventRegistrationInfo copyWith({
    String? eventId,
    bool? notification,
    bool? email,
    bool? sms,
    bool? voice,
    bool? fcm,
    String? emailId,
    String? countryCode,
    String? phoneNumber,
    String? name,
    List<String>? targetDeviceIds,
    List<String>? tags,
    List<String>? roles,
  }) {
    return EventRegistrationInfo(
      eventId: eventId ?? this.eventId,
      notification: notification ?? this.notification,
      email: email ?? this.email,
      sms: sms ?? this.sms,
      voice: voice ?? this.voice,
      fcm: fcm ?? this.fcm,
      emailId: emailId ?? this.emailId,
      countryCode: countryCode ?? this.countryCode,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      name: name ?? this.name,
      targetDeviceIds: targetDeviceIds ?? this.targetDeviceIds,
      tags: tags ?? this.tags,
      roles: roles ?? this.roles,
    );
  }

  EventRegistrationInfo copyWithWrapped({
    Wrapped<String>? eventId,
    Wrapped<bool?>? notification,
    Wrapped<bool?>? email,
    Wrapped<bool?>? sms,
    Wrapped<bool?>? voice,
    Wrapped<bool?>? fcm,
    Wrapped<String?>? emailId,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? phoneNumber,
    Wrapped<String?>? name,
    Wrapped<List<String>?>? targetDeviceIds,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? roles,
  }) {
    return EventRegistrationInfo(
      eventId: (eventId != null ? eventId.value : this.eventId),
      notification: (notification != null
          ? notification.value
          : this.notification),
      email: (email != null ? email.value : this.email),
      sms: (sms != null ? sms.value : this.sms),
      voice: (voice != null ? voice.value : this.voice),
      fcm: (fcm != null ? fcm.value : this.fcm),
      emailId: (emailId != null ? emailId.value : this.emailId),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      phoneNumber: (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
      name: (name != null ? name.value : this.name),
      targetDeviceIds: (targetDeviceIds != null
          ? targetDeviceIds.value
          : this.targetDeviceIds),
      tags: (tags != null ? tags.value : this.tags),
      roles: (roles != null ? roles.value : this.roles),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationBase {
  const EventRegistrationBase({required this.userId});

  factory EventRegistrationBase.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationBaseFromJson(json);

  static const toJsonFactory = _$EventRegistrationBaseToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationBaseToJson(this);

  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String userId;
  static const fromJsonFactory = _$EventRegistrationBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationBase &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $EventRegistrationBaseExtension on EventRegistrationBase {
  EventRegistrationBase copyWith({String? userId}) {
    return EventRegistrationBase(userId: userId ?? this.userId);
  }

  EventRegistrationBase copyWithWrapped({Wrapped<String>? userId}) {
    return EventRegistrationBase(
      userId: (userId != null ? userId.value : this.userId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistration {
  const EventRegistration({
    required this.eventId,
    this.notification,
    this.email,
    this.sms,
    this.voice,
    this.fcm,
    this.emailId,
    this.countryCode,
    this.phoneNumber,
    this.name,
    this.targetDeviceIds,
    this.tags,
    this.roles,
    required this.userId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory EventRegistration.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationFromJson(json);

  static const toJsonFactory = _$EventRegistrationToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationToJson(this);

  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String eventId;
  @JsonKey(name: 'notification', includeIfNull: false)
  final bool? notification;
  @JsonKey(name: 'email', includeIfNull: false)
  final bool? email;
  @JsonKey(name: 'sms', includeIfNull: false)
  final bool? sms;
  @JsonKey(name: 'voice', includeIfNull: false)
  final bool? voice;
  @JsonKey(name: 'fcm', includeIfNull: false)
  final bool? fcm;
  @JsonKey(name: 'emailId', includeIfNull: false, defaultValue: '')
  final String? emailId;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'phoneNumber', includeIfNull: false, defaultValue: '')
  final String? phoneNumber;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(
    name: 'targetDeviceIds',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String>? targetDeviceIds;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String userId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$EventRegistrationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistration &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.notification, notification) ||
                const DeepCollectionEquality().equals(
                  other.notification,
                  notification,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.sms, sms) ||
                const DeepCollectionEquality().equals(other.sms, sms)) &&
            (identical(other.voice, voice) ||
                const DeepCollectionEquality().equals(other.voice, voice)) &&
            (identical(other.fcm, fcm) ||
                const DeepCollectionEquality().equals(other.fcm, fcm)) &&
            (identical(other.emailId, emailId) ||
                const DeepCollectionEquality().equals(
                  other.emailId,
                  emailId,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality().equals(
                  other.phoneNumber,
                  phoneNumber,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.targetDeviceIds, targetDeviceIds) ||
                const DeepCollectionEquality().equals(
                  other.targetDeviceIds,
                  targetDeviceIds,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(notification) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(sms) ^
      const DeepCollectionEquality().hash(voice) ^
      const DeepCollectionEquality().hash(fcm) ^
      const DeepCollectionEquality().hash(emailId) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(targetDeviceIds) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $EventRegistrationExtension on EventRegistration {
  EventRegistration copyWith({
    String? eventId,
    bool? notification,
    bool? email,
    bool? sms,
    bool? voice,
    bool? fcm,
    String? emailId,
    String? countryCode,
    String? phoneNumber,
    String? name,
    List<String>? targetDeviceIds,
    List<String>? tags,
    List<String>? roles,
    String? userId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return EventRegistration(
      eventId: eventId ?? this.eventId,
      notification: notification ?? this.notification,
      email: email ?? this.email,
      sms: sms ?? this.sms,
      voice: voice ?? this.voice,
      fcm: fcm ?? this.fcm,
      emailId: emailId ?? this.emailId,
      countryCode: countryCode ?? this.countryCode,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      name: name ?? this.name,
      targetDeviceIds: targetDeviceIds ?? this.targetDeviceIds,
      tags: tags ?? this.tags,
      roles: roles ?? this.roles,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  EventRegistration copyWithWrapped({
    Wrapped<String>? eventId,
    Wrapped<bool?>? notification,
    Wrapped<bool?>? email,
    Wrapped<bool?>? sms,
    Wrapped<bool?>? voice,
    Wrapped<bool?>? fcm,
    Wrapped<String?>? emailId,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? phoneNumber,
    Wrapped<String?>? name,
    Wrapped<List<String>?>? targetDeviceIds,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? roles,
    Wrapped<String>? userId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return EventRegistration(
      eventId: (eventId != null ? eventId.value : this.eventId),
      notification: (notification != null
          ? notification.value
          : this.notification),
      email: (email != null ? email.value : this.email),
      sms: (sms != null ? sms.value : this.sms),
      voice: (voice != null ? voice.value : this.voice),
      fcm: (fcm != null ? fcm.value : this.fcm),
      emailId: (emailId != null ? emailId.value : this.emailId),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      phoneNumber: (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
      name: (name != null ? name.value : this.name),
      targetDeviceIds: (targetDeviceIds != null
          ? targetDeviceIds.value
          : this.targetDeviceIds),
      tags: (tags != null ? tags.value : this.tags),
      roles: (roles != null ? roles.value : this.roles),
      userId: (userId != null ? userId.value : this.userId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationEntity {
  const EventRegistrationEntity({this.entity});

  factory EventRegistrationEntity.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationEntityFromJson(json);

  static const toJsonFactory = _$EventRegistrationEntityToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final EventRegistration? entity;
  static const fromJsonFactory = _$EventRegistrationEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $EventRegistrationEntityExtension on EventRegistrationEntity {
  EventRegistrationEntity copyWith({EventRegistration? entity}) {
    return EventRegistrationEntity(entity: entity ?? this.entity);
  }

  EventRegistrationEntity copyWithWrapped({
    Wrapped<EventRegistration?>? entity,
  }) {
    return EventRegistrationEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationEntityRes {
  const EventRegistrationEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory EventRegistrationEntityRes.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationEntityResFromJson(json);

  static const toJsonFactory = _$EventRegistrationEntityResToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final EventRegistration? entity;
  static const fromJsonFactory = _$EventRegistrationEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $EventRegistrationEntityResExtension on EventRegistrationEntityRes {
  EventRegistrationEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    EventRegistration? entity,
  }) {
    return EventRegistrationEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  EventRegistrationEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<EventRegistration?>? entity,
  }) {
    return EventRegistrationEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationArray {
  const EventRegistrationArray({this.values});

  factory EventRegistrationArray.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationArrayFromJson(json);

  static const toJsonFactory = _$EventRegistrationArrayToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <EventRegistration>[],
  )
  final List<EventRegistration>? values;
  static const fromJsonFactory = _$EventRegistrationArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $EventRegistrationArrayExtension on EventRegistrationArray {
  EventRegistrationArray copyWith({List<EventRegistration>? values}) {
    return EventRegistrationArray(values: values ?? this.values);
  }

  EventRegistrationArray copyWithWrapped({
    Wrapped<List<EventRegistration>?>? values,
  }) {
    return EventRegistrationArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationArrayRes {
  const EventRegistrationArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory EventRegistrationArrayRes.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationArrayResFromJson(json);

  static const toJsonFactory = _$EventRegistrationArrayResToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <EventRegistration>[],
  )
  final List<EventRegistration>? values;
  static const fromJsonFactory = _$EventRegistrationArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $EventRegistrationArrayResExtension on EventRegistrationArrayRes {
  EventRegistrationArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<EventRegistration>? values,
  }) {
    return EventRegistrationArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  EventRegistrationArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<EventRegistration>?>? values,
  }) {
    return EventRegistrationArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredEvent {
  const TriggeredEvent({
    required this.eventId,
    this.modelId,
    this.deviceId,
    this.hardwareDeviceId,
    this.notificationTitle,
    this.notificationContent,
    this.emailSubject,
    this.emailContent,
    this.smsMessage,
    this.fcmTitle,
    this.fcmContent,
    this.voiceMessage,
    this.icon,
    this.userId,
    required this.eventType,
    this.deliveryStatus,
    this.deliveryErrors,
    this.deviceIcon,
    this.domainKey,
    this.id,
    this.name,
    this.rtype,
    this.createdStamp,
    this.createdBy,
    this.updatedBy,
    this.updatedStamp,
    this.tags,
    this.modelName,
    this.deviceName,
    this.assetId,
    this.assetName,
    this.premiseId,
    this.premiseName,
    this.facilityId,
    this.facilityName,
    this.floorId,
    this.floorName,
    this.sourceType,
  });

  factory TriggeredEvent.fromJson(Map<String, dynamic> json) =>
      _$TriggeredEventFromJson(json);

  static const toJsonFactory = _$TriggeredEventToJson;
  Map<String, dynamic> toJson() => _$TriggeredEventToJson(this);

  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String eventId;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String? hardwareDeviceId;
  @JsonKey(name: 'notificationTitle', includeIfNull: false, defaultValue: '')
  final String? notificationTitle;
  @JsonKey(name: 'notificationContent', includeIfNull: false, defaultValue: '')
  final String? notificationContent;
  @JsonKey(name: 'emailSubject', includeIfNull: false, defaultValue: '')
  final String? emailSubject;
  @JsonKey(name: 'emailContent', includeIfNull: false, defaultValue: '')
  final String? emailContent;
  @JsonKey(name: 'smsMessage', includeIfNull: false, defaultValue: '')
  final String? smsMessage;
  @JsonKey(name: 'fcmTitle', includeIfNull: false, defaultValue: '')
  final String? fcmTitle;
  @JsonKey(name: 'fcmContent', includeIfNull: false, defaultValue: '')
  final String? fcmContent;
  @JsonKey(name: 'voiceMessage', includeIfNull: false, defaultValue: '')
  final String? voiceMessage;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String? userId;
  @JsonKey(
    name: 'eventType',
    includeIfNull: false,
    toJson: triggeredEventEventTypeToJson,
    fromJson: triggeredEventEventTypeFromJson,
  )
  final enums.TriggeredEventEventType eventType;
  @JsonKey(
    name: 'deliveryStatus',
    includeIfNull: false,
    toJson: triggeredEventDeliveryStatusNullableToJson,
    fromJson: triggeredEventDeliveryStatusNullableFromJson,
  )
  final enums.TriggeredEventDeliveryStatus? deliveryStatus;
  @JsonKey(
    name: 'deliveryErrors',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String>? deliveryErrors;
  @JsonKey(name: 'deviceIcon', includeIfNull: false, defaultValue: '')
  final String? deviceIcon;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String? rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int? createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String? createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String? updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int? updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'modelName', includeIfNull: false, defaultValue: '')
  final String? modelName;
  @JsonKey(name: 'deviceName', includeIfNull: false, defaultValue: '')
  final String? deviceName;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'assetName', includeIfNull: false, defaultValue: '')
  final String? assetName;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'premiseName', includeIfNull: false, defaultValue: '')
  final String? premiseName;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'facilityName', includeIfNull: false, defaultValue: '')
  final String? facilityName;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'floorName', includeIfNull: false, defaultValue: '')
  final String? floorName;
  @JsonKey(
    name: 'sourceType',
    includeIfNull: false,
    toJson: triggeredEventSourceTypeNullableToJson,
    fromJson: triggeredEventSourceTypeNullableFromJson,
  )
  final enums.TriggeredEventSourceType? sourceType;
  static const fromJsonFactory = _$TriggeredEventFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredEvent &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality().equals(
                  other.deviceId,
                  deviceId,
                )) &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality().equals(
                  other.hardwareDeviceId,
                  hardwareDeviceId,
                )) &&
            (identical(other.notificationTitle, notificationTitle) ||
                const DeepCollectionEquality().equals(
                  other.notificationTitle,
                  notificationTitle,
                )) &&
            (identical(other.notificationContent, notificationContent) ||
                const DeepCollectionEquality().equals(
                  other.notificationContent,
                  notificationContent,
                )) &&
            (identical(other.emailSubject, emailSubject) ||
                const DeepCollectionEquality().equals(
                  other.emailSubject,
                  emailSubject,
                )) &&
            (identical(other.emailContent, emailContent) ||
                const DeepCollectionEquality().equals(
                  other.emailContent,
                  emailContent,
                )) &&
            (identical(other.smsMessage, smsMessage) ||
                const DeepCollectionEquality().equals(
                  other.smsMessage,
                  smsMessage,
                )) &&
            (identical(other.fcmTitle, fcmTitle) ||
                const DeepCollectionEquality().equals(
                  other.fcmTitle,
                  fcmTitle,
                )) &&
            (identical(other.fcmContent, fcmContent) ||
                const DeepCollectionEquality().equals(
                  other.fcmContent,
                  fcmContent,
                )) &&
            (identical(other.voiceMessage, voiceMessage) ||
                const DeepCollectionEquality().equals(
                  other.voiceMessage,
                  voiceMessage,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality().equals(
                  other.eventType,
                  eventType,
                )) &&
            (identical(other.deliveryStatus, deliveryStatus) ||
                const DeepCollectionEquality().equals(
                  other.deliveryStatus,
                  deliveryStatus,
                )) &&
            (identical(other.deliveryErrors, deliveryErrors) ||
                const DeepCollectionEquality().equals(
                  other.deliveryErrors,
                  deliveryErrors,
                )) &&
            (identical(other.deviceIcon, deviceIcon) ||
                const DeepCollectionEquality().equals(
                  other.deviceIcon,
                  deviceIcon,
                )) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.modelName, modelName) ||
                const DeepCollectionEquality().equals(
                  other.modelName,
                  modelName,
                )) &&
            (identical(other.deviceName, deviceName) ||
                const DeepCollectionEquality().equals(
                  other.deviceName,
                  deviceName,
                )) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality().equals(
                  other.assetId,
                  assetId,
                )) &&
            (identical(other.assetName, assetName) ||
                const DeepCollectionEquality().equals(
                  other.assetName,
                  assetName,
                )) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.premiseName, premiseName) ||
                const DeepCollectionEquality().equals(
                  other.premiseName,
                  premiseName,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.facilityName, facilityName) ||
                const DeepCollectionEquality().equals(
                  other.facilityName,
                  facilityName,
                )) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality().equals(
                  other.floorId,
                  floorId,
                )) &&
            (identical(other.floorName, floorName) ||
                const DeepCollectionEquality().equals(
                  other.floorName,
                  floorName,
                )) &&
            (identical(other.sourceType, sourceType) ||
                const DeepCollectionEquality().equals(
                  other.sourceType,
                  sourceType,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      const DeepCollectionEquality().hash(notificationTitle) ^
      const DeepCollectionEquality().hash(notificationContent) ^
      const DeepCollectionEquality().hash(emailSubject) ^
      const DeepCollectionEquality().hash(emailContent) ^
      const DeepCollectionEquality().hash(smsMessage) ^
      const DeepCollectionEquality().hash(fcmTitle) ^
      const DeepCollectionEquality().hash(fcmContent) ^
      const DeepCollectionEquality().hash(voiceMessage) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(deliveryStatus) ^
      const DeepCollectionEquality().hash(deliveryErrors) ^
      const DeepCollectionEquality().hash(deviceIcon) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(modelName) ^
      const DeepCollectionEquality().hash(deviceName) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(assetName) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(premiseName) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(facilityName) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(floorName) ^
      const DeepCollectionEquality().hash(sourceType) ^
      runtimeType.hashCode;
}

extension $TriggeredEventExtension on TriggeredEvent {
  TriggeredEvent copyWith({
    String? eventId,
    String? modelId,
    String? deviceId,
    String? hardwareDeviceId,
    String? notificationTitle,
    String? notificationContent,
    String? emailSubject,
    String? emailContent,
    String? smsMessage,
    String? fcmTitle,
    String? fcmContent,
    String? voiceMessage,
    String? icon,
    String? userId,
    enums.TriggeredEventEventType? eventType,
    enums.TriggeredEventDeliveryStatus? deliveryStatus,
    List<String>? deliveryErrors,
    String? deviceIcon,
    String? domainKey,
    String? id,
    String? name,
    String? rtype,
    int? createdStamp,
    String? createdBy,
    String? updatedBy,
    int? updatedStamp,
    List<String>? tags,
    String? modelName,
    String? deviceName,
    String? assetId,
    String? assetName,
    String? premiseId,
    String? premiseName,
    String? facilityId,
    String? facilityName,
    String? floorId,
    String? floorName,
    enums.TriggeredEventSourceType? sourceType,
  }) {
    return TriggeredEvent(
      eventId: eventId ?? this.eventId,
      modelId: modelId ?? this.modelId,
      deviceId: deviceId ?? this.deviceId,
      hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId,
      notificationTitle: notificationTitle ?? this.notificationTitle,
      notificationContent: notificationContent ?? this.notificationContent,
      emailSubject: emailSubject ?? this.emailSubject,
      emailContent: emailContent ?? this.emailContent,
      smsMessage: smsMessage ?? this.smsMessage,
      fcmTitle: fcmTitle ?? this.fcmTitle,
      fcmContent: fcmContent ?? this.fcmContent,
      voiceMessage: voiceMessage ?? this.voiceMessage,
      icon: icon ?? this.icon,
      userId: userId ?? this.userId,
      eventType: eventType ?? this.eventType,
      deliveryStatus: deliveryStatus ?? this.deliveryStatus,
      deliveryErrors: deliveryErrors ?? this.deliveryErrors,
      deviceIcon: deviceIcon ?? this.deviceIcon,
      domainKey: domainKey ?? this.domainKey,
      id: id ?? this.id,
      name: name ?? this.name,
      rtype: rtype ?? this.rtype,
      createdStamp: createdStamp ?? this.createdStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      tags: tags ?? this.tags,
      modelName: modelName ?? this.modelName,
      deviceName: deviceName ?? this.deviceName,
      assetId: assetId ?? this.assetId,
      assetName: assetName ?? this.assetName,
      premiseId: premiseId ?? this.premiseId,
      premiseName: premiseName ?? this.premiseName,
      facilityId: facilityId ?? this.facilityId,
      facilityName: facilityName ?? this.facilityName,
      floorId: floorId ?? this.floorId,
      floorName: floorName ?? this.floorName,
      sourceType: sourceType ?? this.sourceType,
    );
  }

  TriggeredEvent copyWithWrapped({
    Wrapped<String>? eventId,
    Wrapped<String?>? modelId,
    Wrapped<String?>? deviceId,
    Wrapped<String?>? hardwareDeviceId,
    Wrapped<String?>? notificationTitle,
    Wrapped<String?>? notificationContent,
    Wrapped<String?>? emailSubject,
    Wrapped<String?>? emailContent,
    Wrapped<String?>? smsMessage,
    Wrapped<String?>? fcmTitle,
    Wrapped<String?>? fcmContent,
    Wrapped<String?>? voiceMessage,
    Wrapped<String?>? icon,
    Wrapped<String?>? userId,
    Wrapped<enums.TriggeredEventEventType>? eventType,
    Wrapped<enums.TriggeredEventDeliveryStatus?>? deliveryStatus,
    Wrapped<List<String>?>? deliveryErrors,
    Wrapped<String?>? deviceIcon,
    Wrapped<String?>? domainKey,
    Wrapped<String?>? id,
    Wrapped<String?>? name,
    Wrapped<String?>? rtype,
    Wrapped<int?>? createdStamp,
    Wrapped<String?>? createdBy,
    Wrapped<String?>? updatedBy,
    Wrapped<int?>? updatedStamp,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? modelName,
    Wrapped<String?>? deviceName,
    Wrapped<String?>? assetId,
    Wrapped<String?>? assetName,
    Wrapped<String?>? premiseId,
    Wrapped<String?>? premiseName,
    Wrapped<String?>? facilityId,
    Wrapped<String?>? facilityName,
    Wrapped<String?>? floorId,
    Wrapped<String?>? floorName,
    Wrapped<enums.TriggeredEventSourceType?>? sourceType,
  }) {
    return TriggeredEvent(
      eventId: (eventId != null ? eventId.value : this.eventId),
      modelId: (modelId != null ? modelId.value : this.modelId),
      deviceId: (deviceId != null ? deviceId.value : this.deviceId),
      hardwareDeviceId: (hardwareDeviceId != null
          ? hardwareDeviceId.value
          : this.hardwareDeviceId),
      notificationTitle: (notificationTitle != null
          ? notificationTitle.value
          : this.notificationTitle),
      notificationContent: (notificationContent != null
          ? notificationContent.value
          : this.notificationContent),
      emailSubject: (emailSubject != null
          ? emailSubject.value
          : this.emailSubject),
      emailContent: (emailContent != null
          ? emailContent.value
          : this.emailContent),
      smsMessage: (smsMessage != null ? smsMessage.value : this.smsMessage),
      fcmTitle: (fcmTitle != null ? fcmTitle.value : this.fcmTitle),
      fcmContent: (fcmContent != null ? fcmContent.value : this.fcmContent),
      voiceMessage: (voiceMessage != null
          ? voiceMessage.value
          : this.voiceMessage),
      icon: (icon != null ? icon.value : this.icon),
      userId: (userId != null ? userId.value : this.userId),
      eventType: (eventType != null ? eventType.value : this.eventType),
      deliveryStatus: (deliveryStatus != null
          ? deliveryStatus.value
          : this.deliveryStatus),
      deliveryErrors: (deliveryErrors != null
          ? deliveryErrors.value
          : this.deliveryErrors),
      deviceIcon: (deviceIcon != null ? deviceIcon.value : this.deviceIcon),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      rtype: (rtype != null ? rtype.value : this.rtype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      tags: (tags != null ? tags.value : this.tags),
      modelName: (modelName != null ? modelName.value : this.modelName),
      deviceName: (deviceName != null ? deviceName.value : this.deviceName),
      assetId: (assetId != null ? assetId.value : this.assetId),
      assetName: (assetName != null ? assetName.value : this.assetName),
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      premiseName: (premiseName != null ? premiseName.value : this.premiseName),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      facilityName: (facilityName != null
          ? facilityName.value
          : this.facilityName),
      floorId: (floorId != null ? floorId.value : this.floorId),
      floorName: (floorName != null ? floorName.value : this.floorName),
      sourceType: (sourceType != null ? sourceType.value : this.sourceType),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredEventArray {
  const TriggeredEventArray({this.values});

  factory TriggeredEventArray.fromJson(Map<String, dynamic> json) =>
      _$TriggeredEventArrayFromJson(json);

  static const toJsonFactory = _$TriggeredEventArrayToJson;
  Map<String, dynamic> toJson() => _$TriggeredEventArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <TriggeredEvent>[],
  )
  final List<TriggeredEvent>? values;
  static const fromJsonFactory = _$TriggeredEventArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredEventArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TriggeredEventArrayExtension on TriggeredEventArray {
  TriggeredEventArray copyWith({List<TriggeredEvent>? values}) {
    return TriggeredEventArray(values: values ?? this.values);
  }

  TriggeredEventArray copyWithWrapped({
    Wrapped<List<TriggeredEvent>?>? values,
  }) {
    return TriggeredEventArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredEventArrayRes {
  const TriggeredEventArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TriggeredEventArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TriggeredEventArrayResFromJson(json);

  static const toJsonFactory = _$TriggeredEventArrayResToJson;
  Map<String, dynamic> toJson() => _$TriggeredEventArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <TriggeredEvent>[],
  )
  final List<TriggeredEvent>? values;
  static const fromJsonFactory = _$TriggeredEventArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredEventArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TriggeredEventArrayResExtension on TriggeredEventArrayRes {
  TriggeredEventArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<TriggeredEvent>? values,
  }) {
    return TriggeredEventArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  TriggeredEventArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<TriggeredEvent>?>? values,
  }) {
    return TriggeredEventArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredControlArray {
  const TriggeredControlArray({this.values});

  factory TriggeredControlArray.fromJson(Map<String, dynamic> json) =>
      _$TriggeredControlArrayFromJson(json);

  static const toJsonFactory = _$TriggeredControlArrayToJson;
  Map<String, dynamic> toJson() => _$TriggeredControlArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <TriggeredControl>[],
  )
  final List<TriggeredControl>? values;
  static const fromJsonFactory = _$TriggeredControlArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredControlArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TriggeredControlArrayExtension on TriggeredControlArray {
  TriggeredControlArray copyWith({List<TriggeredControl>? values}) {
    return TriggeredControlArray(values: values ?? this.values);
  }

  TriggeredControlArray copyWithWrapped({
    Wrapped<List<TriggeredControl>?>? values,
  }) {
    return TriggeredControlArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredControlArrayRes {
  const TriggeredControlArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TriggeredControlArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TriggeredControlArrayResFromJson(json);

  static const toJsonFactory = _$TriggeredControlArrayResToJson;
  Map<String, dynamic> toJson() => _$TriggeredControlArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <TriggeredControl>[],
  )
  final List<TriggeredControl>? values;
  static const fromJsonFactory = _$TriggeredControlArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredControlArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TriggeredControlArrayResExtension on TriggeredControlArrayRes {
  TriggeredControlArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<TriggeredControl>? values,
  }) {
    return TriggeredControlArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  TriggeredControlArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<TriggeredControl>?>? values,
  }) {
    return TriggeredControlArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DomainEntity {
  const DomainEntity({this.entity});

  factory DomainEntity.fromJson(Map<String, dynamic> json) =>
      _$DomainEntityFromJson(json);

  static const toJsonFactory = _$DomainEntityToJson;
  Map<String, dynamic> toJson() => _$DomainEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Domain? entity;
  static const fromJsonFactory = _$DomainEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DomainEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DomainEntityExtension on DomainEntity {
  DomainEntity copyWith({Domain? entity}) {
    return DomainEntity(entity: entity ?? this.entity);
  }

  DomainEntity copyWithWrapped({Wrapped<Domain?>? entity}) {
    return DomainEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DomainEntityRes {
  const DomainEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DomainEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DomainEntityResFromJson(json);

  static const toJsonFactory = _$DomainEntityResToJson;
  Map<String, dynamic> toJson() => _$DomainEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Domain? entity;
  static const fromJsonFactory = _$DomainEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DomainEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DomainEntityResExtension on DomainEntityRes {
  DomainEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Domain? entity,
  }) {
    return DomainEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DomainEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Domain?>? entity,
  }) {
    return DomainEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LoginResBase {
  const LoginResBase({this.accounts});

  factory LoginResBase.fromJson(Map<String, dynamic> json) =>
      _$LoginResBaseFromJson(json);

  static const toJsonFactory = _$LoginResBaseToJson;
  Map<String, dynamic> toJson() => _$LoginResBaseToJson(this);

  @JsonKey(name: 'accounts', includeIfNull: false, defaultValue: <UserInfo>[])
  final List<UserInfo>? accounts;
  static const fromJsonFactory = _$LoginResBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LoginResBase &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality().equals(
                  other.accounts,
                  accounts,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^ runtimeType.hashCode;
}

extension $LoginResBaseExtension on LoginResBase {
  LoginResBase copyWith({List<UserInfo>? accounts}) {
    return LoginResBase(accounts: accounts ?? this.accounts);
  }

  LoginResBase copyWithWrapped({Wrapped<List<UserInfo>?>? accounts}) {
    return LoginResBase(
      accounts: (accounts != null ? accounts.value : this.accounts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LoginRes {
  const LoginRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.accounts,
  });

  factory LoginRes.fromJson(Map<String, dynamic> json) =>
      _$LoginResFromJson(json);

  static const toJsonFactory = _$LoginResToJson;
  Map<String, dynamic> toJson() => _$LoginResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'accounts', includeIfNull: false, defaultValue: <UserInfo>[])
  final List<UserInfo>? accounts;
  static const fromJsonFactory = _$LoginResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LoginRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality().equals(
                  other.accounts,
                  accounts,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(accounts) ^
      runtimeType.hashCode;
}

extension $LoginResExtension on LoginRes {
  LoginRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    List<UserInfo>? accounts,
  }) {
    return LoginRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      accounts: accounts ?? this.accounts,
    );
  }

  LoginRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<List<UserInfo>?>? accounts,
  }) {
    return LoginRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      accounts: (accounts != null ? accounts.value : this.accounts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetInfo {
  const DisplayWidgetInfo({
    required this.name,
    this.description,
    this.label,
    required this.modelId,
    this.tags,
    this.tooltip,
    required this.widgetType,
    required this.attributes,
  });

  factory DisplayWidgetInfo.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetInfoFromJson(json);

  static const toJsonFactory = _$DisplayWidgetInfoToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'widgetType', includeIfNull: false, defaultValue: '')
  final String widgetType;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  static const fromJsonFactory = _$DisplayWidgetInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(
                  other.tooltip,
                  tooltip,
                )) &&
            (identical(other.widgetType, widgetType) ||
                const DeepCollectionEquality().equals(
                  other.widgetType,
                  widgetType,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(widgetType) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $DisplayWidgetInfoExtension on DisplayWidgetInfo {
  DisplayWidgetInfo copyWith({
    String? name,
    String? description,
    String? label,
    String? modelId,
    List<String>? tags,
    String? tooltip,
    String? widgetType,
    Object? attributes,
  }) {
    return DisplayWidgetInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      modelId: modelId ?? this.modelId,
      tags: tags ?? this.tags,
      tooltip: tooltip ?? this.tooltip,
      widgetType: widgetType ?? this.widgetType,
      attributes: attributes ?? this.attributes,
    );
  }

  DisplayWidgetInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<String>? modelId,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? tooltip,
    Wrapped<String>? widgetType,
    Wrapped<Object>? attributes,
  }) {
    return DisplayWidgetInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      modelId: (modelId != null ? modelId.value : this.modelId),
      tags: (tags != null ? tags.value : this.tags),
      tooltip: (tooltip != null ? tooltip.value : this.tooltip),
      widgetType: (widgetType != null ? widgetType.value : this.widgetType),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidget {
  const DisplayWidget({
    required this.name,
    this.description,
    this.label,
    required this.modelId,
    this.tags,
    this.tooltip,
    required this.widgetType,
    required this.attributes,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory DisplayWidget.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetFromJson(json);

  static const toJsonFactory = _$DisplayWidgetToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'widgetType', includeIfNull: false, defaultValue: '')
  final String widgetType;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$DisplayWidgetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidget &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(
                  other.tooltip,
                  tooltip,
                )) &&
            (identical(other.widgetType, widgetType) ||
                const DeepCollectionEquality().equals(
                  other.widgetType,
                  widgetType,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(widgetType) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $DisplayWidgetExtension on DisplayWidget {
  DisplayWidget copyWith({
    String? name,
    String? description,
    String? label,
    String? modelId,
    List<String>? tags,
    String? tooltip,
    String? widgetType,
    Object? attributes,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return DisplayWidget(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      modelId: modelId ?? this.modelId,
      tags: tags ?? this.tags,
      tooltip: tooltip ?? this.tooltip,
      widgetType: widgetType ?? this.widgetType,
      attributes: attributes ?? this.attributes,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  DisplayWidget copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<String>? modelId,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? tooltip,
    Wrapped<String>? widgetType,
    Wrapped<Object>? attributes,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return DisplayWidget(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      modelId: (modelId != null ? modelId.value : this.modelId),
      tags: (tags != null ? tags.value : this.tags),
      tooltip: (tooltip != null ? tooltip.value : this.tooltip),
      widgetType: (widgetType != null ? widgetType.value : this.widgetType),
      attributes: (attributes != null ? attributes.value : this.attributes),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetEntity {
  const DisplayWidgetEntity({this.entity});

  factory DisplayWidgetEntity.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetEntityFromJson(json);

  static const toJsonFactory = _$DisplayWidgetEntityToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DisplayWidget? entity;
  static const fromJsonFactory = _$DisplayWidgetEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DisplayWidgetEntityExtension on DisplayWidgetEntity {
  DisplayWidgetEntity copyWith({DisplayWidget? entity}) {
    return DisplayWidgetEntity(entity: entity ?? this.entity);
  }

  DisplayWidgetEntity copyWithWrapped({Wrapped<DisplayWidget?>? entity}) {
    return DisplayWidgetEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetEntityRes {
  const DisplayWidgetEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DisplayWidgetEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetEntityResFromJson(json);

  static const toJsonFactory = _$DisplayWidgetEntityResToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DisplayWidget? entity;
  static const fromJsonFactory = _$DisplayWidgetEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DisplayWidgetEntityResExtension on DisplayWidgetEntityRes {
  DisplayWidgetEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    DisplayWidget? entity,
  }) {
    return DisplayWidgetEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DisplayWidgetEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<DisplayWidget?>? entity,
  }) {
    return DisplayWidgetEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetArray {
  const DisplayWidgetArray({this.values});

  factory DisplayWidgetArray.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetArrayFromJson(json);

  static const toJsonFactory = _$DisplayWidgetArrayToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <DisplayWidget>[],
  )
  final List<DisplayWidget>? values;
  static const fromJsonFactory = _$DisplayWidgetArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DisplayWidgetArrayExtension on DisplayWidgetArray {
  DisplayWidgetArray copyWith({List<DisplayWidget>? values}) {
    return DisplayWidgetArray(values: values ?? this.values);
  }

  DisplayWidgetArray copyWithWrapped({Wrapped<List<DisplayWidget>?>? values}) {
    return DisplayWidgetArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetArrayRes {
  const DisplayWidgetArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DisplayWidgetArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetArrayResFromJson(json);

  static const toJsonFactory = _$DisplayWidgetArrayResToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <DisplayWidget>[],
  )
  final List<DisplayWidget>? values;
  static const fromJsonFactory = _$DisplayWidgetArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DisplayWidgetArrayResExtension on DisplayWidgetArrayRes {
  DisplayWidgetArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<DisplayWidget>? values,
  }) {
    return DisplayWidgetArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DisplayWidgetArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<DisplayWidget>?>? values,
  }) {
    return DisplayWidgetArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetInfo {
  const ScreenWidgetInfo({
    required this.name,
    this.description,
    this.label,
    this.tags,
    this.tooltip,
    required this.widgetType,
    required this.attributes,
    this.target,
  });

  factory ScreenWidgetInfo.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetInfoFromJson(json);

  static const toJsonFactory = _$ScreenWidgetInfoToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'widgetType', includeIfNull: false, defaultValue: '')
  final String widgetType;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: screenWidgetInfoTargetNullableToJson,
    fromJson: screenWidgetInfoTargetNullableFromJson,
  )
  final enums.ScreenWidgetInfoTarget? target;
  static const fromJsonFactory = _$ScreenWidgetInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(
                  other.tooltip,
                  tooltip,
                )) &&
            (identical(other.widgetType, widgetType) ||
                const DeepCollectionEquality().equals(
                  other.widgetType,
                  widgetType,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(widgetType) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(target) ^
      runtimeType.hashCode;
}

extension $ScreenWidgetInfoExtension on ScreenWidgetInfo {
  ScreenWidgetInfo copyWith({
    String? name,
    String? description,
    String? label,
    List<String>? tags,
    String? tooltip,
    String? widgetType,
    Object? attributes,
    enums.ScreenWidgetInfoTarget? target,
  }) {
    return ScreenWidgetInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      tags: tags ?? this.tags,
      tooltip: tooltip ?? this.tooltip,
      widgetType: widgetType ?? this.widgetType,
      attributes: attributes ?? this.attributes,
      target: target ?? this.target,
    );
  }

  ScreenWidgetInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? tooltip,
    Wrapped<String>? widgetType,
    Wrapped<Object>? attributes,
    Wrapped<enums.ScreenWidgetInfoTarget?>? target,
  }) {
    return ScreenWidgetInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      tags: (tags != null ? tags.value : this.tags),
      tooltip: (tooltip != null ? tooltip.value : this.tooltip),
      widgetType: (widgetType != null ? widgetType.value : this.widgetType),
      attributes: (attributes != null ? attributes.value : this.attributes),
      target: (target != null ? target.value : this.target),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidget {
  const ScreenWidget({
    required this.name,
    this.description,
    this.label,
    this.tags,
    this.tooltip,
    required this.widgetType,
    required this.attributes,
    this.target,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory ScreenWidget.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetFromJson(json);

  static const toJsonFactory = _$ScreenWidgetToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'widgetType', includeIfNull: false, defaultValue: '')
  final String widgetType;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: screenWidgetTargetNullableToJson,
    fromJson: screenWidgetTargetNullableFromJson,
  )
  final enums.ScreenWidgetTarget? target;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$ScreenWidgetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidget &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(
                  other.tooltip,
                  tooltip,
                )) &&
            (identical(other.widgetType, widgetType) ||
                const DeepCollectionEquality().equals(
                  other.widgetType,
                  widgetType,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(widgetType) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $ScreenWidgetExtension on ScreenWidget {
  ScreenWidget copyWith({
    String? name,
    String? description,
    String? label,
    List<String>? tags,
    String? tooltip,
    String? widgetType,
    Object? attributes,
    enums.ScreenWidgetTarget? target,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return ScreenWidget(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      tags: tags ?? this.tags,
      tooltip: tooltip ?? this.tooltip,
      widgetType: widgetType ?? this.widgetType,
      attributes: attributes ?? this.attributes,
      target: target ?? this.target,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  ScreenWidget copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? tooltip,
    Wrapped<String>? widgetType,
    Wrapped<Object>? attributes,
    Wrapped<enums.ScreenWidgetTarget?>? target,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return ScreenWidget(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      tags: (tags != null ? tags.value : this.tags),
      tooltip: (tooltip != null ? tooltip.value : this.tooltip),
      widgetType: (widgetType != null ? widgetType.value : this.widgetType),
      attributes: (attributes != null ? attributes.value : this.attributes),
      target: (target != null ? target.value : this.target),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetEntity {
  const ScreenWidgetEntity({this.entity});

  factory ScreenWidgetEntity.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetEntityFromJson(json);

  static const toJsonFactory = _$ScreenWidgetEntityToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ScreenWidget? entity;
  static const fromJsonFactory = _$ScreenWidgetEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ScreenWidgetEntityExtension on ScreenWidgetEntity {
  ScreenWidgetEntity copyWith({ScreenWidget? entity}) {
    return ScreenWidgetEntity(entity: entity ?? this.entity);
  }

  ScreenWidgetEntity copyWithWrapped({Wrapped<ScreenWidget?>? entity}) {
    return ScreenWidgetEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetEntityRes {
  const ScreenWidgetEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ScreenWidgetEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetEntityResFromJson(json);

  static const toJsonFactory = _$ScreenWidgetEntityResToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final ScreenWidget? entity;
  static const fromJsonFactory = _$ScreenWidgetEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ScreenWidgetEntityResExtension on ScreenWidgetEntityRes {
  ScreenWidgetEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    ScreenWidget? entity,
  }) {
    return ScreenWidgetEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  ScreenWidgetEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<ScreenWidget?>? entity,
  }) {
    return ScreenWidgetEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetArray {
  const ScreenWidgetArray({this.values});

  factory ScreenWidgetArray.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetArrayFromJson(json);

  static const toJsonFactory = _$ScreenWidgetArrayToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <ScreenWidget>[])
  final List<ScreenWidget>? values;
  static const fromJsonFactory = _$ScreenWidgetArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ScreenWidgetArrayExtension on ScreenWidgetArray {
  ScreenWidgetArray copyWith({List<ScreenWidget>? values}) {
    return ScreenWidgetArray(values: values ?? this.values);
  }

  ScreenWidgetArray copyWithWrapped({Wrapped<List<ScreenWidget>?>? values}) {
    return ScreenWidgetArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetArrayRes {
  const ScreenWidgetArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ScreenWidgetArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetArrayResFromJson(json);

  static const toJsonFactory = _$ScreenWidgetArrayResToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <ScreenWidget>[])
  final List<ScreenWidget>? values;
  static const fromJsonFactory = _$ScreenWidgetArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ScreenWidgetArrayResExtension on ScreenWidgetArrayRes {
  ScreenWidgetArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<ScreenWidget>? values,
  }) {
    return ScreenWidgetArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  ScreenWidgetArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<ScreenWidget>?>? values,
  }) {
    return ScreenWidgetArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoLocation {
  const GeoLocation({this.type, required this.coordinates});

  factory GeoLocation.fromJson(Map<String, dynamic> json) =>
      _$GeoLocationFromJson(json);

  static const toJsonFactory = _$GeoLocationToJson;
  Map<String, dynamic> toJson() => _$GeoLocationToJson(this);

  @JsonKey(name: 'type', includeIfNull: false, defaultValue: '')
  final String? type;
  @JsonKey(name: 'coordinates', includeIfNull: false, defaultValue: <double>[])
  final List<double> coordinates;
  static const fromJsonFactory = _$GeoLocationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoLocation &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.coordinates, coordinates) ||
                const DeepCollectionEquality().equals(
                  other.coordinates,
                  coordinates,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(coordinates) ^
      runtimeType.hashCode;
}

extension $GeoLocationExtension on GeoLocation {
  GeoLocation copyWith({String? type, List<double>? coordinates}) {
    return GeoLocation(
      type: type ?? this.type,
      coordinates: coordinates ?? this.coordinates,
    );
  }

  GeoLocation copyWithWrapped({
    Wrapped<String?>? type,
    Wrapped<List<double>>? coordinates,
  }) {
    return GeoLocation(
      type: (type != null ? type.value : this.type),
      coordinates: (coordinates != null ? coordinates.value : this.coordinates),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoLine {
  const GeoLine({required this.begin, required this.end});

  factory GeoLine.fromJson(Map<String, dynamic> json) =>
      _$GeoLineFromJson(json);

  static const toJsonFactory = _$GeoLineToJson;
  Map<String, dynamic> toJson() => _$GeoLineToJson(this);

  @JsonKey(name: 'begin', includeIfNull: false)
  final GeoLocation begin;
  @JsonKey(name: 'end', includeIfNull: false)
  final GeoLocation end;
  static const fromJsonFactory = _$GeoLineFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoLine &&
            (identical(other.begin, begin) ||
                const DeepCollectionEquality().equals(other.begin, begin)) &&
            (identical(other.end, end) ||
                const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(begin) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $GeoLineExtension on GeoLine {
  GeoLine copyWith({GeoLocation? begin, GeoLocation? end}) {
    return GeoLine(begin: begin ?? this.begin, end: end ?? this.end);
  }

  GeoLine copyWithWrapped({
    Wrapped<GeoLocation>? begin,
    Wrapped<GeoLocation>? end,
  }) {
    return GeoLine(
      begin: (begin != null ? begin.value : this.begin),
      end: (end != null ? end.value : this.end),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoEnvelope {
  const GeoEnvelope({required this.leftTop, required this.rightBottom});

  factory GeoEnvelope.fromJson(Map<String, dynamic> json) =>
      _$GeoEnvelopeFromJson(json);

  static const toJsonFactory = _$GeoEnvelopeToJson;
  Map<String, dynamic> toJson() => _$GeoEnvelopeToJson(this);

  @JsonKey(name: 'leftTop', includeIfNull: false)
  final GeoLocation leftTop;
  @JsonKey(name: 'rightBottom', includeIfNull: false)
  final GeoLocation rightBottom;
  static const fromJsonFactory = _$GeoEnvelopeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoEnvelope &&
            (identical(other.leftTop, leftTop) ||
                const DeepCollectionEquality().equals(
                  other.leftTop,
                  leftTop,
                )) &&
            (identical(other.rightBottom, rightBottom) ||
                const DeepCollectionEquality().equals(
                  other.rightBottom,
                  rightBottom,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(leftTop) ^
      const DeepCollectionEquality().hash(rightBottom) ^
      runtimeType.hashCode;
}

extension $GeoEnvelopeExtension on GeoEnvelope {
  GeoEnvelope copyWith({GeoLocation? leftTop, GeoLocation? rightBottom}) {
    return GeoEnvelope(
      leftTop: leftTop ?? this.leftTop,
      rightBottom: rightBottom ?? this.rightBottom,
    );
  }

  GeoEnvelope copyWithWrapped({
    Wrapped<GeoLocation>? leftTop,
    Wrapped<GeoLocation>? rightBottom,
  }) {
    return GeoEnvelope(
      leftTop: (leftTop != null ? leftTop.value : this.leftTop),
      rightBottom: (rightBottom != null ? rightBottom.value : this.rightBottom),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoPolygon {
  const GeoPolygon({required this.points});

  factory GeoPolygon.fromJson(Map<String, dynamic> json) =>
      _$GeoPolygonFromJson(json);

  static const toJsonFactory = _$GeoPolygonToJson;
  Map<String, dynamic> toJson() => _$GeoPolygonToJson(this);

  @JsonKey(name: 'points', includeIfNull: false, defaultValue: <GeoLocation>[])
  final List<GeoLocation> points;
  static const fromJsonFactory = _$GeoPolygonFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoPolygon &&
            (identical(other.points, points) ||
                const DeepCollectionEquality().equals(other.points, points)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(points) ^ runtimeType.hashCode;
}

extension $GeoPolygonExtension on GeoPolygon {
  GeoPolygon copyWith({List<GeoLocation>? points}) {
    return GeoPolygon(points: points ?? this.points);
  }

  GeoPolygon copyWithWrapped({Wrapped<List<GeoLocation>>? points}) {
    return GeoPolygon(points: (points != null ? points.value : this.points));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoMultiPoint {
  const GeoMultiPoint({required this.first, required this.second});

  factory GeoMultiPoint.fromJson(Map<String, dynamic> json) =>
      _$GeoMultiPointFromJson(json);

  static const toJsonFactory = _$GeoMultiPointToJson;
  Map<String, dynamic> toJson() => _$GeoMultiPointToJson(this);

  @JsonKey(name: 'first', includeIfNull: false)
  final GeoLocation first;
  @JsonKey(name: 'second', includeIfNull: false)
  final GeoLocation second;
  static const fromJsonFactory = _$GeoMultiPointFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoMultiPoint &&
            (identical(other.first, first) ||
                const DeepCollectionEquality().equals(other.first, first)) &&
            (identical(other.second, second) ||
                const DeepCollectionEquality().equals(other.second, second)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(first) ^
      const DeepCollectionEquality().hash(second) ^
      runtimeType.hashCode;
}

extension $GeoMultiPointExtension on GeoMultiPoint {
  GeoMultiPoint copyWith({GeoLocation? first, GeoLocation? second}) {
    return GeoMultiPoint(
      first: first ?? this.first,
      second: second ?? this.second,
    );
  }

  GeoMultiPoint copyWithWrapped({
    Wrapped<GeoLocation>? first,
    Wrapped<GeoLocation>? second,
  }) {
    return GeoMultiPoint(
      first: (first != null ? first.value : this.first),
      second: (second != null ? second.value : this.second),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoMultiLine {
  const GeoMultiLine({required this.points});

  factory GeoMultiLine.fromJson(Map<String, dynamic> json) =>
      _$GeoMultiLineFromJson(json);

  static const toJsonFactory = _$GeoMultiLineToJson;
  Map<String, dynamic> toJson() => _$GeoMultiLineToJson(this);

  @JsonKey(name: 'points', includeIfNull: false, defaultValue: <GeoLine>[])
  final List<GeoLine> points;
  static const fromJsonFactory = _$GeoMultiLineFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoMultiLine &&
            (identical(other.points, points) ||
                const DeepCollectionEquality().equals(other.points, points)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(points) ^ runtimeType.hashCode;
}

extension $GeoMultiLineExtension on GeoMultiLine {
  GeoMultiLine copyWith({List<GeoLine>? points}) {
    return GeoMultiLine(points: points ?? this.points);
  }

  GeoMultiLine copyWithWrapped({Wrapped<List<GeoLine>>? points}) {
    return GeoMultiLine(points: (points != null ? points.value : this.points));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoMultiPolygon {
  const GeoMultiPolygon({required this.points});

  factory GeoMultiPolygon.fromJson(Map<String, dynamic> json) =>
      _$GeoMultiPolygonFromJson(json);

  static const toJsonFactory = _$GeoMultiPolygonToJson;
  Map<String, dynamic> toJson() => _$GeoMultiPolygonToJson(this);

  @JsonKey(name: 'points', includeIfNull: false, defaultValue: <GeoPolygon>[])
  final List<GeoPolygon> points;
  static const fromJsonFactory = _$GeoMultiPolygonFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoMultiPolygon &&
            (identical(other.points, points) ||
                const DeepCollectionEquality().equals(other.points, points)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(points) ^ runtimeType.hashCode;
}

extension $GeoMultiPolygonExtension on GeoMultiPolygon {
  GeoMultiPolygon copyWith({List<GeoPolygon>? points}) {
    return GeoMultiPolygon(points: points ?? this.points);
  }

  GeoMultiPolygon copyWithWrapped({Wrapped<List<GeoPolygon>>? points}) {
    return GeoMultiPolygon(
      points: (points != null ? points.value : this.points),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoCircle {
  const GeoCircle({required this.center, required this.radius});

  factory GeoCircle.fromJson(Map<String, dynamic> json) =>
      _$GeoCircleFromJson(json);

  static const toJsonFactory = _$GeoCircleToJson;
  Map<String, dynamic> toJson() => _$GeoCircleToJson(this);

  @JsonKey(name: 'center', includeIfNull: false)
  final GeoLocation center;
  @JsonKey(name: 'radius', includeIfNull: false)
  final int radius;
  static const fromJsonFactory = _$GeoCircleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoCircle &&
            (identical(other.center, center) ||
                const DeepCollectionEquality().equals(other.center, center)) &&
            (identical(other.radius, radius) ||
                const DeepCollectionEquality().equals(other.radius, radius)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(center) ^
      const DeepCollectionEquality().hash(radius) ^
      runtimeType.hashCode;
}

extension $GeoCircleExtension on GeoCircle {
  GeoCircle copyWith({GeoLocation? center, int? radius}) {
    return GeoCircle(
      center: center ?? this.center,
      radius: radius ?? this.radius,
    );
  }

  GeoCircle copyWithWrapped({
    Wrapped<GeoLocation>? center,
    Wrapped<int>? radius,
  }) {
    return GeoCircle(
      center: (center != null ? center.value : this.center),
      radius: (radius != null ? radius.value : this.radius),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorInfo {
  const PreprocessorInfo({
    required this.name,
    required this.className,
    this.code,
    this.description,
    this.tags,
  });

  factory PreprocessorInfo.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorInfoFromJson(json);

  static const toJsonFactory = _$PreprocessorInfoToJson;
  Map<String, dynamic> toJson() => _$PreprocessorInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'className', includeIfNull: false, defaultValue: '')
  final String className;
  @JsonKey(name: 'code', includeIfNull: false, defaultValue: '')
  final String? code;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$PreprocessorInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.className, className) ||
                const DeepCollectionEquality().equals(
                  other.className,
                  className,
                )) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(className) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $PreprocessorInfoExtension on PreprocessorInfo {
  PreprocessorInfo copyWith({
    String? name,
    String? className,
    String? code,
    String? description,
    List<String>? tags,
  }) {
    return PreprocessorInfo(
      name: name ?? this.name,
      className: className ?? this.className,
      code: code ?? this.code,
      description: description ?? this.description,
      tags: tags ?? this.tags,
    );
  }

  PreprocessorInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? className,
    Wrapped<String?>? code,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
  }) {
    return PreprocessorInfo(
      name: (name != null ? name.value : this.name),
      className: (className != null ? className.value : this.className),
      code: (code != null ? code.value : this.code),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Preprocessor {
  const Preprocessor({
    required this.name,
    required this.className,
    this.code,
    this.description,
    this.tags,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Preprocessor.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorFromJson(json);

  static const toJsonFactory = _$PreprocessorToJson;
  Map<String, dynamic> toJson() => _$PreprocessorToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'className', includeIfNull: false, defaultValue: '')
  final String className;
  @JsonKey(name: 'code', includeIfNull: false, defaultValue: '')
  final String? code;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$PreprocessorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Preprocessor &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.className, className) ||
                const DeepCollectionEquality().equals(
                  other.className,
                  className,
                )) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(className) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $PreprocessorExtension on Preprocessor {
  Preprocessor copyWith({
    String? name,
    String? className,
    String? code,
    String? description,
    List<String>? tags,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Preprocessor(
      name: name ?? this.name,
      className: className ?? this.className,
      code: code ?? this.code,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Preprocessor copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? className,
    Wrapped<String?>? code,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Preprocessor(
      name: (name != null ? name.value : this.name),
      className: (className != null ? className.value : this.className),
      code: (code != null ? code.value : this.code),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorEntity {
  const PreprocessorEntity({this.entity});

  factory PreprocessorEntity.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorEntityFromJson(json);

  static const toJsonFactory = _$PreprocessorEntityToJson;
  Map<String, dynamic> toJson() => _$PreprocessorEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Preprocessor? entity;
  static const fromJsonFactory = _$PreprocessorEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $PreprocessorEntityExtension on PreprocessorEntity {
  PreprocessorEntity copyWith({Preprocessor? entity}) {
    return PreprocessorEntity(entity: entity ?? this.entity);
  }

  PreprocessorEntity copyWithWrapped({Wrapped<Preprocessor?>? entity}) {
    return PreprocessorEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorEntityRes {
  const PreprocessorEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory PreprocessorEntityRes.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorEntityResFromJson(json);

  static const toJsonFactory = _$PreprocessorEntityResToJson;
  Map<String, dynamic> toJson() => _$PreprocessorEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Preprocessor? entity;
  static const fromJsonFactory = _$PreprocessorEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $PreprocessorEntityResExtension on PreprocessorEntityRes {
  PreprocessorEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Preprocessor? entity,
  }) {
    return PreprocessorEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  PreprocessorEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Preprocessor?>? entity,
  }) {
    return PreprocessorEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorArray {
  const PreprocessorArray({this.values});

  factory PreprocessorArray.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorArrayFromJson(json);

  static const toJsonFactory = _$PreprocessorArrayToJson;
  Map<String, dynamic> toJson() => _$PreprocessorArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Preprocessor>[])
  final List<Preprocessor>? values;
  static const fromJsonFactory = _$PreprocessorArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $PreprocessorArrayExtension on PreprocessorArray {
  PreprocessorArray copyWith({List<Preprocessor>? values}) {
    return PreprocessorArray(values: values ?? this.values);
  }

  PreprocessorArray copyWithWrapped({Wrapped<List<Preprocessor>?>? values}) {
    return PreprocessorArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorArrayRes {
  const PreprocessorArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory PreprocessorArrayRes.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorArrayResFromJson(json);

  static const toJsonFactory = _$PreprocessorArrayResToJson;
  Map<String, dynamic> toJson() => _$PreprocessorArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Preprocessor>[])
  final List<Preprocessor>? values;
  static const fromJsonFactory = _$PreprocessorArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $PreprocessorArrayResExtension on PreprocessorArrayRes {
  PreprocessorArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Preprocessor>? values,
  }) {
    return PreprocessorArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  PreprocessorArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Preprocessor>?>? values,
  }) {
    return PreprocessorArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FilterMatchGroup {
  const FilterMatchGroup({required this.matchType, this.conditionIds});

  factory FilterMatchGroup.fromJson(Map<String, dynamic> json) =>
      _$FilterMatchGroupFromJson(json);

  static const toJsonFactory = _$FilterMatchGroupToJson;
  Map<String, dynamic> toJson() => _$FilterMatchGroupToJson(this);

  @JsonKey(
    name: 'matchType',
    includeIfNull: false,
    toJson: filterMatchGroupMatchTypeToJson,
    fromJson: filterMatchGroupMatchTypeFromJson,
  )
  final enums.FilterMatchGroupMatchType matchType;
  @JsonKey(name: 'conditionIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? conditionIds;
  static const fromJsonFactory = _$FilterMatchGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterMatchGroup &&
            (identical(other.matchType, matchType) ||
                const DeepCollectionEquality().equals(
                  other.matchType,
                  matchType,
                )) &&
            (identical(other.conditionIds, conditionIds) ||
                const DeepCollectionEquality().equals(
                  other.conditionIds,
                  conditionIds,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(matchType) ^
      const DeepCollectionEquality().hash(conditionIds) ^
      runtimeType.hashCode;
}

extension $FilterMatchGroupExtension on FilterMatchGroup {
  FilterMatchGroup copyWith({
    enums.FilterMatchGroupMatchType? matchType,
    List<String>? conditionIds,
  }) {
    return FilterMatchGroup(
      matchType: matchType ?? this.matchType,
      conditionIds: conditionIds ?? this.conditionIds,
    );
  }

  FilterMatchGroup copyWithWrapped({
    Wrapped<enums.FilterMatchGroupMatchType>? matchType,
    Wrapped<List<String>?>? conditionIds,
  }) {
    return FilterMatchGroup(
      matchType: (matchType != null ? matchType.value : this.matchType),
      conditionIds: (conditionIds != null
          ? conditionIds.value
          : this.conditionIds),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterInfo {
  const DataFilterInfo({
    this.modelId,
    required this.name,
    required this.label,
    this.icon,
    this.description,
    this.clientId,
    this.tags,
    required this.matchGroups,
    required this.target,
  });

  factory DataFilterInfo.fromJson(Map<String, dynamic> json) =>
      _$DataFilterInfoFromJson(json);

  static const toJsonFactory = _$DataFilterInfoToJson;
  Map<String, dynamic> toJson() => _$DataFilterInfoToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'matchGroups',
    includeIfNull: false,
    defaultValue: <FilterMatchGroup>[],
  )
  final List<FilterMatchGroup> matchGroups;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: dataFilterInfoTargetToJson,
    fromJson: dataFilterInfoTargetFromJson,
  )
  final enums.DataFilterInfoTarget target;
  static const fromJsonFactory = _$DataFilterInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterInfo &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.matchGroups, matchGroups) ||
                const DeepCollectionEquality().equals(
                  other.matchGroups,
                  matchGroups,
                )) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(matchGroups) ^
      const DeepCollectionEquality().hash(target) ^
      runtimeType.hashCode;
}

extension $DataFilterInfoExtension on DataFilterInfo {
  DataFilterInfo copyWith({
    String? modelId,
    String? name,
    String? label,
    String? icon,
    String? description,
    String? clientId,
    List<String>? tags,
    List<FilterMatchGroup>? matchGroups,
    enums.DataFilterInfoTarget? target,
  }) {
    return DataFilterInfo(
      modelId: modelId ?? this.modelId,
      name: name ?? this.name,
      label: label ?? this.label,
      icon: icon ?? this.icon,
      description: description ?? this.description,
      clientId: clientId ?? this.clientId,
      tags: tags ?? this.tags,
      matchGroups: matchGroups ?? this.matchGroups,
      target: target ?? this.target,
    );
  }

  DataFilterInfo copyWithWrapped({
    Wrapped<String?>? modelId,
    Wrapped<String>? name,
    Wrapped<String>? label,
    Wrapped<String?>? icon,
    Wrapped<String?>? description,
    Wrapped<String?>? clientId,
    Wrapped<List<String>?>? tags,
    Wrapped<List<FilterMatchGroup>>? matchGroups,
    Wrapped<enums.DataFilterInfoTarget>? target,
  }) {
    return DataFilterInfo(
      modelId: (modelId != null ? modelId.value : this.modelId),
      name: (name != null ? name.value : this.name),
      label: (label != null ? label.value : this.label),
      icon: (icon != null ? icon.value : this.icon),
      description: (description != null ? description.value : this.description),
      clientId: (clientId != null ? clientId.value : this.clientId),
      tags: (tags != null ? tags.value : this.tags),
      matchGroups: (matchGroups != null ? matchGroups.value : this.matchGroups),
      target: (target != null ? target.value : this.target),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilter {
  const DataFilter({
    this.modelId,
    required this.name,
    required this.label,
    this.icon,
    this.description,
    this.clientId,
    this.tags,
    required this.matchGroups,
    required this.target,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory DataFilter.fromJson(Map<String, dynamic> json) =>
      _$DataFilterFromJson(json);

  static const toJsonFactory = _$DataFilterToJson;
  Map<String, dynamic> toJson() => _$DataFilterToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'matchGroups',
    includeIfNull: false,
    defaultValue: <FilterMatchGroup>[],
  )
  final List<FilterMatchGroup> matchGroups;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: dataFilterTargetToJson,
    fromJson: dataFilterTargetFromJson,
  )
  final enums.DataFilterTarget target;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$DataFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilter &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.matchGroups, matchGroups) ||
                const DeepCollectionEquality().equals(
                  other.matchGroups,
                  matchGroups,
                )) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(matchGroups) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $DataFilterExtension on DataFilter {
  DataFilter copyWith({
    String? modelId,
    String? name,
    String? label,
    String? icon,
    String? description,
    String? clientId,
    List<String>? tags,
    List<FilterMatchGroup>? matchGroups,
    enums.DataFilterTarget? target,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return DataFilter(
      modelId: modelId ?? this.modelId,
      name: name ?? this.name,
      label: label ?? this.label,
      icon: icon ?? this.icon,
      description: description ?? this.description,
      clientId: clientId ?? this.clientId,
      tags: tags ?? this.tags,
      matchGroups: matchGroups ?? this.matchGroups,
      target: target ?? this.target,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  DataFilter copyWithWrapped({
    Wrapped<String?>? modelId,
    Wrapped<String>? name,
    Wrapped<String>? label,
    Wrapped<String?>? icon,
    Wrapped<String?>? description,
    Wrapped<String?>? clientId,
    Wrapped<List<String>?>? tags,
    Wrapped<List<FilterMatchGroup>>? matchGroups,
    Wrapped<enums.DataFilterTarget>? target,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return DataFilter(
      modelId: (modelId != null ? modelId.value : this.modelId),
      name: (name != null ? name.value : this.name),
      label: (label != null ? label.value : this.label),
      icon: (icon != null ? icon.value : this.icon),
      description: (description != null ? description.value : this.description),
      clientId: (clientId != null ? clientId.value : this.clientId),
      tags: (tags != null ? tags.value : this.tags),
      matchGroups: (matchGroups != null ? matchGroups.value : this.matchGroups),
      target: (target != null ? target.value : this.target),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterEntity {
  const DataFilterEntity({this.entity});

  factory DataFilterEntity.fromJson(Map<String, dynamic> json) =>
      _$DataFilterEntityFromJson(json);

  static const toJsonFactory = _$DataFilterEntityToJson;
  Map<String, dynamic> toJson() => _$DataFilterEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DataFilter? entity;
  static const fromJsonFactory = _$DataFilterEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DataFilterEntityExtension on DataFilterEntity {
  DataFilterEntity copyWith({DataFilter? entity}) {
    return DataFilterEntity(entity: entity ?? this.entity);
  }

  DataFilterEntity copyWithWrapped({Wrapped<DataFilter?>? entity}) {
    return DataFilterEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterEntityRes {
  const DataFilterEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DataFilterEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DataFilterEntityResFromJson(json);

  static const toJsonFactory = _$DataFilterEntityResToJson;
  Map<String, dynamic> toJson() => _$DataFilterEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DataFilter? entity;
  static const fromJsonFactory = _$DataFilterEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DataFilterEntityResExtension on DataFilterEntityRes {
  DataFilterEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    DataFilter? entity,
  }) {
    return DataFilterEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  DataFilterEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<DataFilter?>? entity,
  }) {
    return DataFilterEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterArray {
  const DataFilterArray({this.values});

  factory DataFilterArray.fromJson(Map<String, dynamic> json) =>
      _$DataFilterArrayFromJson(json);

  static const toJsonFactory = _$DataFilterArrayToJson;
  Map<String, dynamic> toJson() => _$DataFilterArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DataFilter>[])
  final List<DataFilter>? values;
  static const fromJsonFactory = _$DataFilterArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DataFilterArrayExtension on DataFilterArray {
  DataFilterArray copyWith({List<DataFilter>? values}) {
    return DataFilterArray(values: values ?? this.values);
  }

  DataFilterArray copyWithWrapped({Wrapped<List<DataFilter>?>? values}) {
    return DataFilterArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterArrayRes {
  const DataFilterArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DataFilterArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DataFilterArrayResFromJson(json);

  static const toJsonFactory = _$DataFilterArrayResToJson;
  Map<String, dynamic> toJson() => _$DataFilterArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DataFilter>[])
  final List<DataFilter>? values;
  static const fromJsonFactory = _$DataFilterArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DataFilterArrayResExtension on DataFilterArrayRes {
  DataFilterArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<DataFilter>? values,
  }) {
    return DataFilterArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  DataFilterArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<DataFilter>?>? values,
  }) {
    return DataFilterArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceInfo {
  const GeoFenceInfo({
    required this.name,
    required this.label,
    this.description,
    this.tags,
    required this.fenceType,
    this.point,
    this.line,
    this.envelope,
    this.polygon,
    this.multipoint,
    this.multiline,
    this.multipolygon,
    this.circle,
  });

  factory GeoFenceInfo.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceInfoFromJson(json);

  static const toJsonFactory = _$GeoFenceInfoToJson;
  Map<String, dynamic> toJson() => _$GeoFenceInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'fenceType',
    includeIfNull: false,
    toJson: geoFenceInfoFenceTypeToJson,
    fromJson: geoFenceInfoFenceTypeFromJson,
  )
  final enums.GeoFenceInfoFenceType fenceType;
  @JsonKey(name: 'point', includeIfNull: false)
  final GeoLocation? point;
  @JsonKey(name: 'line', includeIfNull: false)
  final GeoLine? line;
  @JsonKey(name: 'envelope', includeIfNull: false)
  final GeoEnvelope? envelope;
  @JsonKey(name: 'polygon', includeIfNull: false)
  final GeoPolygon? polygon;
  @JsonKey(name: 'multipoint', includeIfNull: false)
  final GeoMultiPoint? multipoint;
  @JsonKey(name: 'multiline', includeIfNull: false)
  final GeoMultiLine? multiline;
  @JsonKey(name: 'multipolygon', includeIfNull: false)
  final GeoMultiPolygon? multipolygon;
  @JsonKey(name: 'circle', includeIfNull: false)
  final GeoCircle? circle;
  static const fromJsonFactory = _$GeoFenceInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.fenceType, fenceType) ||
                const DeepCollectionEquality().equals(
                  other.fenceType,
                  fenceType,
                )) &&
            (identical(other.point, point) ||
                const DeepCollectionEquality().equals(other.point, point)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)) &&
            (identical(other.envelope, envelope) ||
                const DeepCollectionEquality().equals(
                  other.envelope,
                  envelope,
                )) &&
            (identical(other.polygon, polygon) ||
                const DeepCollectionEquality().equals(
                  other.polygon,
                  polygon,
                )) &&
            (identical(other.multipoint, multipoint) ||
                const DeepCollectionEquality().equals(
                  other.multipoint,
                  multipoint,
                )) &&
            (identical(other.multiline, multiline) ||
                const DeepCollectionEquality().equals(
                  other.multiline,
                  multiline,
                )) &&
            (identical(other.multipolygon, multipolygon) ||
                const DeepCollectionEquality().equals(
                  other.multipolygon,
                  multipolygon,
                )) &&
            (identical(other.circle, circle) ||
                const DeepCollectionEquality().equals(other.circle, circle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(fenceType) ^
      const DeepCollectionEquality().hash(point) ^
      const DeepCollectionEquality().hash(line) ^
      const DeepCollectionEquality().hash(envelope) ^
      const DeepCollectionEquality().hash(polygon) ^
      const DeepCollectionEquality().hash(multipoint) ^
      const DeepCollectionEquality().hash(multiline) ^
      const DeepCollectionEquality().hash(multipolygon) ^
      const DeepCollectionEquality().hash(circle) ^
      runtimeType.hashCode;
}

extension $GeoFenceInfoExtension on GeoFenceInfo {
  GeoFenceInfo copyWith({
    String? name,
    String? label,
    String? description,
    List<String>? tags,
    enums.GeoFenceInfoFenceType? fenceType,
    GeoLocation? point,
    GeoLine? line,
    GeoEnvelope? envelope,
    GeoPolygon? polygon,
    GeoMultiPoint? multipoint,
    GeoMultiLine? multiline,
    GeoMultiPolygon? multipolygon,
    GeoCircle? circle,
  }) {
    return GeoFenceInfo(
      name: name ?? this.name,
      label: label ?? this.label,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      fenceType: fenceType ?? this.fenceType,
      point: point ?? this.point,
      line: line ?? this.line,
      envelope: envelope ?? this.envelope,
      polygon: polygon ?? this.polygon,
      multipoint: multipoint ?? this.multipoint,
      multiline: multiline ?? this.multiline,
      multipolygon: multipolygon ?? this.multipolygon,
      circle: circle ?? this.circle,
    );
  }

  GeoFenceInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? label,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<enums.GeoFenceInfoFenceType>? fenceType,
    Wrapped<GeoLocation?>? point,
    Wrapped<GeoLine?>? line,
    Wrapped<GeoEnvelope?>? envelope,
    Wrapped<GeoPolygon?>? polygon,
    Wrapped<GeoMultiPoint?>? multipoint,
    Wrapped<GeoMultiLine?>? multiline,
    Wrapped<GeoMultiPolygon?>? multipolygon,
    Wrapped<GeoCircle?>? circle,
  }) {
    return GeoFenceInfo(
      name: (name != null ? name.value : this.name),
      label: (label != null ? label.value : this.label),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      fenceType: (fenceType != null ? fenceType.value : this.fenceType),
      point: (point != null ? point.value : this.point),
      line: (line != null ? line.value : this.line),
      envelope: (envelope != null ? envelope.value : this.envelope),
      polygon: (polygon != null ? polygon.value : this.polygon),
      multipoint: (multipoint != null ? multipoint.value : this.multipoint),
      multiline: (multiline != null ? multiline.value : this.multiline),
      multipolygon: (multipolygon != null
          ? multipolygon.value
          : this.multipolygon),
      circle: (circle != null ? circle.value : this.circle),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceBase {
  const GeoFenceBase({required this.fence});

  factory GeoFenceBase.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceBaseFromJson(json);

  static const toJsonFactory = _$GeoFenceBaseToJson;
  Map<String, dynamic> toJson() => _$GeoFenceBaseToJson(this);

  @JsonKey(name: 'fence', includeIfNull: false)
  final Object fence;
  static const fromJsonFactory = _$GeoFenceBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceBase &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fence) ^ runtimeType.hashCode;
}

extension $GeoFenceBaseExtension on GeoFenceBase {
  GeoFenceBase copyWith({Object? fence}) {
    return GeoFenceBase(fence: fence ?? this.fence);
  }

  GeoFenceBase copyWithWrapped({Wrapped<Object>? fence}) {
    return GeoFenceBase(fence: (fence != null ? fence.value : this.fence));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFence {
  const GeoFence({
    required this.name,
    required this.label,
    this.description,
    this.tags,
    required this.fenceType,
    this.point,
    this.line,
    this.envelope,
    this.polygon,
    this.multipoint,
    this.multiline,
    this.multipolygon,
    this.circle,
    required this.fence,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory GeoFence.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceFromJson(json);

  static const toJsonFactory = _$GeoFenceToJson;
  Map<String, dynamic> toJson() => _$GeoFenceToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'fenceType',
    includeIfNull: false,
    toJson: geoFenceFenceTypeToJson,
    fromJson: geoFenceFenceTypeFromJson,
  )
  final enums.GeoFenceFenceType fenceType;
  @JsonKey(name: 'point', includeIfNull: false)
  final GeoLocation? point;
  @JsonKey(name: 'line', includeIfNull: false)
  final GeoLine? line;
  @JsonKey(name: 'envelope', includeIfNull: false)
  final GeoEnvelope? envelope;
  @JsonKey(name: 'polygon', includeIfNull: false)
  final GeoPolygon? polygon;
  @JsonKey(name: 'multipoint', includeIfNull: false)
  final GeoMultiPoint? multipoint;
  @JsonKey(name: 'multiline', includeIfNull: false)
  final GeoMultiLine? multiline;
  @JsonKey(name: 'multipolygon', includeIfNull: false)
  final GeoMultiPolygon? multipolygon;
  @JsonKey(name: 'circle', includeIfNull: false)
  final GeoCircle? circle;
  @JsonKey(name: 'fence', includeIfNull: false)
  final Object fence;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$GeoFenceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFence &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.fenceType, fenceType) ||
                const DeepCollectionEquality().equals(
                  other.fenceType,
                  fenceType,
                )) &&
            (identical(other.point, point) ||
                const DeepCollectionEquality().equals(other.point, point)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)) &&
            (identical(other.envelope, envelope) ||
                const DeepCollectionEquality().equals(
                  other.envelope,
                  envelope,
                )) &&
            (identical(other.polygon, polygon) ||
                const DeepCollectionEquality().equals(
                  other.polygon,
                  polygon,
                )) &&
            (identical(other.multipoint, multipoint) ||
                const DeepCollectionEquality().equals(
                  other.multipoint,
                  multipoint,
                )) &&
            (identical(other.multiline, multiline) ||
                const DeepCollectionEquality().equals(
                  other.multiline,
                  multiline,
                )) &&
            (identical(other.multipolygon, multipolygon) ||
                const DeepCollectionEquality().equals(
                  other.multipolygon,
                  multipolygon,
                )) &&
            (identical(other.circle, circle) ||
                const DeepCollectionEquality().equals(other.circle, circle)) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(fenceType) ^
      const DeepCollectionEquality().hash(point) ^
      const DeepCollectionEquality().hash(line) ^
      const DeepCollectionEquality().hash(envelope) ^
      const DeepCollectionEquality().hash(polygon) ^
      const DeepCollectionEquality().hash(multipoint) ^
      const DeepCollectionEquality().hash(multiline) ^
      const DeepCollectionEquality().hash(multipolygon) ^
      const DeepCollectionEquality().hash(circle) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $GeoFenceExtension on GeoFence {
  GeoFence copyWith({
    String? name,
    String? label,
    String? description,
    List<String>? tags,
    enums.GeoFenceFenceType? fenceType,
    GeoLocation? point,
    GeoLine? line,
    GeoEnvelope? envelope,
    GeoPolygon? polygon,
    GeoMultiPoint? multipoint,
    GeoMultiLine? multiline,
    GeoMultiPolygon? multipolygon,
    GeoCircle? circle,
    Object? fence,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return GeoFence(
      name: name ?? this.name,
      label: label ?? this.label,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      fenceType: fenceType ?? this.fenceType,
      point: point ?? this.point,
      line: line ?? this.line,
      envelope: envelope ?? this.envelope,
      polygon: polygon ?? this.polygon,
      multipoint: multipoint ?? this.multipoint,
      multiline: multiline ?? this.multiline,
      multipolygon: multipolygon ?? this.multipolygon,
      circle: circle ?? this.circle,
      fence: fence ?? this.fence,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  GeoFence copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? label,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<enums.GeoFenceFenceType>? fenceType,
    Wrapped<GeoLocation?>? point,
    Wrapped<GeoLine?>? line,
    Wrapped<GeoEnvelope?>? envelope,
    Wrapped<GeoPolygon?>? polygon,
    Wrapped<GeoMultiPoint?>? multipoint,
    Wrapped<GeoMultiLine?>? multiline,
    Wrapped<GeoMultiPolygon?>? multipolygon,
    Wrapped<GeoCircle?>? circle,
    Wrapped<Object>? fence,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return GeoFence(
      name: (name != null ? name.value : this.name),
      label: (label != null ? label.value : this.label),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      fenceType: (fenceType != null ? fenceType.value : this.fenceType),
      point: (point != null ? point.value : this.point),
      line: (line != null ? line.value : this.line),
      envelope: (envelope != null ? envelope.value : this.envelope),
      polygon: (polygon != null ? polygon.value : this.polygon),
      multipoint: (multipoint != null ? multipoint.value : this.multipoint),
      multiline: (multiline != null ? multiline.value : this.multiline),
      multipolygon: (multipolygon != null
          ? multipolygon.value
          : this.multipolygon),
      circle: (circle != null ? circle.value : this.circle),
      fence: (fence != null ? fence.value : this.fence),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceEntity {
  const GeoFenceEntity({this.entity});

  factory GeoFenceEntity.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceEntityFromJson(json);

  static const toJsonFactory = _$GeoFenceEntityToJson;
  Map<String, dynamic> toJson() => _$GeoFenceEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final GeoFence? entity;
  static const fromJsonFactory = _$GeoFenceEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $GeoFenceEntityExtension on GeoFenceEntity {
  GeoFenceEntity copyWith({GeoFence? entity}) {
    return GeoFenceEntity(entity: entity ?? this.entity);
  }

  GeoFenceEntity copyWithWrapped({Wrapped<GeoFence?>? entity}) {
    return GeoFenceEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceEntityRes {
  const GeoFenceEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory GeoFenceEntityRes.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceEntityResFromJson(json);

  static const toJsonFactory = _$GeoFenceEntityResToJson;
  Map<String, dynamic> toJson() => _$GeoFenceEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final GeoFence? entity;
  static const fromJsonFactory = _$GeoFenceEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $GeoFenceEntityResExtension on GeoFenceEntityRes {
  GeoFenceEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    GeoFence? entity,
  }) {
    return GeoFenceEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  GeoFenceEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<GeoFence?>? entity,
  }) {
    return GeoFenceEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceArray {
  const GeoFenceArray({this.values});

  factory GeoFenceArray.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceArrayFromJson(json);

  static const toJsonFactory = _$GeoFenceArrayToJson;
  Map<String, dynamic> toJson() => _$GeoFenceArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <GeoFence>[])
  final List<GeoFence>? values;
  static const fromJsonFactory = _$GeoFenceArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $GeoFenceArrayExtension on GeoFenceArray {
  GeoFenceArray copyWith({List<GeoFence>? values}) {
    return GeoFenceArray(values: values ?? this.values);
  }

  GeoFenceArray copyWithWrapped({Wrapped<List<GeoFence>?>? values}) {
    return GeoFenceArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceArrayRes {
  const GeoFenceArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory GeoFenceArrayRes.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceArrayResFromJson(json);

  static const toJsonFactory = _$GeoFenceArrayResToJson;
  Map<String, dynamic> toJson() => _$GeoFenceArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <GeoFence>[])
  final List<GeoFence>? values;
  static const fromJsonFactory = _$GeoFenceArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $GeoFenceArrayResExtension on GeoFenceArrayRes {
  GeoFenceArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<GeoFence>? values,
  }) {
    return GeoFenceArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  GeoFenceArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<GeoFence>?>? values,
  }) {
    return GeoFenceArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsRow {
  const AnalyticsRow({
    required this.height,
    required this.flex,
    required this.widgetIds,
    this.label,
    this.description,
  });

  factory AnalyticsRow.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsRowFromJson(json);

  static const toJsonFactory = _$AnalyticsRowToJson;
  Map<String, dynamic> toJson() => _$AnalyticsRowToJson(this);

  @JsonKey(name: 'height', includeIfNull: false)
  final int height;
  @JsonKey(name: 'flex', includeIfNull: false)
  final int flex;
  @JsonKey(name: 'widgetIds', includeIfNull: false, defaultValue: <String>[])
  final List<String> widgetIds;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  static const fromJsonFactory = _$AnalyticsRowFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsRow &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.flex, flex) ||
                const DeepCollectionEquality().equals(other.flex, flex)) &&
            (identical(other.widgetIds, widgetIds) ||
                const DeepCollectionEquality().equals(
                  other.widgetIds,
                  widgetIds,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(flex) ^
      const DeepCollectionEquality().hash(widgetIds) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $AnalyticsRowExtension on AnalyticsRow {
  AnalyticsRow copyWith({
    int? height,
    int? flex,
    List<String>? widgetIds,
    String? label,
    String? description,
  }) {
    return AnalyticsRow(
      height: height ?? this.height,
      flex: flex ?? this.flex,
      widgetIds: widgetIds ?? this.widgetIds,
      label: label ?? this.label,
      description: description ?? this.description,
    );
  }

  AnalyticsRow copyWithWrapped({
    Wrapped<int>? height,
    Wrapped<int>? flex,
    Wrapped<List<String>>? widgetIds,
    Wrapped<String?>? label,
    Wrapped<String?>? description,
  }) {
    return AnalyticsRow(
      height: (height != null ? height.value : this.height),
      flex: (flex != null ? flex.value : this.flex),
      widgetIds: (widgetIds != null ? widgetIds.value : this.widgetIds),
      label: (label != null ? label.value : this.label),
      description: (description != null ? description.value : this.description),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenInfo {
  const AnalyticsScreenInfo({
    required this.name,
    this.label,
    this.description,
    this.icon,
    this.tags,
    this.showDefault,
    required this.rows,
  });

  factory AnalyticsScreenInfo.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenInfoFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenInfoToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'showDefault', includeIfNull: false, defaultValue: false)
  final bool? showDefault;
  @JsonKey(name: 'rows', includeIfNull: false, defaultValue: <AnalyticsRow>[])
  final List<AnalyticsRow> rows;
  static const fromJsonFactory = _$AnalyticsScreenInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.showDefault, showDefault) ||
                const DeepCollectionEquality().equals(
                  other.showDefault,
                  showDefault,
                )) &&
            (identical(other.rows, rows) ||
                const DeepCollectionEquality().equals(other.rows, rows)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(showDefault) ^
      const DeepCollectionEquality().hash(rows) ^
      runtimeType.hashCode;
}

extension $AnalyticsScreenInfoExtension on AnalyticsScreenInfo {
  AnalyticsScreenInfo copyWith({
    String? name,
    String? label,
    String? description,
    String? icon,
    List<String>? tags,
    bool? showDefault,
    List<AnalyticsRow>? rows,
  }) {
    return AnalyticsScreenInfo(
      name: name ?? this.name,
      label: label ?? this.label,
      description: description ?? this.description,
      icon: icon ?? this.icon,
      tags: tags ?? this.tags,
      showDefault: showDefault ?? this.showDefault,
      rows: rows ?? this.rows,
    );
  }

  AnalyticsScreenInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? label,
    Wrapped<String?>? description,
    Wrapped<String?>? icon,
    Wrapped<List<String>?>? tags,
    Wrapped<bool?>? showDefault,
    Wrapped<List<AnalyticsRow>>? rows,
  }) {
    return AnalyticsScreenInfo(
      name: (name != null ? name.value : this.name),
      label: (label != null ? label.value : this.label),
      description: (description != null ? description.value : this.description),
      icon: (icon != null ? icon.value : this.icon),
      tags: (tags != null ? tags.value : this.tags),
      showDefault: (showDefault != null ? showDefault.value : this.showDefault),
      rows: (rows != null ? rows.value : this.rows),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreen {
  const AnalyticsScreen({
    required this.name,
    this.label,
    this.description,
    this.icon,
    this.tags,
    this.showDefault,
    required this.rows,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory AnalyticsScreen.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'showDefault', includeIfNull: false, defaultValue: false)
  final bool? showDefault;
  @JsonKey(name: 'rows', includeIfNull: false, defaultValue: <AnalyticsRow>[])
  final List<AnalyticsRow> rows;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$AnalyticsScreenFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreen &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.showDefault, showDefault) ||
                const DeepCollectionEquality().equals(
                  other.showDefault,
                  showDefault,
                )) &&
            (identical(other.rows, rows) ||
                const DeepCollectionEquality().equals(other.rows, rows)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(showDefault) ^
      const DeepCollectionEquality().hash(rows) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $AnalyticsScreenExtension on AnalyticsScreen {
  AnalyticsScreen copyWith({
    String? name,
    String? label,
    String? description,
    String? icon,
    List<String>? tags,
    bool? showDefault,
    List<AnalyticsRow>? rows,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return AnalyticsScreen(
      name: name ?? this.name,
      label: label ?? this.label,
      description: description ?? this.description,
      icon: icon ?? this.icon,
      tags: tags ?? this.tags,
      showDefault: showDefault ?? this.showDefault,
      rows: rows ?? this.rows,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  AnalyticsScreen copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? label,
    Wrapped<String?>? description,
    Wrapped<String?>? icon,
    Wrapped<List<String>?>? tags,
    Wrapped<bool?>? showDefault,
    Wrapped<List<AnalyticsRow>>? rows,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return AnalyticsScreen(
      name: (name != null ? name.value : this.name),
      label: (label != null ? label.value : this.label),
      description: (description != null ? description.value : this.description),
      icon: (icon != null ? icon.value : this.icon),
      tags: (tags != null ? tags.value : this.tags),
      showDefault: (showDefault != null ? showDefault.value : this.showDefault),
      rows: (rows != null ? rows.value : this.rows),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenEntity {
  const AnalyticsScreenEntity({this.entity});

  factory AnalyticsScreenEntity.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenEntityFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenEntityToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final AnalyticsScreen? entity;
  static const fromJsonFactory = _$AnalyticsScreenEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AnalyticsScreenEntityExtension on AnalyticsScreenEntity {
  AnalyticsScreenEntity copyWith({AnalyticsScreen? entity}) {
    return AnalyticsScreenEntity(entity: entity ?? this.entity);
  }

  AnalyticsScreenEntity copyWithWrapped({Wrapped<AnalyticsScreen?>? entity}) {
    return AnalyticsScreenEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenEntityRes {
  const AnalyticsScreenEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AnalyticsScreenEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenEntityResFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenEntityResToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final AnalyticsScreen? entity;
  static const fromJsonFactory = _$AnalyticsScreenEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AnalyticsScreenEntityResExtension on AnalyticsScreenEntityRes {
  AnalyticsScreenEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    AnalyticsScreen? entity,
  }) {
    return AnalyticsScreenEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  AnalyticsScreenEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<AnalyticsScreen?>? entity,
  }) {
    return AnalyticsScreenEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenArray {
  const AnalyticsScreenArray({this.values});

  factory AnalyticsScreenArray.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenArrayFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenArrayToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <AnalyticsScreen>[],
  )
  final List<AnalyticsScreen>? values;
  static const fromJsonFactory = _$AnalyticsScreenArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AnalyticsScreenArrayExtension on AnalyticsScreenArray {
  AnalyticsScreenArray copyWith({List<AnalyticsScreen>? values}) {
    return AnalyticsScreenArray(values: values ?? this.values);
  }

  AnalyticsScreenArray copyWithWrapped({
    Wrapped<List<AnalyticsScreen>?>? values,
  }) {
    return AnalyticsScreenArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenArrayRes {
  const AnalyticsScreenArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AnalyticsScreenArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenArrayResFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenArrayResToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <AnalyticsScreen>[],
  )
  final List<AnalyticsScreen>? values;
  static const fromJsonFactory = _$AnalyticsScreenArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AnalyticsScreenArrayResExtension on AnalyticsScreenArrayRes {
  AnalyticsScreenArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<AnalyticsScreen>? values,
  }) {
    return AnalyticsScreenArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  AnalyticsScreenArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<AnalyticsScreen>?>? values,
  }) {
    return AnalyticsScreenArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TrendValue {
  const TrendValue({
    required this.stamp,
    this.count,
    this.min,
    this.max,
    this.avg,
  });

  factory TrendValue.fromJson(Map<String, dynamic> json) =>
      _$TrendValueFromJson(json);

  static const toJsonFactory = _$TrendValueToJson;
  Map<String, dynamic> toJson() => _$TrendValueToJson(this);

  @JsonKey(name: 'stamp', includeIfNull: false)
  final int stamp;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  @JsonKey(name: 'min', includeIfNull: false)
  final double? min;
  @JsonKey(name: 'max', includeIfNull: false)
  final double? max;
  @JsonKey(name: 'avg', includeIfNull: false)
  final double? avg;
  static const fromJsonFactory = _$TrendValueFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrendValue &&
            (identical(other.stamp, stamp) ||
                const DeepCollectionEquality().equals(other.stamp, stamp)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.min, min) ||
                const DeepCollectionEquality().equals(other.min, min)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)) &&
            (identical(other.avg, avg) ||
                const DeepCollectionEquality().equals(other.avg, avg)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stamp) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(min) ^
      const DeepCollectionEquality().hash(max) ^
      const DeepCollectionEquality().hash(avg) ^
      runtimeType.hashCode;
}

extension $TrendValueExtension on TrendValue {
  TrendValue copyWith({
    int? stamp,
    int? count,
    double? min,
    double? max,
    double? avg,
  }) {
    return TrendValue(
      stamp: stamp ?? this.stamp,
      count: count ?? this.count,
      min: min ?? this.min,
      max: max ?? this.max,
      avg: avg ?? this.avg,
    );
  }

  TrendValue copyWithWrapped({
    Wrapped<int>? stamp,
    Wrapped<int?>? count,
    Wrapped<double?>? min,
    Wrapped<double?>? max,
    Wrapped<double?>? avg,
  }) {
    return TrendValue(
      stamp: (stamp != null ? stamp.value : this.stamp),
      count: (count != null ? count.value : this.count),
      min: (min != null ? min.value : this.min),
      max: (max != null ? max.value : this.max),
      avg: (avg != null ? avg.value : this.avg),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TrendValueArray {
  const TrendValueArray({this.values});

  factory TrendValueArray.fromJson(Map<String, dynamic> json) =>
      _$TrendValueArrayFromJson(json);

  static const toJsonFactory = _$TrendValueArrayToJson;
  Map<String, dynamic> toJson() => _$TrendValueArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TrendValue>[])
  final List<TrendValue>? values;
  static const fromJsonFactory = _$TrendValueArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrendValueArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TrendValueArrayExtension on TrendValueArray {
  TrendValueArray copyWith({List<TrendValue>? values}) {
    return TrendValueArray(values: values ?? this.values);
  }

  TrendValueArray copyWithWrapped({Wrapped<List<TrendValue>?>? values}) {
    return TrendValueArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TrendValueArrayRes {
  const TrendValueArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TrendValueArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TrendValueArrayResFromJson(json);

  static const toJsonFactory = _$TrendValueArrayResToJson;
  Map<String, dynamic> toJson() => _$TrendValueArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TrendValue>[])
  final List<TrendValue>? values;
  static const fromJsonFactory = _$TrendValueArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrendValueArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TrendValueArrayResExtension on TrendValueArrayRes {
  TrendValueArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<TrendValue>? values,
  }) {
    return TrendValueArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  TrendValueArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<TrendValue>?>? values,
  }) {
    return TrendValueArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TimeSeriesValue {
  const TimeSeriesValue({required this.updatedStamp, this.data, this.id});

  factory TimeSeriesValue.fromJson(Map<String, dynamic> json) =>
      _$TimeSeriesValueFromJson(json);

  static const toJsonFactory = _$TimeSeriesValueToJson;
  Map<String, dynamic> toJson() => _$TimeSeriesValueToJson(this);

  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'data', includeIfNull: false)
  final Object? data;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  static const fromJsonFactory = _$TimeSeriesValueFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimeSeriesValue &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $TimeSeriesValueExtension on TimeSeriesValue {
  TimeSeriesValue copyWith({int? updatedStamp, Object? data, String? id}) {
    return TimeSeriesValue(
      updatedStamp: updatedStamp ?? this.updatedStamp,
      data: data ?? this.data,
      id: id ?? this.id,
    );
  }

  TimeSeriesValue copyWithWrapped({
    Wrapped<int>? updatedStamp,
    Wrapped<Object?>? data,
    Wrapped<String?>? id,
  }) {
    return TimeSeriesValue(
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      data: (data != null ? data.value : this.data),
      id: (id != null ? id.value : this.id),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TimeSeriesValueArray {
  const TimeSeriesValueArray({this.values});

  factory TimeSeriesValueArray.fromJson(Map<String, dynamic> json) =>
      _$TimeSeriesValueArrayFromJson(json);

  static const toJsonFactory = _$TimeSeriesValueArrayToJson;
  Map<String, dynamic> toJson() => _$TimeSeriesValueArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <TimeSeriesValue>[],
  )
  final List<TimeSeriesValue>? values;
  static const fromJsonFactory = _$TimeSeriesValueArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimeSeriesValueArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TimeSeriesValueArrayExtension on TimeSeriesValueArray {
  TimeSeriesValueArray copyWith({List<TimeSeriesValue>? values}) {
    return TimeSeriesValueArray(values: values ?? this.values);
  }

  TimeSeriesValueArray copyWithWrapped({
    Wrapped<List<TimeSeriesValue>?>? values,
  }) {
    return TimeSeriesValueArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TimeSeriesValueArrayRes {
  const TimeSeriesValueArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TimeSeriesValueArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TimeSeriesValueArrayResFromJson(json);

  static const toJsonFactory = _$TimeSeriesValueArrayResToJson;
  Map<String, dynamic> toJson() => _$TimeSeriesValueArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <TimeSeriesValue>[],
  )
  final List<TimeSeriesValue>? values;
  static const fromJsonFactory = _$TimeSeriesValueArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimeSeriesValueArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TimeSeriesValueArrayResExtension on TimeSeriesValueArrayRes {
  TimeSeriesValueArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<TimeSeriesValue>? values,
  }) {
    return TimeSeriesValueArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  TimeSeriesValueArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<TimeSeriesValue>?>? values,
  }) {
    return TimeSeriesValueArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ElasticEmailConfig {
  const ElasticEmailConfig({required this.fromEmail, required this.apiKey});

  factory ElasticEmailConfig.fromJson(Map<String, dynamic> json) =>
      _$ElasticEmailConfigFromJson(json);

  static const toJsonFactory = _$ElasticEmailConfigToJson;
  Map<String, dynamic> toJson() => _$ElasticEmailConfigToJson(this);

  @JsonKey(name: 'fromEmail', includeIfNull: false, defaultValue: '')
  final String fromEmail;
  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  static const fromJsonFactory = _$ElasticEmailConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ElasticEmailConfig &&
            (identical(other.fromEmail, fromEmail) ||
                const DeepCollectionEquality().equals(
                  other.fromEmail,
                  fromEmail,
                )) &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fromEmail) ^
      const DeepCollectionEquality().hash(apiKey) ^
      runtimeType.hashCode;
}

extension $ElasticEmailConfigExtension on ElasticEmailConfig {
  ElasticEmailConfig copyWith({String? fromEmail, String? apiKey}) {
    return ElasticEmailConfig(
      fromEmail: fromEmail ?? this.fromEmail,
      apiKey: apiKey ?? this.apiKey,
    );
  }

  ElasticEmailConfig copyWithWrapped({
    Wrapped<String>? fromEmail,
    Wrapped<String>? apiKey,
  }) {
    return ElasticEmailConfig(
      fromEmail: (fromEmail != null ? fromEmail.value : this.fromEmail),
      apiKey: (apiKey != null ? apiKey.value : this.apiKey),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwilioConfig {
  const TwilioConfig({
    required this.accountSid,
    required this.authToken,
    required this.phoneNumber,
    this.language,
    this.voice,
  });

  factory TwilioConfig.fromJson(Map<String, dynamic> json) =>
      _$TwilioConfigFromJson(json);

  static const toJsonFactory = _$TwilioConfigToJson;
  Map<String, dynamic> toJson() => _$TwilioConfigToJson(this);

  @JsonKey(name: 'accountSid', includeIfNull: false, defaultValue: '')
  final String accountSid;
  @JsonKey(name: 'authToken', includeIfNull: false, defaultValue: '')
  final String authToken;
  @JsonKey(name: 'phoneNumber', includeIfNull: false, defaultValue: '')
  final String phoneNumber;
  @JsonKey(name: 'language', includeIfNull: false, defaultValue: '')
  final String? language;
  @JsonKey(name: 'voice', includeIfNull: false, defaultValue: '')
  final String? voice;
  static const fromJsonFactory = _$TwilioConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwilioConfig &&
            (identical(other.accountSid, accountSid) ||
                const DeepCollectionEquality().equals(
                  other.accountSid,
                  accountSid,
                )) &&
            (identical(other.authToken, authToken) ||
                const DeepCollectionEquality().equals(
                  other.authToken,
                  authToken,
                )) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality().equals(
                  other.phoneNumber,
                  phoneNumber,
                )) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality().equals(
                  other.language,
                  language,
                )) &&
            (identical(other.voice, voice) ||
                const DeepCollectionEquality().equals(other.voice, voice)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSid) ^
      const DeepCollectionEquality().hash(authToken) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(voice) ^
      runtimeType.hashCode;
}

extension $TwilioConfigExtension on TwilioConfig {
  TwilioConfig copyWith({
    String? accountSid,
    String? authToken,
    String? phoneNumber,
    String? language,
    String? voice,
  }) {
    return TwilioConfig(
      accountSid: accountSid ?? this.accountSid,
      authToken: authToken ?? this.authToken,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      language: language ?? this.language,
      voice: voice ?? this.voice,
    );
  }

  TwilioConfig copyWithWrapped({
    Wrapped<String>? accountSid,
    Wrapped<String>? authToken,
    Wrapped<String>? phoneNumber,
    Wrapped<String?>? language,
    Wrapped<String?>? voice,
  }) {
    return TwilioConfig(
      accountSid: (accountSid != null ? accountSid.value : this.accountSid),
      authToken: (authToken != null ? authToken.value : this.authToken),
      phoneNumber: (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
      language: (language != null ? language.value : this.language),
      voice: (voice != null ? voice.value : this.voice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoapifyConfig {
  const GeoapifyConfig({required this.apiKey});

  factory GeoapifyConfig.fromJson(Map<String, dynamic> json) =>
      _$GeoapifyConfigFromJson(json);

  static const toJsonFactory = _$GeoapifyConfigToJson;
  Map<String, dynamic> toJson() => _$GeoapifyConfigToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  static const fromJsonFactory = _$GeoapifyConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoapifyConfig &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^ runtimeType.hashCode;
}

extension $GeoapifyConfigExtension on GeoapifyConfig {
  GeoapifyConfig copyWith({String? apiKey}) {
    return GeoapifyConfig(apiKey: apiKey ?? this.apiKey);
  }

  GeoapifyConfig copyWithWrapped({Wrapped<String>? apiKey}) {
    return GeoapifyConfig(
      apiKey: (apiKey != null ? apiKey.value : this.apiKey),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysInfoBase {
  const TwinSysInfoBase({
    this.elasticEmailConfig,
    this.twilioConfig,
    this.geoapifyConfig,
  });

  factory TwinSysInfoBase.fromJson(Map<String, dynamic> json) =>
      _$TwinSysInfoBaseFromJson(json);

  static const toJsonFactory = _$TwinSysInfoBaseToJson;
  Map<String, dynamic> toJson() => _$TwinSysInfoBaseToJson(this);

  @JsonKey(name: 'elasticEmailConfig', includeIfNull: false)
  final ElasticEmailConfig? elasticEmailConfig;
  @JsonKey(name: 'twilioConfig', includeIfNull: false)
  final TwilioConfig? twilioConfig;
  @JsonKey(name: 'geoapifyConfig', includeIfNull: false)
  final GeoapifyConfig? geoapifyConfig;
  static const fromJsonFactory = _$TwinSysInfoBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysInfoBase &&
            (identical(other.elasticEmailConfig, elasticEmailConfig) ||
                const DeepCollectionEquality().equals(
                  other.elasticEmailConfig,
                  elasticEmailConfig,
                )) &&
            (identical(other.twilioConfig, twilioConfig) ||
                const DeepCollectionEquality().equals(
                  other.twilioConfig,
                  twilioConfig,
                )) &&
            (identical(other.geoapifyConfig, geoapifyConfig) ||
                const DeepCollectionEquality().equals(
                  other.geoapifyConfig,
                  geoapifyConfig,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(elasticEmailConfig) ^
      const DeepCollectionEquality().hash(twilioConfig) ^
      const DeepCollectionEquality().hash(geoapifyConfig) ^
      runtimeType.hashCode;
}

extension $TwinSysInfoBaseExtension on TwinSysInfoBase {
  TwinSysInfoBase copyWith({
    ElasticEmailConfig? elasticEmailConfig,
    TwilioConfig? twilioConfig,
    GeoapifyConfig? geoapifyConfig,
  }) {
    return TwinSysInfoBase(
      elasticEmailConfig: elasticEmailConfig ?? this.elasticEmailConfig,
      twilioConfig: twilioConfig ?? this.twilioConfig,
      geoapifyConfig: geoapifyConfig ?? this.geoapifyConfig,
    );
  }

  TwinSysInfoBase copyWithWrapped({
    Wrapped<ElasticEmailConfig?>? elasticEmailConfig,
    Wrapped<TwilioConfig?>? twilioConfig,
    Wrapped<GeoapifyConfig?>? geoapifyConfig,
  }) {
    return TwinSysInfoBase(
      elasticEmailConfig: (elasticEmailConfig != null
          ? elasticEmailConfig.value
          : this.elasticEmailConfig),
      twilioConfig: (twilioConfig != null
          ? twilioConfig.value
          : this.twilioConfig),
      geoapifyConfig: (geoapifyConfig != null
          ? geoapifyConfig.value
          : this.geoapifyConfig),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysInfo {
  const TwinSysInfo({
    this.elasticEmailConfig,
    this.twilioConfig,
    this.geoapifyConfig,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory TwinSysInfo.fromJson(Map<String, dynamic> json) =>
      _$TwinSysInfoFromJson(json);

  static const toJsonFactory = _$TwinSysInfoToJson;
  Map<String, dynamic> toJson() => _$TwinSysInfoToJson(this);

  @JsonKey(name: 'elasticEmailConfig', includeIfNull: false)
  final ElasticEmailConfig? elasticEmailConfig;
  @JsonKey(name: 'twilioConfig', includeIfNull: false)
  final TwilioConfig? twilioConfig;
  @JsonKey(name: 'geoapifyConfig', includeIfNull: false)
  final GeoapifyConfig? geoapifyConfig;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$TwinSysInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysInfo &&
            (identical(other.elasticEmailConfig, elasticEmailConfig) ||
                const DeepCollectionEquality().equals(
                  other.elasticEmailConfig,
                  elasticEmailConfig,
                )) &&
            (identical(other.twilioConfig, twilioConfig) ||
                const DeepCollectionEquality().equals(
                  other.twilioConfig,
                  twilioConfig,
                )) &&
            (identical(other.geoapifyConfig, geoapifyConfig) ||
                const DeepCollectionEquality().equals(
                  other.geoapifyConfig,
                  geoapifyConfig,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(elasticEmailConfig) ^
      const DeepCollectionEquality().hash(twilioConfig) ^
      const DeepCollectionEquality().hash(geoapifyConfig) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $TwinSysInfoExtension on TwinSysInfo {
  TwinSysInfo copyWith({
    ElasticEmailConfig? elasticEmailConfig,
    TwilioConfig? twilioConfig,
    GeoapifyConfig? geoapifyConfig,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return TwinSysInfo(
      elasticEmailConfig: elasticEmailConfig ?? this.elasticEmailConfig,
      twilioConfig: twilioConfig ?? this.twilioConfig,
      geoapifyConfig: geoapifyConfig ?? this.geoapifyConfig,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  TwinSysInfo copyWithWrapped({
    Wrapped<ElasticEmailConfig?>? elasticEmailConfig,
    Wrapped<TwilioConfig?>? twilioConfig,
    Wrapped<GeoapifyConfig?>? geoapifyConfig,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return TwinSysInfo(
      elasticEmailConfig: (elasticEmailConfig != null
          ? elasticEmailConfig.value
          : this.elasticEmailConfig),
      twilioConfig: (twilioConfig != null
          ? twilioConfig.value
          : this.twilioConfig),
      geoapifyConfig: (geoapifyConfig != null
          ? geoapifyConfig.value
          : this.geoapifyConfig),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysInfoEntity {
  const TwinSysInfoEntity({this.entity});

  factory TwinSysInfoEntity.fromJson(Map<String, dynamic> json) =>
      _$TwinSysInfoEntityFromJson(json);

  static const toJsonFactory = _$TwinSysInfoEntityToJson;
  Map<String, dynamic> toJson() => _$TwinSysInfoEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinSysInfo? entity;
  static const fromJsonFactory = _$TwinSysInfoEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysInfoEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $TwinSysInfoEntityExtension on TwinSysInfoEntity {
  TwinSysInfoEntity copyWith({TwinSysInfo? entity}) {
    return TwinSysInfoEntity(entity: entity ?? this.entity);
  }

  TwinSysInfoEntity copyWithWrapped({Wrapped<TwinSysInfo?>? entity}) {
    return TwinSysInfoEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysInfoEntityRes {
  const TwinSysInfoEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory TwinSysInfoEntityRes.fromJson(Map<String, dynamic> json) =>
      _$TwinSysInfoEntityResFromJson(json);

  static const toJsonFactory = _$TwinSysInfoEntityResToJson;
  Map<String, dynamic> toJson() => _$TwinSysInfoEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinSysInfo? entity;
  static const fromJsonFactory = _$TwinSysInfoEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysInfoEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $TwinSysInfoEntityResExtension on TwinSysInfoEntityRes {
  TwinSysInfoEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    TwinSysInfo? entity,
  }) {
    return TwinSysInfoEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  TwinSysInfoEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<TwinSysInfo?>? entity,
  }) {
    return TwinSysInfoEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FloorInfo {
  const FloorInfo({
    this.premiseId,
    this.facilityId,
    required this.name,
    this.description,
    this.tags,
    this.floorPlan,
    this.assets,
    this.roles,
    this.location,
    this.fence,
    this.floorLevel,
    this.floorType,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
  });

  factory FloorInfo.fromJson(Map<String, dynamic> json) =>
      _$FloorInfoFromJson(json);

  static const toJsonFactory = _$FloorInfoToJson;
  Map<String, dynamic> toJson() => _$FloorInfoToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'floorPlan', includeIfNull: false, defaultValue: '')
  final String? floorPlan;
  @JsonKey(name: 'assets', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assets;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'fence', includeIfNull: false)
  final GeoLocation? fence;
  @JsonKey(name: 'floorLevel', includeIfNull: false)
  final int? floorLevel;
  @JsonKey(
    name: 'floorType',
    includeIfNull: false,
    toJson: floorInfoFloorTypeNullableToJson,
    fromJson: floorInfoFloorTypeFloorTypeNullableFromJson,
  )
  final enums.FloorInfoFloorType? floorType;
  static enums.FloorInfoFloorType? floorInfoFloorTypeFloorTypeNullableFromJson(
    Object? value,
  ) => floorInfoFloorTypeNullableFromJson(
    value,
    enums.FloorInfoFloorType.onground,
  );

  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$FloorInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorInfo &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.floorPlan, floorPlan) ||
                const DeepCollectionEquality().equals(
                  other.floorPlan,
                  floorPlan,
                )) &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.floorLevel, floorLevel) ||
                const DeepCollectionEquality().equals(
                  other.floorLevel,
                  floorLevel,
                )) &&
            (identical(other.floorType, floorType) ||
                const DeepCollectionEquality().equals(
                  other.floorType,
                  floorType,
                )) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(floorPlan) ^
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(floorLevel) ^
      const DeepCollectionEquality().hash(floorType) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $FloorInfoExtension on FloorInfo {
  FloorInfo copyWith({
    String? premiseId,
    String? facilityId,
    String? name,
    String? description,
    List<String>? tags,
    String? floorPlan,
    List<String>? assets,
    List<String>? roles,
    GeoLocation? location,
    GeoLocation? fence,
    int? floorLevel,
    enums.FloorInfoFloorType? floorType,
    int? reportedStamp,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
  }) {
    return FloorInfo(
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      floorPlan: floorPlan ?? this.floorPlan,
      assets: assets ?? this.assets,
      roles: roles ?? this.roles,
      location: location ?? this.location,
      fence: fence ?? this.fence,
      floorLevel: floorLevel ?? this.floorLevel,
      floorType: floorType ?? this.floorType,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
    );
  }

  FloorInfo copyWithWrapped({
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? floorPlan,
    Wrapped<List<String>?>? assets,
    Wrapped<List<String>?>? roles,
    Wrapped<GeoLocation?>? location,
    Wrapped<GeoLocation?>? fence,
    Wrapped<int?>? floorLevel,
    Wrapped<enums.FloorInfoFloorType?>? floorType,
    Wrapped<int?>? reportedStamp,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
  }) {
    return FloorInfo(
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      floorPlan: (floorPlan != null ? floorPlan.value : this.floorPlan),
      assets: (assets != null ? assets.value : this.assets),
      roles: (roles != null ? roles.value : this.roles),
      location: (location != null ? location.value : this.location),
      fence: (fence != null ? fence.value : this.fence),
      floorLevel: (floorLevel != null ? floorLevel.value : this.floorLevel),
      floorType: (floorType != null ? floorType.value : this.floorType),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Floor {
  const Floor({
    this.premiseId,
    this.facilityId,
    required this.name,
    this.description,
    this.tags,
    this.floorPlan,
    this.assets,
    this.roles,
    this.location,
    this.fence,
    this.floorLevel,
    this.floorType,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Floor.fromJson(Map<String, dynamic> json) => _$FloorFromJson(json);

  static const toJsonFactory = _$FloorToJson;
  Map<String, dynamic> toJson() => _$FloorToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'floorPlan', includeIfNull: false, defaultValue: '')
  final String? floorPlan;
  @JsonKey(name: 'assets', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assets;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'fence', includeIfNull: false)
  final GeoLocation? fence;
  @JsonKey(name: 'floorLevel', includeIfNull: false)
  final int? floorLevel;
  @JsonKey(
    name: 'floorType',
    includeIfNull: false,
    toJson: floorFloorTypeNullableToJson,
    fromJson: floorFloorTypeFloorTypeNullableFromJson,
  )
  final enums.FloorFloorType? floorType;
  static enums.FloorFloorType? floorFloorTypeFloorTypeNullableFromJson(
    Object? value,
  ) => floorFloorTypeNullableFromJson(value, enums.FloorFloorType.onground);

  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$FloorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Floor &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.floorPlan, floorPlan) ||
                const DeepCollectionEquality().equals(
                  other.floorPlan,
                  floorPlan,
                )) &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.floorLevel, floorLevel) ||
                const DeepCollectionEquality().equals(
                  other.floorLevel,
                  floorLevel,
                )) &&
            (identical(other.floorType, floorType) ||
                const DeepCollectionEquality().equals(
                  other.floorType,
                  floorType,
                )) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(floorPlan) ^
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(floorLevel) ^
      const DeepCollectionEquality().hash(floorType) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $FloorExtension on Floor {
  Floor copyWith({
    String? premiseId,
    String? facilityId,
    String? name,
    String? description,
    List<String>? tags,
    String? floorPlan,
    List<String>? assets,
    List<String>? roles,
    GeoLocation? location,
    GeoLocation? fence,
    int? floorLevel,
    enums.FloorFloorType? floorType,
    int? reportedStamp,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Floor(
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      floorPlan: floorPlan ?? this.floorPlan,
      assets: assets ?? this.assets,
      roles: roles ?? this.roles,
      location: location ?? this.location,
      fence: fence ?? this.fence,
      floorLevel: floorLevel ?? this.floorLevel,
      floorType: floorType ?? this.floorType,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Floor copyWithWrapped({
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? floorPlan,
    Wrapped<List<String>?>? assets,
    Wrapped<List<String>?>? roles,
    Wrapped<GeoLocation?>? location,
    Wrapped<GeoLocation?>? fence,
    Wrapped<int?>? floorLevel,
    Wrapped<enums.FloorFloorType?>? floorType,
    Wrapped<int?>? reportedStamp,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Floor(
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      floorPlan: (floorPlan != null ? floorPlan.value : this.floorPlan),
      assets: (assets != null ? assets.value : this.assets),
      roles: (roles != null ? roles.value : this.roles),
      location: (location != null ? location.value : this.location),
      fence: (fence != null ? fence.value : this.fence),
      floorLevel: (floorLevel != null ? floorLevel.value : this.floorLevel),
      floorType: (floorType != null ? floorType.value : this.floorType),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FloorEntity {
  const FloorEntity({this.entity});

  factory FloorEntity.fromJson(Map<String, dynamic> json) =>
      _$FloorEntityFromJson(json);

  static const toJsonFactory = _$FloorEntityToJson;
  Map<String, dynamic> toJson() => _$FloorEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Floor? entity;
  static const fromJsonFactory = _$FloorEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FloorEntityExtension on FloorEntity {
  FloorEntity copyWith({Floor? entity}) {
    return FloorEntity(entity: entity ?? this.entity);
  }

  FloorEntity copyWithWrapped({Wrapped<Floor?>? entity}) {
    return FloorEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorEntityRes {
  const FloorEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory FloorEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FloorEntityResFromJson(json);

  static const toJsonFactory = _$FloorEntityResToJson;
  Map<String, dynamic> toJson() => _$FloorEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Floor? entity;
  static const fromJsonFactory = _$FloorEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $FloorEntityResExtension on FloorEntityRes {
  FloorEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Floor? entity,
  }) {
    return FloorEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  FloorEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Floor?>? entity,
  }) {
    return FloorEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FloorArray {
  const FloorArray({this.values});

  factory FloorArray.fromJson(Map<String, dynamic> json) =>
      _$FloorArrayFromJson(json);

  static const toJsonFactory = _$FloorArrayToJson;
  Map<String, dynamic> toJson() => _$FloorArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Floor>[])
  final List<Floor>? values;
  static const fromJsonFactory = _$FloorArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $FloorArrayExtension on FloorArray {
  FloorArray copyWith({List<Floor>? values}) {
    return FloorArray(values: values ?? this.values);
  }

  FloorArray copyWithWrapped({Wrapped<List<Floor>?>? values}) {
    return FloorArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorArrayRes {
  const FloorArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory FloorArrayRes.fromJson(Map<String, dynamic> json) =>
      _$FloorArrayResFromJson(json);

  static const toJsonFactory = _$FloorArrayResToJson;
  Map<String, dynamic> toJson() => _$FloorArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Floor>[])
  final List<Floor>? values;
  static const fromJsonFactory = _$FloorArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $FloorArrayResExtension on FloorArrayRes {
  FloorArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Floor>? values,
  }) {
    return FloorArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  FloorArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Floor>?>? values,
  }) {
    return FloorArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetInfo {
  const AssetInfo({
    this.premiseId,
    this.facilityId,
    this.floorId,
    required this.name,
    this.description,
    this.tags,
    this.devices,
    this.roles,
    this.location,
    this.fence,
    this.position,
    required this.assetModelId,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
  });

  factory AssetInfo.fromJson(Map<String, dynamic> json) =>
      _$AssetInfoFromJson(json);

  static const toJsonFactory = _$AssetInfoToJson;
  Map<String, dynamic> toJson() => _$AssetInfoToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'devices', includeIfNull: false, defaultValue: <String>[])
  final List<String>? devices;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'fence', includeIfNull: false)
  final GeoLocation? fence;
  @JsonKey(name: 'position', includeIfNull: false)
  final ScreenPosition? position;
  @JsonKey(name: 'assetModelId', includeIfNull: false, defaultValue: '')
  final String assetModelId;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  static const fromJsonFactory = _$AssetInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetInfo &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality().equals(
                  other.floorId,
                  floorId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality().equals(
                  other.devices,
                  devices,
                )) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.assetModelId, assetModelId) ||
                const DeepCollectionEquality().equals(
                  other.assetModelId,
                  assetModelId,
                )) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(devices) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(assetModelId) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      runtimeType.hashCode;
}

extension $AssetInfoExtension on AssetInfo {
  AssetInfo copyWith({
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? name,
    String? description,
    List<String>? tags,
    List<String>? devices,
    List<String>? roles,
    GeoLocation? location,
    GeoLocation? fence,
    ScreenPosition? position,
    String? assetModelId,
    int? reportedStamp,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
  }) {
    return AssetInfo(
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      floorId: floorId ?? this.floorId,
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      devices: devices ?? this.devices,
      roles: roles ?? this.roles,
      location: location ?? this.location,
      fence: fence ?? this.fence,
      position: position ?? this.position,
      assetModelId: assetModelId ?? this.assetModelId,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
    );
  }

  AssetInfo copyWithWrapped({
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String?>? floorId,
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? devices,
    Wrapped<List<String>?>? roles,
    Wrapped<GeoLocation?>? location,
    Wrapped<GeoLocation?>? fence,
    Wrapped<ScreenPosition?>? position,
    Wrapped<String>? assetModelId,
    Wrapped<int?>? reportedStamp,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
  }) {
    return AssetInfo(
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      floorId: (floorId != null ? floorId.value : this.floorId),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      devices: (devices != null ? devices.value : this.devices),
      roles: (roles != null ? roles.value : this.roles),
      location: (location != null ? location.value : this.location),
      fence: (fence != null ? fence.value : this.fence),
      position: (position != null ? position.value : this.position),
      assetModelId: (assetModelId != null
          ? assetModelId.value
          : this.assetModelId),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetBase {
  const AssetBase({this.currentLocation});

  factory AssetBase.fromJson(Map<String, dynamic> json) =>
      _$AssetBaseFromJson(json);

  static const toJsonFactory = _$AssetBaseToJson;
  Map<String, dynamic> toJson() => _$AssetBaseToJson(this);

  @JsonKey(name: 'currentLocation', includeIfNull: false)
  final GeoLocation? currentLocation;
  static const fromJsonFactory = _$AssetBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetBase &&
            (identical(other.currentLocation, currentLocation) ||
                const DeepCollectionEquality().equals(
                  other.currentLocation,
                  currentLocation,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentLocation) ^
      runtimeType.hashCode;
}

extension $AssetBaseExtension on AssetBase {
  AssetBase copyWith({GeoLocation? currentLocation}) {
    return AssetBase(currentLocation: currentLocation ?? this.currentLocation);
  }

  AssetBase copyWithWrapped({Wrapped<GeoLocation?>? currentLocation}) {
    return AssetBase(
      currentLocation: (currentLocation != null
          ? currentLocation.value
          : this.currentLocation),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Asset {
  const Asset({
    this.premiseId,
    this.facilityId,
    this.floorId,
    required this.name,
    this.description,
    this.tags,
    this.devices,
    this.roles,
    this.location,
    this.fence,
    this.position,
    required this.assetModelId,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
    this.currentLocation,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
  });

  factory Asset.fromJson(Map<String, dynamic> json) => _$AssetFromJson(json);

  static const toJsonFactory = _$AssetToJson;
  Map<String, dynamic> toJson() => _$AssetToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'devices', includeIfNull: false, defaultValue: <String>[])
  final List<String>? devices;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'fence', includeIfNull: false)
  final GeoLocation? fence;
  @JsonKey(name: 'position', includeIfNull: false)
  final ScreenPosition? position;
  @JsonKey(name: 'assetModelId', includeIfNull: false, defaultValue: '')
  final String assetModelId;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'currentLocation', includeIfNull: false)
  final GeoLocation? currentLocation;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  static const fromJsonFactory = _$AssetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Asset &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality().equals(
                  other.facilityId,
                  facilityId,
                )) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality().equals(
                  other.floorId,
                  floorId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality().equals(
                  other.devices,
                  devices,
                )) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.assetModelId, assetModelId) ||
                const DeepCollectionEquality().equals(
                  other.assetModelId,
                  assetModelId,
                )) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.currentLocation, currentLocation) ||
                const DeepCollectionEquality().equals(
                  other.currentLocation,
                  currentLocation,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(devices) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(assetModelId) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(currentLocation) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      runtimeType.hashCode;
}

extension $AssetExtension on Asset {
  Asset copyWith({
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? name,
    String? description,
    List<String>? tags,
    List<String>? devices,
    List<String>? roles,
    GeoLocation? location,
    GeoLocation? fence,
    ScreenPosition? position,
    String? assetModelId,
    int? reportedStamp,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
    GeoLocation? currentLocation,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
  }) {
    return Asset(
      premiseId: premiseId ?? this.premiseId,
      facilityId: facilityId ?? this.facilityId,
      floorId: floorId ?? this.floorId,
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      devices: devices ?? this.devices,
      roles: roles ?? this.roles,
      location: location ?? this.location,
      fence: fence ?? this.fence,
      position: position ?? this.position,
      assetModelId: assetModelId ?? this.assetModelId,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
      currentLocation: currentLocation ?? this.currentLocation,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
    );
  }

  Asset copyWithWrapped({
    Wrapped<String?>? premiseId,
    Wrapped<String?>? facilityId,
    Wrapped<String?>? floorId,
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<List<String>?>? devices,
    Wrapped<List<String>?>? roles,
    Wrapped<GeoLocation?>? location,
    Wrapped<GeoLocation?>? fence,
    Wrapped<ScreenPosition?>? position,
    Wrapped<String>? assetModelId,
    Wrapped<int?>? reportedStamp,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
    Wrapped<GeoLocation?>? currentLocation,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
  }) {
    return Asset(
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      facilityId: (facilityId != null ? facilityId.value : this.facilityId),
      floorId: (floorId != null ? floorId.value : this.floorId),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      devices: (devices != null ? devices.value : this.devices),
      roles: (roles != null ? roles.value : this.roles),
      location: (location != null ? location.value : this.location),
      fence: (fence != null ? fence.value : this.fence),
      position: (position != null ? position.value : this.position),
      assetModelId: (assetModelId != null
          ? assetModelId.value
          : this.assetModelId),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
      currentLocation: (currentLocation != null
          ? currentLocation.value
          : this.currentLocation),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetEntity {
  const AssetEntity({this.entity});

  factory AssetEntity.fromJson(Map<String, dynamic> json) =>
      _$AssetEntityFromJson(json);

  static const toJsonFactory = _$AssetEntityToJson;
  Map<String, dynamic> toJson() => _$AssetEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Asset? entity;
  static const fromJsonFactory = _$AssetEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AssetEntityExtension on AssetEntity {
  AssetEntity copyWith({Asset? entity}) {
    return AssetEntity(entity: entity ?? this.entity);
  }

  AssetEntity copyWithWrapped({Wrapped<Asset?>? entity}) {
    return AssetEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetEntityRes {
  const AssetEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AssetEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AssetEntityResFromJson(json);

  static const toJsonFactory = _$AssetEntityResToJson;
  Map<String, dynamic> toJson() => _$AssetEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Asset? entity;
  static const fromJsonFactory = _$AssetEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AssetEntityResExtension on AssetEntityRes {
  AssetEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Asset? entity,
  }) {
    return AssetEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  AssetEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Asset?>? entity,
  }) {
    return AssetEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetArray {
  const AssetArray({this.values});

  factory AssetArray.fromJson(Map<String, dynamic> json) =>
      _$AssetArrayFromJson(json);

  static const toJsonFactory = _$AssetArrayToJson;
  Map<String, dynamic> toJson() => _$AssetArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Asset>[])
  final List<Asset>? values;
  static const fromJsonFactory = _$AssetArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AssetArrayExtension on AssetArray {
  AssetArray copyWith({List<Asset>? values}) {
    return AssetArray(values: values ?? this.values);
  }

  AssetArray copyWithWrapped({Wrapped<List<Asset>?>? values}) {
    return AssetArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetArrayRes {
  const AssetArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AssetArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AssetArrayResFromJson(json);

  static const toJsonFactory = _$AssetArrayResToJson;
  Map<String, dynamic> toJson() => _$AssetArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Asset>[])
  final List<Asset>? values;
  static const fromJsonFactory = _$AssetArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AssetArrayResExtension on AssetArrayRes {
  AssetArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Asset>? values,
  }) {
    return AssetArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  AssetArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Asset>?>? values,
  }) {
    return AssetArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityInfo {
  const FacilityInfo({
    required this.name,
    this.description,
    this.premiseId,
    this.tags,
    this.selectedImage,
    this.images,
    this.roles,
    this.location,
    this.fence,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
  });

  factory FacilityInfo.fromJson(Map<String, dynamic> json) =>
      _$FacilityInfoFromJson(json);

  static const toJsonFactory = _$FacilityInfoToJson;
  Map<String, dynamic> toJson() => _$FacilityInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'fence', includeIfNull: false)
  final GeoLocation? fence;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$FacilityInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality().equals(
                  other.selectedImage,
                  selectedImage,
                )) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $FacilityInfoExtension on FacilityInfo {
  FacilityInfo copyWith({
    String? name,
    String? description,
    String? premiseId,
    List<String>? tags,
    int? selectedImage,
    List<String>? images,
    List<String>? roles,
    GeoLocation? location,
    GeoLocation? fence,
    int? reportedStamp,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
  }) {
    return FacilityInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      premiseId: premiseId ?? this.premiseId,
      tags: tags ?? this.tags,
      selectedImage: selectedImage ?? this.selectedImage,
      images: images ?? this.images,
      roles: roles ?? this.roles,
      location: location ?? this.location,
      fence: fence ?? this.fence,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
    );
  }

  FacilityInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? premiseId,
    Wrapped<List<String>?>? tags,
    Wrapped<int?>? selectedImage,
    Wrapped<List<String>?>? images,
    Wrapped<List<String>?>? roles,
    Wrapped<GeoLocation?>? location,
    Wrapped<GeoLocation?>? fence,
    Wrapped<int?>? reportedStamp,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
  }) {
    return FacilityInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      tags: (tags != null ? tags.value : this.tags),
      selectedImage: (selectedImage != null
          ? selectedImage.value
          : this.selectedImage),
      images: (images != null ? images.value : this.images),
      roles: (roles != null ? roles.value : this.roles),
      location: (location != null ? location.value : this.location),
      fence: (fence != null ? fence.value : this.fence),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Facility {
  const Facility({
    required this.name,
    this.description,
    this.premiseId,
    this.tags,
    this.selectedImage,
    this.images,
    this.roles,
    this.location,
    this.fence,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Facility.fromJson(Map<String, dynamic> json) =>
      _$FacilityFromJson(json);

  static const toJsonFactory = _$FacilityToJson;
  Map<String, dynamic> toJson() => _$FacilityToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'fence', includeIfNull: false)
  final GeoLocation? fence;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$FacilityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Facility &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality().equals(
                  other.premiseId,
                  premiseId,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality().equals(
                  other.selectedImage,
                  selectedImage,
                )) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $FacilityExtension on Facility {
  Facility copyWith({
    String? name,
    String? description,
    String? premiseId,
    List<String>? tags,
    int? selectedImage,
    List<String>? images,
    List<String>? roles,
    GeoLocation? location,
    GeoLocation? fence,
    int? reportedStamp,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Facility(
      name: name ?? this.name,
      description: description ?? this.description,
      premiseId: premiseId ?? this.premiseId,
      tags: tags ?? this.tags,
      selectedImage: selectedImage ?? this.selectedImage,
      images: images ?? this.images,
      roles: roles ?? this.roles,
      location: location ?? this.location,
      fence: fence ?? this.fence,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Facility copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? premiseId,
    Wrapped<List<String>?>? tags,
    Wrapped<int?>? selectedImage,
    Wrapped<List<String>?>? images,
    Wrapped<List<String>?>? roles,
    Wrapped<GeoLocation?>? location,
    Wrapped<GeoLocation?>? fence,
    Wrapped<int?>? reportedStamp,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Facility(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      premiseId: (premiseId != null ? premiseId.value : this.premiseId),
      tags: (tags != null ? tags.value : this.tags),
      selectedImage: (selectedImage != null
          ? selectedImage.value
          : this.selectedImage),
      images: (images != null ? images.value : this.images),
      roles: (roles != null ? roles.value : this.roles),
      location: (location != null ? location.value : this.location),
      fence: (fence != null ? fence.value : this.fence),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityEntity {
  const FacilityEntity({this.entity});

  factory FacilityEntity.fromJson(Map<String, dynamic> json) =>
      _$FacilityEntityFromJson(json);

  static const toJsonFactory = _$FacilityEntityToJson;
  Map<String, dynamic> toJson() => _$FacilityEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Facility? entity;
  static const fromJsonFactory = _$FacilityEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FacilityEntityExtension on FacilityEntity {
  FacilityEntity copyWith({Facility? entity}) {
    return FacilityEntity(entity: entity ?? this.entity);
  }

  FacilityEntity copyWithWrapped({Wrapped<Facility?>? entity}) {
    return FacilityEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityEntityRes {
  const FacilityEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory FacilityEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FacilityEntityResFromJson(json);

  static const toJsonFactory = _$FacilityEntityResToJson;
  Map<String, dynamic> toJson() => _$FacilityEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Facility? entity;
  static const fromJsonFactory = _$FacilityEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $FacilityEntityResExtension on FacilityEntityRes {
  FacilityEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Facility? entity,
  }) {
    return FacilityEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  FacilityEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Facility?>? entity,
  }) {
    return FacilityEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityArray {
  const FacilityArray({this.values});

  factory FacilityArray.fromJson(Map<String, dynamic> json) =>
      _$FacilityArrayFromJson(json);

  static const toJsonFactory = _$FacilityArrayToJson;
  Map<String, dynamic> toJson() => _$FacilityArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Facility>[])
  final List<Facility>? values;
  static const fromJsonFactory = _$FacilityArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $FacilityArrayExtension on FacilityArray {
  FacilityArray copyWith({List<Facility>? values}) {
    return FacilityArray(values: values ?? this.values);
  }

  FacilityArray copyWithWrapped({Wrapped<List<Facility>?>? values}) {
    return FacilityArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityArrayRes {
  const FacilityArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory FacilityArrayRes.fromJson(Map<String, dynamic> json) =>
      _$FacilityArrayResFromJson(json);

  static const toJsonFactory = _$FacilityArrayResToJson;
  Map<String, dynamic> toJson() => _$FacilityArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Facility>[])
  final List<Facility>? values;
  static const fromJsonFactory = _$FacilityArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $FacilityArrayResExtension on FacilityArrayRes {
  FacilityArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Facility>? values,
  }) {
    return FacilityArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  FacilityArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Facility>?>? values,
  }) {
    return FacilityArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserInfo {
  const UserInfo({required this.user, required this.domain, this.$client});

  factory UserInfo.fromJson(Map<String, dynamic> json) =>
      _$UserInfoFromJson(json);

  static const toJsonFactory = _$UserInfoToJson;
  Map<String, dynamic> toJson() => _$UserInfoToJson(this);

  @JsonKey(name: 'user', includeIfNull: false)
  final TwinLoggedInUser user;
  @JsonKey(name: 'domain', includeIfNull: false)
  final Domain domain;
  @JsonKey(name: 'client', includeIfNull: false)
  final Client? $client;
  static const fromJsonFactory = _$UserInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserInfo &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.domain, domain) ||
                const DeepCollectionEquality().equals(other.domain, domain)) &&
            (identical(other.$client, $client) ||
                const DeepCollectionEquality().equals(other.$client, $client)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(domain) ^
      const DeepCollectionEquality().hash($client) ^
      runtimeType.hashCode;
}

extension $UserInfoExtension on UserInfo {
  UserInfo copyWith({TwinLoggedInUser? user, Domain? domain, Client? $client}) {
    return UserInfo(
      user: user ?? this.user,
      domain: domain ?? this.domain,
      $client: $client ?? this.$client,
    );
  }

  UserInfo copyWithWrapped({
    Wrapped<TwinLoggedInUser>? user,
    Wrapped<Domain>? domain,
    Wrapped<Client?>? $client,
  }) {
    return UserInfo(
      user: (user != null ? user.value : this.user),
      domain: (domain != null ? domain.value : this.domain),
      $client: ($client != null ? $client.value : this.$client),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserInfo {
  const TwinUserInfo({
    required this.name,
    required this.email,
    this.description,
    this.tags,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
    this.selectedImage,
    this.images,
    this.roles,
  });

  factory TwinUserInfo.fromJson(Map<String, dynamic> json) =>
      _$TwinUserInfoFromJson(json);

  static const toJsonFactory = _$TwinUserInfoToJson;
  Map<String, dynamic> toJson() => _$TwinUserInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  static const fromJsonFactory = _$TwinUserInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality().equals(
                  other.selectedImage,
                  selectedImage,
                )) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      runtimeType.hashCode;
}

extension $TwinUserInfoExtension on TwinUserInfo {
  TwinUserInfo copyWith({
    String? name,
    String? email,
    String? description,
    List<String>? tags,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
    int? selectedImage,
    List<String>? images,
    List<String>? roles,
  }) {
    return TwinUserInfo(
      name: name ?? this.name,
      email: email ?? this.email,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
      selectedImage: selectedImage ?? this.selectedImage,
      images: images ?? this.images,
      roles: roles ?? this.roles,
    );
  }

  TwinUserInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? email,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
    Wrapped<int?>? selectedImage,
    Wrapped<List<String>?>? images,
    Wrapped<List<String>?>? roles,
  }) {
    return TwinUserInfo(
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
      selectedImage: (selectedImage != null
          ? selectedImage.value
          : this.selectedImage),
      images: (images != null ? images.value : this.images),
      roles: (roles != null ? roles.value : this.roles),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserExt {
  const TwinUserExt({this.password});

  factory TwinUserExt.fromJson(Map<String, dynamic> json) =>
      _$TwinUserExtFromJson(json);

  static const toJsonFactory = _$TwinUserExtToJson;
  Map<String, dynamic> toJson() => _$TwinUserExtToJson(this);

  @JsonKey(name: 'password', includeIfNull: false, defaultValue: '')
  final String? password;
  static const fromJsonFactory = _$TwinUserExtFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserExt &&
            (identical(other.password, password) ||
                const DeepCollectionEquality().equals(
                  other.password,
                  password,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(password) ^ runtimeType.hashCode;
}

extension $TwinUserExtExtension on TwinUserExt {
  TwinUserExt copyWith({String? password}) {
    return TwinUserExt(password: password ?? this.password);
  }

  TwinUserExt copyWithWrapped({Wrapped<String?>? password}) {
    return TwinUserExt(
      password: (password != null ? password.value : this.password),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUser {
  const TwinUser({
    this.domainKey,
    this.entityState,
    required this.name,
    required this.email,
    this.description,
    this.tags,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
    this.selectedImage,
    this.images,
    this.roles,
    this.password,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory TwinUser.fromJson(Map<String, dynamic> json) =>
      _$TwinUserFromJson(json);

  static const toJsonFactory = _$TwinUserToJson;
  Map<String, dynamic> toJson() => _$TwinUserToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(
    name: 'entityState',
    includeIfNull: false,
    toJson: twinUserEntityStateNullableToJson,
    fromJson: twinUserEntityStateNullableFromJson,
  )
  final enums.TwinUserEntityState? entityState;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'password', includeIfNull: false, defaultValue: '')
  final String? password;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$TwinUserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUser &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.entityState, entityState) ||
                const DeepCollectionEquality().equals(
                  other.entityState,
                  entityState,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality().equals(
                  other.selectedImage,
                  selectedImage,
                )) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality().equals(
                  other.password,
                  password,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(entityState) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $TwinUserExtension on TwinUser {
  TwinUser copyWith({
    String? domainKey,
    enums.TwinUserEntityState? entityState,
    String? name,
    String? email,
    String? description,
    List<String>? tags,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
    int? selectedImage,
    List<String>? images,
    List<String>? roles,
    String? password,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return TwinUser(
      domainKey: domainKey ?? this.domainKey,
      entityState: entityState ?? this.entityState,
      name: name ?? this.name,
      email: email ?? this.email,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
      selectedImage: selectedImage ?? this.selectedImage,
      images: images ?? this.images,
      roles: roles ?? this.roles,
      password: password ?? this.password,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  TwinUser copyWithWrapped({
    Wrapped<String?>? domainKey,
    Wrapped<enums.TwinUserEntityState?>? entityState,
    Wrapped<String>? name,
    Wrapped<String>? email,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
    Wrapped<int?>? selectedImage,
    Wrapped<List<String>?>? images,
    Wrapped<List<String>?>? roles,
    Wrapped<String?>? password,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return TwinUser(
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      entityState: (entityState != null ? entityState.value : this.entityState),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
      selectedImage: (selectedImage != null
          ? selectedImage.value
          : this.selectedImage),
      images: (images != null ? images.value : this.images),
      roles: (roles != null ? roles.value : this.roles),
      password: (password != null ? password.value : this.password),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserTokenExt {
  const TwinUserTokenExt({required this.token});

  factory TwinUserTokenExt.fromJson(Map<String, dynamic> json) =>
      _$TwinUserTokenExtFromJson(json);

  static const toJsonFactory = _$TwinUserTokenExtToJson;
  Map<String, dynamic> toJson() => _$TwinUserTokenExtToJson(this);

  @JsonKey(name: 'token', includeIfNull: false, defaultValue: '')
  final String token;
  static const fromJsonFactory = _$TwinUserTokenExtFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserTokenExt &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^ runtimeType.hashCode;
}

extension $TwinUserTokenExtExtension on TwinUserTokenExt {
  TwinUserTokenExt copyWith({String? token}) {
    return TwinUserTokenExt(token: token ?? this.token);
  }

  TwinUserTokenExt copyWithWrapped({Wrapped<String>? token}) {
    return TwinUserTokenExt(token: (token != null ? token.value : this.token));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinLoggedInUser {
  const TwinLoggedInUser({
    required this.token,
    this.domainKey,
    this.entityState,
    required this.name,
    required this.email,
    this.description,
    this.tags,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
    this.selectedImage,
    this.images,
    this.roles,
    this.password,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory TwinLoggedInUser.fromJson(Map<String, dynamic> json) =>
      _$TwinLoggedInUserFromJson(json);

  static const toJsonFactory = _$TwinLoggedInUserToJson;
  Map<String, dynamic> toJson() => _$TwinLoggedInUserToJson(this);

  @JsonKey(name: 'token', includeIfNull: false, defaultValue: '')
  final String token;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(
    name: 'entityState',
    includeIfNull: false,
    toJson: twinLoggedInUserEntityStateNullableToJson,
    fromJson: twinLoggedInUserEntityStateNullableFromJson,
  )
  final enums.TwinLoggedInUserEntityState? entityState;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'password', includeIfNull: false, defaultValue: '')
  final String? password;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$TwinLoggedInUserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinLoggedInUser &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.entityState, entityState) ||
                const DeepCollectionEquality().equals(
                  other.entityState,
                  entityState,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality().equals(
                  other.selectedImage,
                  selectedImage,
                )) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality().equals(
                  other.password,
                  password,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(entityState) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $TwinLoggedInUserExtension on TwinLoggedInUser {
  TwinLoggedInUser copyWith({
    String? token,
    String? domainKey,
    enums.TwinLoggedInUserEntityState? entityState,
    String? name,
    String? email,
    String? description,
    List<String>? tags,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
    int? selectedImage,
    List<String>? images,
    List<String>? roles,
    String? password,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return TwinLoggedInUser(
      token: token ?? this.token,
      domainKey: domainKey ?? this.domainKey,
      entityState: entityState ?? this.entityState,
      name: name ?? this.name,
      email: email ?? this.email,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
      selectedImage: selectedImage ?? this.selectedImage,
      images: images ?? this.images,
      roles: roles ?? this.roles,
      password: password ?? this.password,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  TwinLoggedInUser copyWithWrapped({
    Wrapped<String>? token,
    Wrapped<String?>? domainKey,
    Wrapped<enums.TwinLoggedInUserEntityState?>? entityState,
    Wrapped<String>? name,
    Wrapped<String>? email,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
    Wrapped<int?>? selectedImage,
    Wrapped<List<String>?>? images,
    Wrapped<List<String>?>? roles,
    Wrapped<String?>? password,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return TwinLoggedInUser(
      token: (token != null ? token.value : this.token),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      entityState: (entityState != null ? entityState.value : this.entityState),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
      selectedImage: (selectedImage != null
          ? selectedImage.value
          : this.selectedImage),
      images: (images != null ? images.value : this.images),
      roles: (roles != null ? roles.value : this.roles),
      password: (password != null ? password.value : this.password),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserEntity {
  const TwinUserEntity({this.entity});

  factory TwinUserEntity.fromJson(Map<String, dynamic> json) =>
      _$TwinUserEntityFromJson(json);

  static const toJsonFactory = _$TwinUserEntityToJson;
  Map<String, dynamic> toJson() => _$TwinUserEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinUser? entity;
  static const fromJsonFactory = _$TwinUserEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $TwinUserEntityExtension on TwinUserEntity {
  TwinUserEntity copyWith({TwinUser? entity}) {
    return TwinUserEntity(entity: entity ?? this.entity);
  }

  TwinUserEntity copyWithWrapped({Wrapped<TwinUser?>? entity}) {
    return TwinUserEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserEntityRes {
  const TwinUserEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory TwinUserEntityRes.fromJson(Map<String, dynamic> json) =>
      _$TwinUserEntityResFromJson(json);

  static const toJsonFactory = _$TwinUserEntityResToJson;
  Map<String, dynamic> toJson() => _$TwinUserEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinUser? entity;
  static const fromJsonFactory = _$TwinUserEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $TwinUserEntityResExtension on TwinUserEntityRes {
  TwinUserEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    TwinUser? entity,
  }) {
    return TwinUserEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  TwinUserEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<TwinUser?>? entity,
  }) {
    return TwinUserEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserArray {
  const TwinUserArray({this.values});

  factory TwinUserArray.fromJson(Map<String, dynamic> json) =>
      _$TwinUserArrayFromJson(json);

  static const toJsonFactory = _$TwinUserArrayToJson;
  Map<String, dynamic> toJson() => _$TwinUserArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TwinUser>[])
  final List<TwinUser>? values;
  static const fromJsonFactory = _$TwinUserArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TwinUserArrayExtension on TwinUserArray {
  TwinUserArray copyWith({List<TwinUser>? values}) {
    return TwinUserArray(values: values ?? this.values);
  }

  TwinUserArray copyWithWrapped({Wrapped<List<TwinUser>?>? values}) {
    return TwinUserArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserArrayRes {
  const TwinUserArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TwinUserArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TwinUserArrayResFromJson(json);

  static const toJsonFactory = _$TwinUserArrayResToJson;
  Map<String, dynamic> toJson() => _$TwinUserArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TwinUser>[])
  final List<TwinUser>? values;
  static const fromJsonFactory = _$TwinUserArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TwinUserArrayResExtension on TwinUserArrayRes {
  TwinUserArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<TwinUser>? values,
  }) {
    return TwinUserArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  TwinUserArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<TwinUser>?>? values,
  }) {
    return TwinUserArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RoleInfo {
  const RoleInfo({required this.name, this.description, this.tags});

  factory RoleInfo.fromJson(Map<String, dynamic> json) =>
      _$RoleInfoFromJson(json);

  static const toJsonFactory = _$RoleInfoToJson;
  Map<String, dynamic> toJson() => _$RoleInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$RoleInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $RoleInfoExtension on RoleInfo {
  RoleInfo copyWith({String? name, String? description, List<String>? tags}) {
    return RoleInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
    );
  }

  RoleInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
  }) {
    return RoleInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Role {
  const Role({
    required this.name,
    this.description,
    this.tags,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Role.fromJson(Map<String, dynamic> json) => _$RoleFromJson(json);

  static const toJsonFactory = _$RoleToJson;
  Map<String, dynamic> toJson() => _$RoleToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$RoleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Role &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $RoleExtension on Role {
  Role copyWith({
    String? name,
    String? description,
    List<String>? tags,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Role(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Role copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Role(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RoleEntity {
  const RoleEntity({this.entity});

  factory RoleEntity.fromJson(Map<String, dynamic> json) =>
      _$RoleEntityFromJson(json);

  static const toJsonFactory = _$RoleEntityToJson;
  Map<String, dynamic> toJson() => _$RoleEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Role? entity;
  static const fromJsonFactory = _$RoleEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $RoleEntityExtension on RoleEntity {
  RoleEntity copyWith({Role? entity}) {
    return RoleEntity(entity: entity ?? this.entity);
  }

  RoleEntity copyWithWrapped({Wrapped<Role?>? entity}) {
    return RoleEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class RoleEntityRes {
  const RoleEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory RoleEntityRes.fromJson(Map<String, dynamic> json) =>
      _$RoleEntityResFromJson(json);

  static const toJsonFactory = _$RoleEntityResToJson;
  Map<String, dynamic> toJson() => _$RoleEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Role? entity;
  static const fromJsonFactory = _$RoleEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $RoleEntityResExtension on RoleEntityRes {
  RoleEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Role? entity,
  }) {
    return RoleEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  RoleEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Role?>? entity,
  }) {
    return RoleEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RoleArray {
  const RoleArray({this.values});

  factory RoleArray.fromJson(Map<String, dynamic> json) =>
      _$RoleArrayFromJson(json);

  static const toJsonFactory = _$RoleArrayToJson;
  Map<String, dynamic> toJson() => _$RoleArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Role>[])
  final List<Role>? values;
  static const fromJsonFactory = _$RoleArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $RoleArrayExtension on RoleArray {
  RoleArray copyWith({List<Role>? values}) {
    return RoleArray(values: values ?? this.values);
  }

  RoleArray copyWithWrapped({Wrapped<List<Role>?>? values}) {
    return RoleArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class RoleArrayRes {
  const RoleArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory RoleArrayRes.fromJson(Map<String, dynamic> json) =>
      _$RoleArrayResFromJson(json);

  static const toJsonFactory = _$RoleArrayResToJson;
  Map<String, dynamic> toJson() => _$RoleArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Role>[])
  final List<Role>? values;
  static const fromJsonFactory = _$RoleArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $RoleArrayResExtension on RoleArrayRes {
  RoleArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Role>? values,
  }) {
    return RoleArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  RoleArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Role>?>? values,
  }) {
    return RoleArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseInfo {
  const PremiseInfo({
    required this.name,
    this.description,
    this.tags,
    this.selectedImage,
    this.images,
    this.location,
    this.fence,
    this.roles,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
  });

  factory PremiseInfo.fromJson(Map<String, dynamic> json) =>
      _$PremiseInfoFromJson(json);

  static const toJsonFactory = _$PremiseInfoToJson;
  Map<String, dynamic> toJson() => _$PremiseInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'fence', includeIfNull: false)
  final GeoLocation? fence;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$PremiseInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality().equals(
                  other.selectedImage,
                  selectedImage,
                )) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $PremiseInfoExtension on PremiseInfo {
  PremiseInfo copyWith({
    String? name,
    String? description,
    List<String>? tags,
    int? selectedImage,
    List<String>? images,
    GeoLocation? location,
    GeoLocation? fence,
    List<String>? roles,
    int? reportedStamp,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
  }) {
    return PremiseInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      selectedImage: selectedImage ?? this.selectedImage,
      images: images ?? this.images,
      location: location ?? this.location,
      fence: fence ?? this.fence,
      roles: roles ?? this.roles,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
    );
  }

  PremiseInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<int?>? selectedImage,
    Wrapped<List<String>?>? images,
    Wrapped<GeoLocation?>? location,
    Wrapped<GeoLocation?>? fence,
    Wrapped<List<String>?>? roles,
    Wrapped<int?>? reportedStamp,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
  }) {
    return PremiseInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      selectedImage: (selectedImage != null
          ? selectedImage.value
          : this.selectedImage),
      images: (images != null ? images.value : this.images),
      location: (location != null ? location.value : this.location),
      fence: (fence != null ? fence.value : this.fence),
      roles: (roles != null ? roles.value : this.roles),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Premise {
  const Premise({
    required this.name,
    this.description,
    this.tags,
    this.selectedImage,
    this.images,
    this.location,
    this.fence,
    this.roles,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Premise.fromJson(Map<String, dynamic> json) =>
      _$PremiseFromJson(json);

  static const toJsonFactory = _$PremiseToJson;
  Map<String, dynamic> toJson() => _$PremiseToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'fence', includeIfNull: false)
  final GeoLocation? fence;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$PremiseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Premise &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality().equals(
                  other.selectedImage,
                  selectedImage,
                )) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality().equals(
                  other.reportedStamp,
                  reportedStamp,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $PremiseExtension on Premise {
  Premise copyWith({
    String? name,
    String? description,
    List<String>? tags,
    int? selectedImage,
    List<String>? images,
    GeoLocation? location,
    GeoLocation? fence,
    List<String>? roles,
    int? reportedStamp,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Premise(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      selectedImage: selectedImage ?? this.selectedImage,
      images: images ?? this.images,
      location: location ?? this.location,
      fence: fence ?? this.fence,
      roles: roles ?? this.roles,
      reportedStamp: reportedStamp ?? this.reportedStamp,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Premise copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<int?>? selectedImage,
    Wrapped<List<String>?>? images,
    Wrapped<GeoLocation?>? location,
    Wrapped<GeoLocation?>? fence,
    Wrapped<List<String>?>? roles,
    Wrapped<int?>? reportedStamp,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Premise(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      selectedImage: (selectedImage != null
          ? selectedImage.value
          : this.selectedImage),
      images: (images != null ? images.value : this.images),
      location: (location != null ? location.value : this.location),
      fence: (fence != null ? fence.value : this.fence),
      roles: (roles != null ? roles.value : this.roles),
      reportedStamp: (reportedStamp != null
          ? reportedStamp.value
          : this.reportedStamp),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseEntity {
  const PremiseEntity({this.entity});

  factory PremiseEntity.fromJson(Map<String, dynamic> json) =>
      _$PremiseEntityFromJson(json);

  static const toJsonFactory = _$PremiseEntityToJson;
  Map<String, dynamic> toJson() => _$PremiseEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Premise? entity;
  static const fromJsonFactory = _$PremiseEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $PremiseEntityExtension on PremiseEntity {
  PremiseEntity copyWith({Premise? entity}) {
    return PremiseEntity(entity: entity ?? this.entity);
  }

  PremiseEntity copyWithWrapped({Wrapped<Premise?>? entity}) {
    return PremiseEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseEntityRes {
  const PremiseEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory PremiseEntityRes.fromJson(Map<String, dynamic> json) =>
      _$PremiseEntityResFromJson(json);

  static const toJsonFactory = _$PremiseEntityResToJson;
  Map<String, dynamic> toJson() => _$PremiseEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Premise? entity;
  static const fromJsonFactory = _$PremiseEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $PremiseEntityResExtension on PremiseEntityRes {
  PremiseEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Premise? entity,
  }) {
    return PremiseEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  PremiseEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Premise?>? entity,
  }) {
    return PremiseEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseArray {
  const PremiseArray({this.values});

  factory PremiseArray.fromJson(Map<String, dynamic> json) =>
      _$PremiseArrayFromJson(json);

  static const toJsonFactory = _$PremiseArrayToJson;
  Map<String, dynamic> toJson() => _$PremiseArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Premise>[])
  final List<Premise>? values;
  static const fromJsonFactory = _$PremiseArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $PremiseArrayExtension on PremiseArray {
  PremiseArray copyWith({List<Premise>? values}) {
    return PremiseArray(values: values ?? this.values);
  }

  PremiseArray copyWithWrapped({Wrapped<List<Premise>?>? values}) {
    return PremiseArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseArrayRes {
  const PremiseArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory PremiseArrayRes.fromJson(Map<String, dynamic> json) =>
      _$PremiseArrayResFromJson(json);

  static const toJsonFactory = _$PremiseArrayResToJson;
  Map<String, dynamic> toJson() => _$PremiseArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Premise>[])
  final List<Premise>? values;
  static const fromJsonFactory = _$PremiseArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $PremiseArrayResExtension on PremiseArrayRes {
  PremiseArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Premise>? values,
  }) {
    return PremiseArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  PremiseArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Premise>?>? values,
  }) {
    return PremiseArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenPosition {
  const ScreenPosition({
    required this.topX,
    required this.topY,
    this.bottomX,
    this.bottomY,
  });

  factory ScreenPosition.fromJson(Map<String, dynamic> json) =>
      _$ScreenPositionFromJson(json);

  static const toJsonFactory = _$ScreenPositionToJson;
  Map<String, dynamic> toJson() => _$ScreenPositionToJson(this);

  @JsonKey(name: 'topX', includeIfNull: false)
  final int topX;
  @JsonKey(name: 'topY', includeIfNull: false)
  final int topY;
  @JsonKey(name: 'bottomX', includeIfNull: false)
  final int? bottomX;
  @JsonKey(name: 'bottomY', includeIfNull: false)
  final int? bottomY;
  static const fromJsonFactory = _$ScreenPositionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenPosition &&
            (identical(other.topX, topX) ||
                const DeepCollectionEquality().equals(other.topX, topX)) &&
            (identical(other.topY, topY) ||
                const DeepCollectionEquality().equals(other.topY, topY)) &&
            (identical(other.bottomX, bottomX) ||
                const DeepCollectionEquality().equals(
                  other.bottomX,
                  bottomX,
                )) &&
            (identical(other.bottomY, bottomY) ||
                const DeepCollectionEquality().equals(other.bottomY, bottomY)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(topX) ^
      const DeepCollectionEquality().hash(topY) ^
      const DeepCollectionEquality().hash(bottomX) ^
      const DeepCollectionEquality().hash(bottomY) ^
      runtimeType.hashCode;
}

extension $ScreenPositionExtension on ScreenPosition {
  ScreenPosition copyWith({int? topX, int? topY, int? bottomX, int? bottomY}) {
    return ScreenPosition(
      topX: topX ?? this.topX,
      topY: topY ?? this.topY,
      bottomX: bottomX ?? this.bottomX,
      bottomY: bottomY ?? this.bottomY,
    );
  }

  ScreenPosition copyWithWrapped({
    Wrapped<int>? topX,
    Wrapped<int>? topY,
    Wrapped<int?>? bottomX,
    Wrapped<int?>? bottomY,
  }) {
    return ScreenPosition(
      topX: (topX != null ? topX.value : this.topX),
      topY: (topY != null ? topY.value : this.topY),
      bottomX: (bottomX != null ? bottomX.value : this.bottomX),
      bottomY: (bottomY != null ? bottomY.value : this.bottomY),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Attribute {
  const Attribute({
    required this.name,
    this.description,
    this.label,
    required this.attributeType,
    required this.$value,
    this.editable,
    this.validator,
    this.allowedValues,
    this.allowedNumbers,
    this.allowedDecimals,
    this.minNumber,
    this.maxNumber,
    this.minDecimal,
    this.maxDecimal,
  });

  factory Attribute.fromJson(Map<String, dynamic> json) =>
      _$AttributeFromJson(json);

  static const toJsonFactory = _$AttributeToJson;
  Map<String, dynamic> toJson() => _$AttributeToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(
    name: 'attributeType',
    includeIfNull: false,
    toJson: attributeAttributeTypeToJson,
    fromJson: attributeAttributeTypeFromJson,
  )
  final enums.AttributeAttributeType attributeType;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String $value;
  @JsonKey(name: 'editable', includeIfNull: false, defaultValue: true)
  final bool? editable;
  @JsonKey(
    name: 'validator',
    includeIfNull: false,
    toJson: attributeValidatorNullableToJson,
    fromJson: attributeValidatorNullableFromJson,
  )
  final enums.AttributeValidator? validator;
  @JsonKey(
    name: 'allowedValues',
    includeIfNull: false,
    defaultValue: <String>[],
  )
  final List<String>? allowedValues;
  @JsonKey(name: 'allowedNumbers', includeIfNull: false, defaultValue: <int>[])
  final List<int>? allowedNumbers;
  @JsonKey(
    name: 'allowedDecimals',
    includeIfNull: false,
    defaultValue: <double>[],
  )
  final List<double>? allowedDecimals;
  @JsonKey(name: 'minNumber', includeIfNull: false)
  final int? minNumber;
  @JsonKey(name: 'maxNumber', includeIfNull: false)
  final int? maxNumber;
  @JsonKey(name: 'minDecimal', includeIfNull: false)
  final double? minDecimal;
  @JsonKey(name: 'maxDecimal', includeIfNull: false)
  final double? maxDecimal;
  static const fromJsonFactory = _$AttributeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Attribute &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.attributeType, attributeType) ||
                const DeepCollectionEquality().equals(
                  other.attributeType,
                  attributeType,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.editable, editable) ||
                const DeepCollectionEquality().equals(
                  other.editable,
                  editable,
                )) &&
            (identical(other.validator, validator) ||
                const DeepCollectionEquality().equals(
                  other.validator,
                  validator,
                )) &&
            (identical(other.allowedValues, allowedValues) ||
                const DeepCollectionEquality().equals(
                  other.allowedValues,
                  allowedValues,
                )) &&
            (identical(other.allowedNumbers, allowedNumbers) ||
                const DeepCollectionEquality().equals(
                  other.allowedNumbers,
                  allowedNumbers,
                )) &&
            (identical(other.allowedDecimals, allowedDecimals) ||
                const DeepCollectionEquality().equals(
                  other.allowedDecimals,
                  allowedDecimals,
                )) &&
            (identical(other.minNumber, minNumber) ||
                const DeepCollectionEquality().equals(
                  other.minNumber,
                  minNumber,
                )) &&
            (identical(other.maxNumber, maxNumber) ||
                const DeepCollectionEquality().equals(
                  other.maxNumber,
                  maxNumber,
                )) &&
            (identical(other.minDecimal, minDecimal) ||
                const DeepCollectionEquality().equals(
                  other.minDecimal,
                  minDecimal,
                )) &&
            (identical(other.maxDecimal, maxDecimal) ||
                const DeepCollectionEquality().equals(
                  other.maxDecimal,
                  maxDecimal,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(attributeType) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(editable) ^
      const DeepCollectionEquality().hash(validator) ^
      const DeepCollectionEquality().hash(allowedValues) ^
      const DeepCollectionEquality().hash(allowedNumbers) ^
      const DeepCollectionEquality().hash(allowedDecimals) ^
      const DeepCollectionEquality().hash(minNumber) ^
      const DeepCollectionEquality().hash(maxNumber) ^
      const DeepCollectionEquality().hash(minDecimal) ^
      const DeepCollectionEquality().hash(maxDecimal) ^
      runtimeType.hashCode;
}

extension $AttributeExtension on Attribute {
  Attribute copyWith({
    String? name,
    String? description,
    String? label,
    enums.AttributeAttributeType? attributeType,
    String? $value,
    bool? editable,
    enums.AttributeValidator? validator,
    List<String>? allowedValues,
    List<int>? allowedNumbers,
    List<double>? allowedDecimals,
    int? minNumber,
    int? maxNumber,
    double? minDecimal,
    double? maxDecimal,
  }) {
    return Attribute(
      name: name ?? this.name,
      description: description ?? this.description,
      label: label ?? this.label,
      attributeType: attributeType ?? this.attributeType,
      $value: $value ?? this.$value,
      editable: editable ?? this.editable,
      validator: validator ?? this.validator,
      allowedValues: allowedValues ?? this.allowedValues,
      allowedNumbers: allowedNumbers ?? this.allowedNumbers,
      allowedDecimals: allowedDecimals ?? this.allowedDecimals,
      minNumber: minNumber ?? this.minNumber,
      maxNumber: maxNumber ?? this.maxNumber,
      minDecimal: minDecimal ?? this.minDecimal,
      maxDecimal: maxDecimal ?? this.maxDecimal,
    );
  }

  Attribute copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? label,
    Wrapped<enums.AttributeAttributeType>? attributeType,
    Wrapped<String>? $value,
    Wrapped<bool?>? editable,
    Wrapped<enums.AttributeValidator?>? validator,
    Wrapped<List<String>?>? allowedValues,
    Wrapped<List<int>?>? allowedNumbers,
    Wrapped<List<double>?>? allowedDecimals,
    Wrapped<int?>? minNumber,
    Wrapped<int?>? maxNumber,
    Wrapped<double?>? minDecimal,
    Wrapped<double?>? maxDecimal,
  }) {
    return Attribute(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      label: (label != null ? label.value : this.label),
      attributeType: (attributeType != null
          ? attributeType.value
          : this.attributeType),
      $value: ($value != null ? $value.value : this.$value),
      editable: (editable != null ? editable.value : this.editable),
      validator: (validator != null ? validator.value : this.validator),
      allowedValues: (allowedValues != null
          ? allowedValues.value
          : this.allowedValues),
      allowedNumbers: (allowedNumbers != null
          ? allowedNumbers.value
          : this.allowedNumbers),
      allowedDecimals: (allowedDecimals != null
          ? allowedDecimals.value
          : this.allowedDecimals),
      minNumber: (minNumber != null ? minNumber.value : this.minNumber),
      maxNumber: (maxNumber != null ? maxNumber.value : this.maxNumber),
      minDecimal: (minDecimal != null ? minDecimal.value : this.minDecimal),
      maxDecimal: (maxDecimal != null ? maxDecimal.value : this.maxDecimal),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableInfo {
  const ScrappingTableInfo({
    required this.name,
    this.description,
    this.tags,
    required this.attributes,
  });

  factory ScrappingTableInfo.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableInfoFromJson(json);

  static const toJsonFactory = _$ScrappingTableInfoToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'attributes',
    includeIfNull: false,
    defaultValue: <Attribute>[],
  )
  final List<Attribute> attributes;
  static const fromJsonFactory = _$ScrappingTableInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $ScrappingTableInfoExtension on ScrappingTableInfo {
  ScrappingTableInfo copyWith({
    String? name,
    String? description,
    List<String>? tags,
    List<Attribute>? attributes,
  }) {
    return ScrappingTableInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      attributes: attributes ?? this.attributes,
    );
  }

  ScrappingTableInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<List<Attribute>>? attributes,
  }) {
    return ScrappingTableInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTable {
  const ScrappingTable({
    required this.name,
    this.description,
    this.tags,
    required this.attributes,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory ScrappingTable.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableFromJson(json);

  static const toJsonFactory = _$ScrappingTableToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'attributes',
    includeIfNull: false,
    defaultValue: <Attribute>[],
  )
  final List<Attribute> attributes;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$ScrappingTableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTable &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $ScrappingTableExtension on ScrappingTable {
  ScrappingTable copyWith({
    String? name,
    String? description,
    List<String>? tags,
    List<Attribute>? attributes,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return ScrappingTable(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      attributes: attributes ?? this.attributes,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  ScrappingTable copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<List<Attribute>>? attributes,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return ScrappingTable(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      attributes: (attributes != null ? attributes.value : this.attributes),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableEntity {
  const ScrappingTableEntity({this.entity});

  factory ScrappingTableEntity.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableEntityFromJson(json);

  static const toJsonFactory = _$ScrappingTableEntityToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ScrappingTable? entity;
  static const fromJsonFactory = _$ScrappingTableEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ScrappingTableEntityExtension on ScrappingTableEntity {
  ScrappingTableEntity copyWith({ScrappingTable? entity}) {
    return ScrappingTableEntity(entity: entity ?? this.entity);
  }

  ScrappingTableEntity copyWithWrapped({Wrapped<ScrappingTable?>? entity}) {
    return ScrappingTableEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableEntityRes {
  const ScrappingTableEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ScrappingTableEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableEntityResFromJson(json);

  static const toJsonFactory = _$ScrappingTableEntityResToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final ScrappingTable? entity;
  static const fromJsonFactory = _$ScrappingTableEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ScrappingTableEntityResExtension on ScrappingTableEntityRes {
  ScrappingTableEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    ScrappingTable? entity,
  }) {
    return ScrappingTableEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  ScrappingTableEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<ScrappingTable?>? entity,
  }) {
    return ScrappingTableEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableArray {
  const ScrappingTableArray({this.values});

  factory ScrappingTableArray.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableArrayFromJson(json);

  static const toJsonFactory = _$ScrappingTableArrayToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <ScrappingTable>[],
  )
  final List<ScrappingTable>? values;
  static const fromJsonFactory = _$ScrappingTableArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ScrappingTableArrayExtension on ScrappingTableArray {
  ScrappingTableArray copyWith({List<ScrappingTable>? values}) {
    return ScrappingTableArray(values: values ?? this.values);
  }

  ScrappingTableArray copyWithWrapped({
    Wrapped<List<ScrappingTable>?>? values,
  }) {
    return ScrappingTableArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableArrayRes {
  const ScrappingTableArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ScrappingTableArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableArrayResFromJson(json);

  static const toJsonFactory = _$ScrappingTableArrayResToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <ScrappingTable>[],
  )
  final List<ScrappingTable>? values;
  static const fromJsonFactory = _$ScrappingTableArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ScrappingTableArrayResExtension on ScrappingTableArrayRes {
  ScrappingTableArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<ScrappingTable>? values,
  }) {
    return ScrappingTableArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  ScrappingTableArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<ScrappingTable>?>? values,
  }) {
    return ScrappingTableArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Tags {
  const Tags({this.values});

  factory Tags.fromJson(Map<String, dynamic> json) => _$TagsFromJson(json);

  static const toJsonFactory = _$TagsToJson;
  Map<String, dynamic> toJson() => _$TagsToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  static const fromJsonFactory = _$TagsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Tags &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TagsExtension on Tags {
  Tags copyWith({List<String>? values}) {
    return Tags(values: values ?? this.values);
  }

  Tags copyWithWrapped({Wrapped<List<String>?>? values}) {
    return Tags(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorStats {
  const FloorStats({this.assets, this.devices});

  factory FloorStats.fromJson(Map<String, dynamic> json) =>
      _$FloorStatsFromJson(json);

  static const toJsonFactory = _$FloorStatsToJson;
  Map<String, dynamic> toJson() => _$FloorStatsToJson(this);

  @JsonKey(name: 'assets', includeIfNull: false)
  final int? assets;
  @JsonKey(name: 'devices', includeIfNull: false)
  final int? devices;
  static const fromJsonFactory = _$FloorStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorStats &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality().equals(other.devices, devices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(devices) ^
      runtimeType.hashCode;
}

extension $FloorStatsExtension on FloorStats {
  FloorStats copyWith({int? assets, int? devices}) {
    return FloorStats(
      assets: assets ?? this.assets,
      devices: devices ?? this.devices,
    );
  }

  FloorStats copyWithWrapped({Wrapped<int?>? assets, Wrapped<int?>? devices}) {
    return FloorStats(
      assets: (assets != null ? assets.value : this.assets),
      devices: (devices != null ? devices.value : this.devices),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FloorStatsEntity {
  const FloorStatsEntity({this.entity});

  factory FloorStatsEntity.fromJson(Map<String, dynamic> json) =>
      _$FloorStatsEntityFromJson(json);

  static const toJsonFactory = _$FloorStatsEntityToJson;
  Map<String, dynamic> toJson() => _$FloorStatsEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final FloorStats? entity;
  static const fromJsonFactory = _$FloorStatsEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorStatsEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FloorStatsEntityExtension on FloorStatsEntity {
  FloorStatsEntity copyWith({FloorStats? entity}) {
    return FloorStatsEntity(entity: entity ?? this.entity);
  }

  FloorStatsEntity copyWithWrapped({Wrapped<FloorStats?>? entity}) {
    return FloorStatsEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FloorStatsEntityRes {
  const FloorStatsEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory FloorStatsEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FloorStatsEntityResFromJson(json);

  static const toJsonFactory = _$FloorStatsEntityResToJson;
  Map<String, dynamic> toJson() => _$FloorStatsEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final FloorStats? entity;
  static const fromJsonFactory = _$FloorStatsEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorStatsEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $FloorStatsEntityResExtension on FloorStatsEntityRes {
  FloorStatsEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    FloorStats? entity,
  }) {
    return FloorStatsEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  FloorStatsEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<FloorStats?>? entity,
  }) {
    return FloorStatsEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityStats {
  const FacilityStats({this.floors, this.assets, this.devices});

  factory FacilityStats.fromJson(Map<String, dynamic> json) =>
      _$FacilityStatsFromJson(json);

  static const toJsonFactory = _$FacilityStatsToJson;
  Map<String, dynamic> toJson() => _$FacilityStatsToJson(this);

  @JsonKey(name: 'floors', includeIfNull: false)
  final int? floors;
  @JsonKey(name: 'assets', includeIfNull: false)
  final int? assets;
  @JsonKey(name: 'devices', includeIfNull: false)
  final int? devices;
  static const fromJsonFactory = _$FacilityStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityStats &&
            (identical(other.floors, floors) ||
                const DeepCollectionEquality().equals(other.floors, floors)) &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality().equals(other.devices, devices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(floors) ^
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(devices) ^
      runtimeType.hashCode;
}

extension $FacilityStatsExtension on FacilityStats {
  FacilityStats copyWith({int? floors, int? assets, int? devices}) {
    return FacilityStats(
      floors: floors ?? this.floors,
      assets: assets ?? this.assets,
      devices: devices ?? this.devices,
    );
  }

  FacilityStats copyWithWrapped({
    Wrapped<int?>? floors,
    Wrapped<int?>? assets,
    Wrapped<int?>? devices,
  }) {
    return FacilityStats(
      floors: (floors != null ? floors.value : this.floors),
      assets: (assets != null ? assets.value : this.assets),
      devices: (devices != null ? devices.value : this.devices),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityStatsEntity {
  const FacilityStatsEntity({this.entity});

  factory FacilityStatsEntity.fromJson(Map<String, dynamic> json) =>
      _$FacilityStatsEntityFromJson(json);

  static const toJsonFactory = _$FacilityStatsEntityToJson;
  Map<String, dynamic> toJson() => _$FacilityStatsEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final FacilityStats? entity;
  static const fromJsonFactory = _$FacilityStatsEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityStatsEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FacilityStatsEntityExtension on FacilityStatsEntity {
  FacilityStatsEntity copyWith({FacilityStats? entity}) {
    return FacilityStatsEntity(entity: entity ?? this.entity);
  }

  FacilityStatsEntity copyWithWrapped({Wrapped<FacilityStats?>? entity}) {
    return FacilityStatsEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityStatsEntityRes {
  const FacilityStatsEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory FacilityStatsEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FacilityStatsEntityResFromJson(json);

  static const toJsonFactory = _$FacilityStatsEntityResToJson;
  Map<String, dynamic> toJson() => _$FacilityStatsEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final FacilityStats? entity;
  static const fromJsonFactory = _$FacilityStatsEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityStatsEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $FacilityStatsEntityResExtension on FacilityStatsEntityRes {
  FacilityStatsEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    FacilityStats? entity,
  }) {
    return FacilityStatsEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  FacilityStatsEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<FacilityStats?>? entity,
  }) {
    return FacilityStatsEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseStats {
  const PremiseStats({this.facilities, this.floors, this.assets, this.devices});

  factory PremiseStats.fromJson(Map<String, dynamic> json) =>
      _$PremiseStatsFromJson(json);

  static const toJsonFactory = _$PremiseStatsToJson;
  Map<String, dynamic> toJson() => _$PremiseStatsToJson(this);

  @JsonKey(name: 'facilities', includeIfNull: false)
  final int? facilities;
  @JsonKey(name: 'floors', includeIfNull: false)
  final int? floors;
  @JsonKey(name: 'assets', includeIfNull: false)
  final int? assets;
  @JsonKey(name: 'devices', includeIfNull: false)
  final int? devices;
  static const fromJsonFactory = _$PremiseStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseStats &&
            (identical(other.facilities, facilities) ||
                const DeepCollectionEquality().equals(
                  other.facilities,
                  facilities,
                )) &&
            (identical(other.floors, floors) ||
                const DeepCollectionEquality().equals(other.floors, floors)) &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality().equals(other.devices, devices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(facilities) ^
      const DeepCollectionEquality().hash(floors) ^
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(devices) ^
      runtimeType.hashCode;
}

extension $PremiseStatsExtension on PremiseStats {
  PremiseStats copyWith({
    int? facilities,
    int? floors,
    int? assets,
    int? devices,
  }) {
    return PremiseStats(
      facilities: facilities ?? this.facilities,
      floors: floors ?? this.floors,
      assets: assets ?? this.assets,
      devices: devices ?? this.devices,
    );
  }

  PremiseStats copyWithWrapped({
    Wrapped<int?>? facilities,
    Wrapped<int?>? floors,
    Wrapped<int?>? assets,
    Wrapped<int?>? devices,
  }) {
    return PremiseStats(
      facilities: (facilities != null ? facilities.value : this.facilities),
      floors: (floors != null ? floors.value : this.floors),
      assets: (assets != null ? assets.value : this.assets),
      devices: (devices != null ? devices.value : this.devices),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseStatsEntity {
  const PremiseStatsEntity({this.entity});

  factory PremiseStatsEntity.fromJson(Map<String, dynamic> json) =>
      _$PremiseStatsEntityFromJson(json);

  static const toJsonFactory = _$PremiseStatsEntityToJson;
  Map<String, dynamic> toJson() => _$PremiseStatsEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final PremiseStats? entity;
  static const fromJsonFactory = _$PremiseStatsEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseStatsEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $PremiseStatsEntityExtension on PremiseStatsEntity {
  PremiseStatsEntity copyWith({PremiseStats? entity}) {
    return PremiseStatsEntity(entity: entity ?? this.entity);
  }

  PremiseStatsEntity copyWithWrapped({Wrapped<PremiseStats?>? entity}) {
    return PremiseStatsEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseStatsEntityRes {
  const PremiseStatsEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory PremiseStatsEntityRes.fromJson(Map<String, dynamic> json) =>
      _$PremiseStatsEntityResFromJson(json);

  static const toJsonFactory = _$PremiseStatsEntityResToJson;
  Map<String, dynamic> toJson() => _$PremiseStatsEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final PremiseStats? entity;
  static const fromJsonFactory = _$PremiseStatsEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseStatsEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $PremiseStatsEntityResExtension on PremiseStatsEntityRes {
  PremiseStatsEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    PremiseStats? entity,
  }) {
    return PremiseStatsEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  PremiseStatsEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<PremiseStats?>? entity,
  }) {
    return PremiseStatsEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TagsRes {
  const TagsRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.values,
  });

  factory TagsRes.fromJson(Map<String, dynamic> json) =>
      _$TagsResFromJson(json);

  static const toJsonFactory = _$TagsResToJson;
  Map<String, dynamic> toJson() => _$TagsResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  static const fromJsonFactory = _$TagsResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TagsRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TagsResExtension on TagsRes {
  TagsRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    List<String>? values,
  }) {
    return TagsRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      values: values ?? this.values,
    );
  }

  TagsRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<List<String>?>? values,
  }) {
    return TagsRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomWidget {
  const CustomWidget({required this.id, required this.attributes});

  factory CustomWidget.fromJson(Map<String, dynamic> json) =>
      _$CustomWidgetFromJson(json);

  static const toJsonFactory = _$CustomWidgetToJson;
  Map<String, dynamic> toJson() => _$CustomWidgetToJson(this);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  static const fromJsonFactory = _$CustomWidgetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomWidget &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $CustomWidgetExtension on CustomWidget {
  CustomWidget copyWith({String? id, Object? attributes}) {
    return CustomWidget(
      id: id ?? this.id,
      attributes: attributes ?? this.attributes,
    );
  }

  CustomWidget copyWithWrapped({
    Wrapped<String>? id,
    Wrapped<Object>? attributes,
  }) {
    return CustomWidget(
      id: (id != null ? id.value : this.id),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SensorWidget {
  const SensorWidget({required this.widgetId, required this.attributes});

  factory SensorWidget.fromJson(Map<String, dynamic> json) =>
      _$SensorWidgetFromJson(json);

  static const toJsonFactory = _$SensorWidgetToJson;
  Map<String, dynamic> toJson() => _$SensorWidgetToJson(this);

  @JsonKey(name: 'widgetId', includeIfNull: false, defaultValue: '')
  final String widgetId;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  static const fromJsonFactory = _$SensorWidgetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SensorWidget &&
            (identical(other.widgetId, widgetId) ||
                const DeepCollectionEquality().equals(
                  other.widgetId,
                  widgetId,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(widgetId) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $SensorWidgetExtension on SensorWidget {
  SensorWidget copyWith({String? widgetId, Object? attributes}) {
    return SensorWidget(
      widgetId: widgetId ?? this.widgetId,
      attributes: attributes ?? this.attributes,
    );
  }

  SensorWidget copyWithWrapped({
    Wrapped<String>? widgetId,
    Wrapped<Object>? attributes,
  }) {
    return SensorWidget(
      widgetId: (widgetId != null ? widgetId.value : this.widgetId),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupInfo {
  const AssetGroupInfo({
    required this.name,
    this.description,
    this.tags,
    required this.target,
    required this.assetIds,
    this.icon,
    this.clientId,
  });

  factory AssetGroupInfo.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupInfoFromJson(json);

  static const toJsonFactory = _$AssetGroupInfoToJson;
  Map<String, dynamic> toJson() => _$AssetGroupInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: assetGroupInfoTargetToJson,
    fromJson: assetGroupInfoTargetFromJson,
  )
  final enums.AssetGroupInfoTarget target;
  @JsonKey(name: 'assetIds', includeIfNull: false, defaultValue: <String>[])
  final List<String> assetIds;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$AssetGroupInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.assetIds, assetIds) ||
                const DeepCollectionEquality().equals(
                  other.assetIds,
                  assetIds,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(assetIds) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $AssetGroupInfoExtension on AssetGroupInfo {
  AssetGroupInfo copyWith({
    String? name,
    String? description,
    List<String>? tags,
    enums.AssetGroupInfoTarget? target,
    List<String>? assetIds,
    String? icon,
    String? clientId,
  }) {
    return AssetGroupInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      target: target ?? this.target,
      assetIds: assetIds ?? this.assetIds,
      icon: icon ?? this.icon,
      clientId: clientId ?? this.clientId,
    );
  }

  AssetGroupInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<enums.AssetGroupInfoTarget>? target,
    Wrapped<List<String>>? assetIds,
    Wrapped<String?>? icon,
    Wrapped<String?>? clientId,
  }) {
    return AssetGroupInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      target: (target != null ? target.value : this.target),
      assetIds: (assetIds != null ? assetIds.value : this.assetIds),
      icon: (icon != null ? icon.value : this.icon),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroup {
  const AssetGroup({
    required this.name,
    this.description,
    this.tags,
    required this.target,
    required this.assetIds,
    this.icon,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory AssetGroup.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupFromJson(json);

  static const toJsonFactory = _$AssetGroupToJson;
  Map<String, dynamic> toJson() => _$AssetGroupToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: assetGroupTargetToJson,
    fromJson: assetGroupTargetFromJson,
  )
  final enums.AssetGroupTarget target;
  @JsonKey(name: 'assetIds', includeIfNull: false, defaultValue: <String>[])
  final List<String> assetIds;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$AssetGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroup &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.assetIds, assetIds) ||
                const DeepCollectionEquality().equals(
                  other.assetIds,
                  assetIds,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(assetIds) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $AssetGroupExtension on AssetGroup {
  AssetGroup copyWith({
    String? name,
    String? description,
    List<String>? tags,
    enums.AssetGroupTarget? target,
    List<String>? assetIds,
    String? icon,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return AssetGroup(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      target: target ?? this.target,
      assetIds: assetIds ?? this.assetIds,
      icon: icon ?? this.icon,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  AssetGroup copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<enums.AssetGroupTarget>? target,
    Wrapped<List<String>>? assetIds,
    Wrapped<String?>? icon,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return AssetGroup(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      target: (target != null ? target.value : this.target),
      assetIds: (assetIds != null ? assetIds.value : this.assetIds),
      icon: (icon != null ? icon.value : this.icon),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupEntity {
  const AssetGroupEntity({this.entity});

  factory AssetGroupEntity.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupEntityFromJson(json);

  static const toJsonFactory = _$AssetGroupEntityToJson;
  Map<String, dynamic> toJson() => _$AssetGroupEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final AssetGroup? entity;
  static const fromJsonFactory = _$AssetGroupEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AssetGroupEntityExtension on AssetGroupEntity {
  AssetGroupEntity copyWith({AssetGroup? entity}) {
    return AssetGroupEntity(entity: entity ?? this.entity);
  }

  AssetGroupEntity copyWithWrapped({Wrapped<AssetGroup?>? entity}) {
    return AssetGroupEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupEntityRes {
  const AssetGroupEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AssetGroupEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupEntityResFromJson(json);

  static const toJsonFactory = _$AssetGroupEntityResToJson;
  Map<String, dynamic> toJson() => _$AssetGroupEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final AssetGroup? entity;
  static const fromJsonFactory = _$AssetGroupEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AssetGroupEntityResExtension on AssetGroupEntityRes {
  AssetGroupEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    AssetGroup? entity,
  }) {
    return AssetGroupEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  AssetGroupEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<AssetGroup?>? entity,
  }) {
    return AssetGroupEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupArray {
  const AssetGroupArray({this.values});

  factory AssetGroupArray.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupArrayFromJson(json);

  static const toJsonFactory = _$AssetGroupArrayToJson;
  Map<String, dynamic> toJson() => _$AssetGroupArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <AssetGroup>[])
  final List<AssetGroup>? values;
  static const fromJsonFactory = _$AssetGroupArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AssetGroupArrayExtension on AssetGroupArray {
  AssetGroupArray copyWith({List<AssetGroup>? values}) {
    return AssetGroupArray(values: values ?? this.values);
  }

  AssetGroupArray copyWithWrapped({Wrapped<List<AssetGroup>?>? values}) {
    return AssetGroupArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupArrayRes {
  const AssetGroupArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AssetGroupArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupArrayResFromJson(json);

  static const toJsonFactory = _$AssetGroupArrayResToJson;
  Map<String, dynamic> toJson() => _$AssetGroupArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <AssetGroup>[])
  final List<AssetGroup>? values;
  static const fromJsonFactory = _$AssetGroupArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AssetGroupArrayResExtension on AssetGroupArrayRes {
  AssetGroupArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<AssetGroup>? values,
  }) {
    return AssetGroupArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  AssetGroupArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<AssetGroup>?>? values,
  }) {
    return AssetGroupArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportInfo {
  const ReportInfo({
    required this.modelId,
    required this.name,
    this.icon,
    this.description,
    this.tags,
    this.includePremise,
    this.includeFacility,
    this.includeFloor,
    this.includeAsset,
    this.includeDevice,
    this.humanDateFormat,
    this.dateFormat,
    this.tz,
    required this.fields,
    required this.target,
    this.clientId,
  });

  factory ReportInfo.fromJson(Map<String, dynamic> json) =>
      _$ReportInfoFromJson(json);

  static const toJsonFactory = _$ReportInfoToJson;
  Map<String, dynamic> toJson() => _$ReportInfoToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'includePremise', includeIfNull: false)
  final bool? includePremise;
  @JsonKey(name: 'includeFacility', includeIfNull: false)
  final bool? includeFacility;
  @JsonKey(name: 'includeFloor', includeIfNull: false)
  final bool? includeFloor;
  @JsonKey(name: 'includeAsset', includeIfNull: false)
  final bool? includeAsset;
  @JsonKey(name: 'includeDevice', includeIfNull: false)
  final bool? includeDevice;
  @JsonKey(name: 'humanDateFormat', includeIfNull: false)
  final bool? humanDateFormat;
  @JsonKey(name: 'dateFormat', includeIfNull: false, defaultValue: '')
  final String? dateFormat;
  @JsonKey(name: 'tz', includeIfNull: false, defaultValue: '')
  final String? tz;
  @JsonKey(name: 'fields', includeIfNull: false, defaultValue: <String>[])
  final List<String> fields;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: reportInfoTargetToJson,
    fromJson: reportInfoTargetFromJson,
  )
  final enums.ReportInfoTarget target;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$ReportInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportInfo &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.includePremise, includePremise) ||
                const DeepCollectionEquality().equals(
                  other.includePremise,
                  includePremise,
                )) &&
            (identical(other.includeFacility, includeFacility) ||
                const DeepCollectionEquality().equals(
                  other.includeFacility,
                  includeFacility,
                )) &&
            (identical(other.includeFloor, includeFloor) ||
                const DeepCollectionEquality().equals(
                  other.includeFloor,
                  includeFloor,
                )) &&
            (identical(other.includeAsset, includeAsset) ||
                const DeepCollectionEquality().equals(
                  other.includeAsset,
                  includeAsset,
                )) &&
            (identical(other.includeDevice, includeDevice) ||
                const DeepCollectionEquality().equals(
                  other.includeDevice,
                  includeDevice,
                )) &&
            (identical(other.humanDateFormat, humanDateFormat) ||
                const DeepCollectionEquality().equals(
                  other.humanDateFormat,
                  humanDateFormat,
                )) &&
            (identical(other.dateFormat, dateFormat) ||
                const DeepCollectionEquality().equals(
                  other.dateFormat,
                  dateFormat,
                )) &&
            (identical(other.tz, tz) ||
                const DeepCollectionEquality().equals(other.tz, tz)) &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(includePremise) ^
      const DeepCollectionEquality().hash(includeFacility) ^
      const DeepCollectionEquality().hash(includeFloor) ^
      const DeepCollectionEquality().hash(includeAsset) ^
      const DeepCollectionEquality().hash(includeDevice) ^
      const DeepCollectionEquality().hash(humanDateFormat) ^
      const DeepCollectionEquality().hash(dateFormat) ^
      const DeepCollectionEquality().hash(tz) ^
      const DeepCollectionEquality().hash(fields) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $ReportInfoExtension on ReportInfo {
  ReportInfo copyWith({
    String? modelId,
    String? name,
    String? icon,
    String? description,
    List<String>? tags,
    bool? includePremise,
    bool? includeFacility,
    bool? includeFloor,
    bool? includeAsset,
    bool? includeDevice,
    bool? humanDateFormat,
    String? dateFormat,
    String? tz,
    List<String>? fields,
    enums.ReportInfoTarget? target,
    String? clientId,
  }) {
    return ReportInfo(
      modelId: modelId ?? this.modelId,
      name: name ?? this.name,
      icon: icon ?? this.icon,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      includePremise: includePremise ?? this.includePremise,
      includeFacility: includeFacility ?? this.includeFacility,
      includeFloor: includeFloor ?? this.includeFloor,
      includeAsset: includeAsset ?? this.includeAsset,
      includeDevice: includeDevice ?? this.includeDevice,
      humanDateFormat: humanDateFormat ?? this.humanDateFormat,
      dateFormat: dateFormat ?? this.dateFormat,
      tz: tz ?? this.tz,
      fields: fields ?? this.fields,
      target: target ?? this.target,
      clientId: clientId ?? this.clientId,
    );
  }

  ReportInfo copyWithWrapped({
    Wrapped<String>? modelId,
    Wrapped<String>? name,
    Wrapped<String?>? icon,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<bool?>? includePremise,
    Wrapped<bool?>? includeFacility,
    Wrapped<bool?>? includeFloor,
    Wrapped<bool?>? includeAsset,
    Wrapped<bool?>? includeDevice,
    Wrapped<bool?>? humanDateFormat,
    Wrapped<String?>? dateFormat,
    Wrapped<String?>? tz,
    Wrapped<List<String>>? fields,
    Wrapped<enums.ReportInfoTarget>? target,
    Wrapped<String?>? clientId,
  }) {
    return ReportInfo(
      modelId: (modelId != null ? modelId.value : this.modelId),
      name: (name != null ? name.value : this.name),
      icon: (icon != null ? icon.value : this.icon),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      includePremise: (includePremise != null
          ? includePremise.value
          : this.includePremise),
      includeFacility: (includeFacility != null
          ? includeFacility.value
          : this.includeFacility),
      includeFloor: (includeFloor != null
          ? includeFloor.value
          : this.includeFloor),
      includeAsset: (includeAsset != null
          ? includeAsset.value
          : this.includeAsset),
      includeDevice: (includeDevice != null
          ? includeDevice.value
          : this.includeDevice),
      humanDateFormat: (humanDateFormat != null
          ? humanDateFormat.value
          : this.humanDateFormat),
      dateFormat: (dateFormat != null ? dateFormat.value : this.dateFormat),
      tz: (tz != null ? tz.value : this.tz),
      fields: (fields != null ? fields.value : this.fields),
      target: (target != null ? target.value : this.target),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Report {
  const Report({
    required this.modelId,
    required this.name,
    this.icon,
    this.description,
    this.tags,
    this.includePremise,
    this.includeFacility,
    this.includeFloor,
    this.includeAsset,
    this.includeDevice,
    this.humanDateFormat,
    this.dateFormat,
    this.tz,
    required this.fields,
    required this.target,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory Report.fromJson(Map<String, dynamic> json) => _$ReportFromJson(json);

  static const toJsonFactory = _$ReportToJson;
  Map<String, dynamic> toJson() => _$ReportToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'includePremise', includeIfNull: false)
  final bool? includePremise;
  @JsonKey(name: 'includeFacility', includeIfNull: false)
  final bool? includeFacility;
  @JsonKey(name: 'includeFloor', includeIfNull: false)
  final bool? includeFloor;
  @JsonKey(name: 'includeAsset', includeIfNull: false)
  final bool? includeAsset;
  @JsonKey(name: 'includeDevice', includeIfNull: false)
  final bool? includeDevice;
  @JsonKey(name: 'humanDateFormat', includeIfNull: false)
  final bool? humanDateFormat;
  @JsonKey(name: 'dateFormat', includeIfNull: false, defaultValue: '')
  final String? dateFormat;
  @JsonKey(name: 'tz', includeIfNull: false, defaultValue: '')
  final String? tz;
  @JsonKey(name: 'fields', includeIfNull: false, defaultValue: <String>[])
  final List<String> fields;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: reportTargetToJson,
    fromJson: reportTargetFromJson,
  )
  final enums.ReportTarget target;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$ReportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Report &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(
                  other.modelId,
                  modelId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.includePremise, includePremise) ||
                const DeepCollectionEquality().equals(
                  other.includePremise,
                  includePremise,
                )) &&
            (identical(other.includeFacility, includeFacility) ||
                const DeepCollectionEquality().equals(
                  other.includeFacility,
                  includeFacility,
                )) &&
            (identical(other.includeFloor, includeFloor) ||
                const DeepCollectionEquality().equals(
                  other.includeFloor,
                  includeFloor,
                )) &&
            (identical(other.includeAsset, includeAsset) ||
                const DeepCollectionEquality().equals(
                  other.includeAsset,
                  includeAsset,
                )) &&
            (identical(other.includeDevice, includeDevice) ||
                const DeepCollectionEquality().equals(
                  other.includeDevice,
                  includeDevice,
                )) &&
            (identical(other.humanDateFormat, humanDateFormat) ||
                const DeepCollectionEquality().equals(
                  other.humanDateFormat,
                  humanDateFormat,
                )) &&
            (identical(other.dateFormat, dateFormat) ||
                const DeepCollectionEquality().equals(
                  other.dateFormat,
                  dateFormat,
                )) &&
            (identical(other.tz, tz) ||
                const DeepCollectionEquality().equals(other.tz, tz)) &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(includePremise) ^
      const DeepCollectionEquality().hash(includeFacility) ^
      const DeepCollectionEquality().hash(includeFloor) ^
      const DeepCollectionEquality().hash(includeAsset) ^
      const DeepCollectionEquality().hash(includeDevice) ^
      const DeepCollectionEquality().hash(humanDateFormat) ^
      const DeepCollectionEquality().hash(dateFormat) ^
      const DeepCollectionEquality().hash(tz) ^
      const DeepCollectionEquality().hash(fields) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $ReportExtension on Report {
  Report copyWith({
    String? modelId,
    String? name,
    String? icon,
    String? description,
    List<String>? tags,
    bool? includePremise,
    bool? includeFacility,
    bool? includeFloor,
    bool? includeAsset,
    bool? includeDevice,
    bool? humanDateFormat,
    String? dateFormat,
    String? tz,
    List<String>? fields,
    enums.ReportTarget? target,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return Report(
      modelId: modelId ?? this.modelId,
      name: name ?? this.name,
      icon: icon ?? this.icon,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      includePremise: includePremise ?? this.includePremise,
      includeFacility: includeFacility ?? this.includeFacility,
      includeFloor: includeFloor ?? this.includeFloor,
      includeAsset: includeAsset ?? this.includeAsset,
      includeDevice: includeDevice ?? this.includeDevice,
      humanDateFormat: humanDateFormat ?? this.humanDateFormat,
      dateFormat: dateFormat ?? this.dateFormat,
      tz: tz ?? this.tz,
      fields: fields ?? this.fields,
      target: target ?? this.target,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  Report copyWithWrapped({
    Wrapped<String>? modelId,
    Wrapped<String>? name,
    Wrapped<String?>? icon,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<bool?>? includePremise,
    Wrapped<bool?>? includeFacility,
    Wrapped<bool?>? includeFloor,
    Wrapped<bool?>? includeAsset,
    Wrapped<bool?>? includeDevice,
    Wrapped<bool?>? humanDateFormat,
    Wrapped<String?>? dateFormat,
    Wrapped<String?>? tz,
    Wrapped<List<String>>? fields,
    Wrapped<enums.ReportTarget>? target,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return Report(
      modelId: (modelId != null ? modelId.value : this.modelId),
      name: (name != null ? name.value : this.name),
      icon: (icon != null ? icon.value : this.icon),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      includePremise: (includePremise != null
          ? includePremise.value
          : this.includePremise),
      includeFacility: (includeFacility != null
          ? includeFacility.value
          : this.includeFacility),
      includeFloor: (includeFloor != null
          ? includeFloor.value
          : this.includeFloor),
      includeAsset: (includeAsset != null
          ? includeAsset.value
          : this.includeAsset),
      includeDevice: (includeDevice != null
          ? includeDevice.value
          : this.includeDevice),
      humanDateFormat: (humanDateFormat != null
          ? humanDateFormat.value
          : this.humanDateFormat),
      dateFormat: (dateFormat != null ? dateFormat.value : this.dateFormat),
      tz: (tz != null ? tz.value : this.tz),
      fields: (fields != null ? fields.value : this.fields),
      target: (target != null ? target.value : this.target),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportEntity {
  const ReportEntity({this.entity});

  factory ReportEntity.fromJson(Map<String, dynamic> json) =>
      _$ReportEntityFromJson(json);

  static const toJsonFactory = _$ReportEntityToJson;
  Map<String, dynamic> toJson() => _$ReportEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Report? entity;
  static const fromJsonFactory = _$ReportEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ReportEntityExtension on ReportEntity {
  ReportEntity copyWith({Report? entity}) {
    return ReportEntity(entity: entity ?? this.entity);
  }

  ReportEntity copyWithWrapped({Wrapped<Report?>? entity}) {
    return ReportEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportEntityRes {
  const ReportEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ReportEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ReportEntityResFromJson(json);

  static const toJsonFactory = _$ReportEntityResToJson;
  Map<String, dynamic> toJson() => _$ReportEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Report? entity;
  static const fromJsonFactory = _$ReportEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ReportEntityResExtension on ReportEntityRes {
  ReportEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Report? entity,
  }) {
    return ReportEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  ReportEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Report?>? entity,
  }) {
    return ReportEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportArray {
  const ReportArray({this.values});

  factory ReportArray.fromJson(Map<String, dynamic> json) =>
      _$ReportArrayFromJson(json);

  static const toJsonFactory = _$ReportArrayToJson;
  Map<String, dynamic> toJson() => _$ReportArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Report>[])
  final List<Report>? values;
  static const fromJsonFactory = _$ReportArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ReportArrayExtension on ReportArray {
  ReportArray copyWith({List<Report>? values}) {
    return ReportArray(values: values ?? this.values);
  }

  ReportArray copyWithWrapped({Wrapped<List<Report>?>? values}) {
    return ReportArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportArrayRes {
  const ReportArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ReportArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ReportArrayResFromJson(json);

  static const toJsonFactory = _$ReportArrayResToJson;
  Map<String, dynamic> toJson() => _$ReportArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Report>[])
  final List<Report>? values;
  static const fromJsonFactory = _$ReportArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ReportArrayResExtension on ReportArrayRes {
  ReportArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Report>? values,
  }) {
    return ReportArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  ReportArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Report>?>? values,
  }) {
    return ReportArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetScrappingTable {
  const AssetScrappingTable({
    required this.lookupName,
    required this.scrappingTableId,
    required this.scrappingTableName,
    required this.attributes,
  });

  factory AssetScrappingTable.fromJson(Map<String, dynamic> json) =>
      _$AssetScrappingTableFromJson(json);

  static const toJsonFactory = _$AssetScrappingTableToJson;
  Map<String, dynamic> toJson() => _$AssetScrappingTableToJson(this);

  @JsonKey(name: 'lookupName', includeIfNull: false, defaultValue: '')
  final String lookupName;
  @JsonKey(name: 'scrappingTableId', includeIfNull: false, defaultValue: '')
  final String scrappingTableId;
  @JsonKey(name: 'scrappingTableName', includeIfNull: false, defaultValue: '')
  final String scrappingTableName;
  @JsonKey(
    name: 'attributes',
    includeIfNull: false,
    defaultValue: <Attribute>[],
  )
  final List<Attribute> attributes;
  static const fromJsonFactory = _$AssetScrappingTableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetScrappingTable &&
            (identical(other.lookupName, lookupName) ||
                const DeepCollectionEquality().equals(
                  other.lookupName,
                  lookupName,
                )) &&
            (identical(other.scrappingTableId, scrappingTableId) ||
                const DeepCollectionEquality().equals(
                  other.scrappingTableId,
                  scrappingTableId,
                )) &&
            (identical(other.scrappingTableName, scrappingTableName) ||
                const DeepCollectionEquality().equals(
                  other.scrappingTableName,
                  scrappingTableName,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lookupName) ^
      const DeepCollectionEquality().hash(scrappingTableId) ^
      const DeepCollectionEquality().hash(scrappingTableName) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $AssetScrappingTableExtension on AssetScrappingTable {
  AssetScrappingTable copyWith({
    String? lookupName,
    String? scrappingTableId,
    String? scrappingTableName,
    List<Attribute>? attributes,
  }) {
    return AssetScrappingTable(
      lookupName: lookupName ?? this.lookupName,
      scrappingTableId: scrappingTableId ?? this.scrappingTableId,
      scrappingTableName: scrappingTableName ?? this.scrappingTableName,
      attributes: attributes ?? this.attributes,
    );
  }

  AssetScrappingTable copyWithWrapped({
    Wrapped<String>? lookupName,
    Wrapped<String>? scrappingTableId,
    Wrapped<String>? scrappingTableName,
    Wrapped<List<Attribute>>? attributes,
  }) {
    return AssetScrappingTable(
      lookupName: (lookupName != null ? lookupName.value : this.lookupName),
      scrappingTableId: (scrappingTableId != null
          ? scrappingTableId.value
          : this.scrappingTableId),
      scrappingTableName: (scrappingTableName != null
          ? scrappingTableName.value
          : this.scrappingTableName),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetDeviceModel {
  const AssetDeviceModel({required this.deviceModelId, this.scrappingTables});

  factory AssetDeviceModel.fromJson(Map<String, dynamic> json) =>
      _$AssetDeviceModelFromJson(json);

  static const toJsonFactory = _$AssetDeviceModelToJson;
  Map<String, dynamic> toJson() => _$AssetDeviceModelToJson(this);

  @JsonKey(name: 'deviceModelId', includeIfNull: false, defaultValue: '')
  final String deviceModelId;
  @JsonKey(
    name: 'scrappingTables',
    includeIfNull: false,
    defaultValue: <AssetScrappingTable>[],
  )
  final List<AssetScrappingTable>? scrappingTables;
  static const fromJsonFactory = _$AssetDeviceModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetDeviceModel &&
            (identical(other.deviceModelId, deviceModelId) ||
                const DeepCollectionEquality().equals(
                  other.deviceModelId,
                  deviceModelId,
                )) &&
            (identical(other.scrappingTables, scrappingTables) ||
                const DeepCollectionEquality().equals(
                  other.scrappingTables,
                  scrappingTables,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deviceModelId) ^
      const DeepCollectionEquality().hash(scrappingTables) ^
      runtimeType.hashCode;
}

extension $AssetDeviceModelExtension on AssetDeviceModel {
  AssetDeviceModel copyWith({
    String? deviceModelId,
    List<AssetScrappingTable>? scrappingTables,
  }) {
    return AssetDeviceModel(
      deviceModelId: deviceModelId ?? this.deviceModelId,
      scrappingTables: scrappingTables ?? this.scrappingTables,
    );
  }

  AssetDeviceModel copyWithWrapped({
    Wrapped<String>? deviceModelId,
    Wrapped<List<AssetScrappingTable>?>? scrappingTables,
  }) {
    return AssetDeviceModel(
      deviceModelId: (deviceModelId != null
          ? deviceModelId.value
          : this.deviceModelId),
      scrappingTables: (scrappingTables != null
          ? scrappingTables.value
          : this.scrappingTables),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelInfo {
  const AssetModelInfo({
    required this.name,
    this.description,
    this.tags,
    this.metadata,
    this.movable,
    this.allowedDeviceModels,
    this.roles,
    this.clientId,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
  });

  factory AssetModelInfo.fromJson(Map<String, dynamic> json) =>
      _$AssetModelInfoFromJson(json);

  static const toJsonFactory = _$AssetModelInfoToJson;
  Map<String, dynamic> toJson() => _$AssetModelInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(
    name: 'allowedDeviceModels',
    includeIfNull: false,
    defaultValue: <AssetDeviceModel>[],
  )
  final List<AssetDeviceModel>? allowedDeviceModels;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  static const fromJsonFactory = _$AssetModelInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality().equals(
                  other.movable,
                  movable,
                )) &&
            (identical(other.allowedDeviceModels, allowedDeviceModels) ||
                const DeepCollectionEquality().equals(
                  other.allowedDeviceModels,
                  allowedDeviceModels,
                )) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(allowedDeviceModels) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      runtimeType.hashCode;
}

extension $AssetModelInfoExtension on AssetModelInfo {
  AssetModelInfo copyWith({
    String? name,
    String? description,
    List<String>? tags,
    Object? metadata,
    bool? movable,
    List<AssetDeviceModel>? allowedDeviceModels,
    List<String>? roles,
    String? clientId,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
  }) {
    return AssetModelInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      metadata: metadata ?? this.metadata,
      movable: movable ?? this.movable,
      allowedDeviceModels: allowedDeviceModels ?? this.allowedDeviceModels,
      roles: roles ?? this.roles,
      clientId: clientId ?? this.clientId,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
    );
  }

  AssetModelInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<Object?>? metadata,
    Wrapped<bool?>? movable,
    Wrapped<List<AssetDeviceModel>?>? allowedDeviceModels,
    Wrapped<List<String>?>? roles,
    Wrapped<String?>? clientId,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
  }) {
    return AssetModelInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      metadata: (metadata != null ? metadata.value : this.metadata),
      movable: (movable != null ? movable.value : this.movable),
      allowedDeviceModels: (allowedDeviceModels != null
          ? allowedDeviceModels.value
          : this.allowedDeviceModels),
      roles: (roles != null ? roles.value : this.roles),
      clientId: (clientId != null ? clientId.value : this.clientId),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModel {
  const AssetModel({
    required this.name,
    this.description,
    this.tags,
    this.metadata,
    this.movable,
    this.allowedDeviceModels,
    this.roles,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
  });

  factory AssetModel.fromJson(Map<String, dynamic> json) =>
      _$AssetModelFromJson(json);

  static const toJsonFactory = _$AssetModelToJson;
  Map<String, dynamic> toJson() => _$AssetModelToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(
    name: 'allowedDeviceModels',
    includeIfNull: false,
    defaultValue: <AssetDeviceModel>[],
  )
  final List<AssetDeviceModel>? allowedDeviceModels;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  static const fromJsonFactory = _$AssetModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality().equals(
                  other.movable,
                  movable,
                )) &&
            (identical(other.allowedDeviceModels, allowedDeviceModels) ||
                const DeepCollectionEquality().equals(
                  other.allowedDeviceModels,
                  allowedDeviceModels,
                )) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(allowedDeviceModels) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      runtimeType.hashCode;
}

extension $AssetModelExtension on AssetModel {
  AssetModel copyWith({
    String? name,
    String? description,
    List<String>? tags,
    Object? metadata,
    bool? movable,
    List<AssetDeviceModel>? allowedDeviceModels,
    List<String>? roles,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
  }) {
    return AssetModel(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      metadata: metadata ?? this.metadata,
      movable: movable ?? this.movable,
      allowedDeviceModels: allowedDeviceModels ?? this.allowedDeviceModels,
      roles: roles ?? this.roles,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
    );
  }

  AssetModel copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<Object?>? metadata,
    Wrapped<bool?>? movable,
    Wrapped<List<AssetDeviceModel>?>? allowedDeviceModels,
    Wrapped<List<String>?>? roles,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
  }) {
    return AssetModel(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      metadata: (metadata != null ? metadata.value : this.metadata),
      movable: (movable != null ? movable.value : this.movable),
      allowedDeviceModels: (allowedDeviceModels != null
          ? allowedDeviceModels.value
          : this.allowedDeviceModels),
      roles: (roles != null ? roles.value : this.roles),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelEntity {
  const AssetModelEntity({this.entity});

  factory AssetModelEntity.fromJson(Map<String, dynamic> json) =>
      _$AssetModelEntityFromJson(json);

  static const toJsonFactory = _$AssetModelEntityToJson;
  Map<String, dynamic> toJson() => _$AssetModelEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final AssetModel? entity;
  static const fromJsonFactory = _$AssetModelEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AssetModelEntityExtension on AssetModelEntity {
  AssetModelEntity copyWith({AssetModel? entity}) {
    return AssetModelEntity(entity: entity ?? this.entity);
  }

  AssetModelEntity copyWithWrapped({Wrapped<AssetModel?>? entity}) {
    return AssetModelEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelEntityRes {
  const AssetModelEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AssetModelEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AssetModelEntityResFromJson(json);

  static const toJsonFactory = _$AssetModelEntityResToJson;
  Map<String, dynamic> toJson() => _$AssetModelEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final AssetModel? entity;
  static const fromJsonFactory = _$AssetModelEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AssetModelEntityResExtension on AssetModelEntityRes {
  AssetModelEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    AssetModel? entity,
  }) {
    return AssetModelEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  AssetModelEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<AssetModel?>? entity,
  }) {
    return AssetModelEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelArray {
  const AssetModelArray({this.values});

  factory AssetModelArray.fromJson(Map<String, dynamic> json) =>
      _$AssetModelArrayFromJson(json);

  static const toJsonFactory = _$AssetModelArrayToJson;
  Map<String, dynamic> toJson() => _$AssetModelArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <AssetModel>[])
  final List<AssetModel>? values;
  static const fromJsonFactory = _$AssetModelArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AssetModelArrayExtension on AssetModelArray {
  AssetModelArray copyWith({List<AssetModel>? values}) {
    return AssetModelArray(values: values ?? this.values);
  }

  AssetModelArray copyWithWrapped({Wrapped<List<AssetModel>?>? values}) {
    return AssetModelArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelArrayRes {
  const AssetModelArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AssetModelArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AssetModelArrayResFromJson(json);

  static const toJsonFactory = _$AssetModelArrayResToJson;
  Map<String, dynamic> toJson() => _$AssetModelArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <AssetModel>[])
  final List<AssetModel>? values;
  static const fromJsonFactory = _$AssetModelArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AssetModelArrayResExtension on AssetModelArrayRes {
  AssetModelArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<AssetModel>? values,
  }) {
    return AssetModelArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  AssetModelArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<AssetModel>?>? values,
  }) {
    return AssetModelArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class IDList {
  const IDList({required this.total, required this.values});

  factory IDList.fromJson(Map<String, dynamic> json) => _$IDListFromJson(json);

  static const toJsonFactory = _$IDListToJson;
  Map<String, dynamic> toJson() => _$IDListToJson(this);

  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String> values;
  static const fromJsonFactory = _$IDListFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is IDList &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $IDListExtension on IDList {
  IDList copyWith({int? total, List<String>? values}) {
    return IDList(total: total ?? this.total, values: values ?? this.values);
  }

  IDList copyWithWrapped({Wrapped<int>? total, Wrapped<List<String>>? values}) {
    return IDList(
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class IDListEntityRes {
  const IDListEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.total,
    required this.values,
  });

  factory IDListEntityRes.fromJson(Map<String, dynamic> json) =>
      _$IDListEntityResFromJson(json);

  static const toJsonFactory = _$IDListEntityResToJson;
  Map<String, dynamic> toJson() => _$IDListEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String> values;
  static const fromJsonFactory = _$IDListEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is IDListEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $IDListEntityResExtension on IDListEntityRes {
  IDListEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? total,
    List<String>? values,
  }) {
    return IDListEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  IDListEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? total,
    Wrapped<List<String>>? values,
  }) {
    return IDListEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterInfo {
  const FieldFilterInfo({
    required this.name,
    this.description,
    this.icon,
    required this.field,
    required this.fieldType,
    required this.condition,
    this.$value,
    this.leftValue,
    this.rightValue,
    this.values,
    this.tags,
    required this.target,
    this.clientId,
  });

  factory FieldFilterInfo.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterInfoFromJson(json);

  static const toJsonFactory = _$FieldFilterInfoToJson;
  Map<String, dynamic> toJson() => _$FieldFilterInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String field;
  @JsonKey(
    name: 'fieldType',
    includeIfNull: false,
    toJson: fieldFilterInfoFieldTypeToJson,
    fromJson: fieldFilterInfoFieldTypeFromJson,
  )
  final enums.FieldFilterInfoFieldType fieldType;
  @JsonKey(
    name: 'condition',
    includeIfNull: false,
    toJson: fieldFilterInfoConditionToJson,
    fromJson: fieldFilterInfoConditionFromJson,
  )
  final enums.FieldFilterInfoCondition condition;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'leftValue', includeIfNull: false, defaultValue: '')
  final String? leftValue;
  @JsonKey(name: 'rightValue', includeIfNull: false, defaultValue: '')
  final String? rightValue;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: fieldFilterInfoTargetToJson,
    fromJson: fieldFilterInfoTargetFromJson,
  )
  final enums.FieldFilterInfoTarget target;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$FieldFilterInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.fieldType, fieldType) ||
                const DeepCollectionEquality().equals(
                  other.fieldType,
                  fieldType,
                )) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality().equals(
                  other.condition,
                  condition,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.leftValue, leftValue) ||
                const DeepCollectionEquality().equals(
                  other.leftValue,
                  leftValue,
                )) &&
            (identical(other.rightValue, rightValue) ||
                const DeepCollectionEquality().equals(
                  other.rightValue,
                  rightValue,
                )) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(fieldType) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(leftValue) ^
      const DeepCollectionEquality().hash(rightValue) ^
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $FieldFilterInfoExtension on FieldFilterInfo {
  FieldFilterInfo copyWith({
    String? name,
    String? description,
    String? icon,
    String? field,
    enums.FieldFilterInfoFieldType? fieldType,
    enums.FieldFilterInfoCondition? condition,
    String? $value,
    String? leftValue,
    String? rightValue,
    List<String>? values,
    List<String>? tags,
    enums.FieldFilterInfoTarget? target,
    String? clientId,
  }) {
    return FieldFilterInfo(
      name: name ?? this.name,
      description: description ?? this.description,
      icon: icon ?? this.icon,
      field: field ?? this.field,
      fieldType: fieldType ?? this.fieldType,
      condition: condition ?? this.condition,
      $value: $value ?? this.$value,
      leftValue: leftValue ?? this.leftValue,
      rightValue: rightValue ?? this.rightValue,
      values: values ?? this.values,
      tags: tags ?? this.tags,
      target: target ?? this.target,
      clientId: clientId ?? this.clientId,
    );
  }

  FieldFilterInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? icon,
    Wrapped<String>? field,
    Wrapped<enums.FieldFilterInfoFieldType>? fieldType,
    Wrapped<enums.FieldFilterInfoCondition>? condition,
    Wrapped<String?>? $value,
    Wrapped<String?>? leftValue,
    Wrapped<String?>? rightValue,
    Wrapped<List<String>?>? values,
    Wrapped<List<String>?>? tags,
    Wrapped<enums.FieldFilterInfoTarget>? target,
    Wrapped<String?>? clientId,
  }) {
    return FieldFilterInfo(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      icon: (icon != null ? icon.value : this.icon),
      field: (field != null ? field.value : this.field),
      fieldType: (fieldType != null ? fieldType.value : this.fieldType),
      condition: (condition != null ? condition.value : this.condition),
      $value: ($value != null ? $value.value : this.$value),
      leftValue: (leftValue != null ? leftValue.value : this.leftValue),
      rightValue: (rightValue != null ? rightValue.value : this.rightValue),
      values: (values != null ? values.value : this.values),
      tags: (tags != null ? tags.value : this.tags),
      target: (target != null ? target.value : this.target),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilter {
  const FieldFilter({
    required this.name,
    this.description,
    this.icon,
    required this.field,
    required this.fieldType,
    required this.condition,
    this.$value,
    this.leftValue,
    this.rightValue,
    this.values,
    this.tags,
    required this.target,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory FieldFilter.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterFromJson(json);

  static const toJsonFactory = _$FieldFilterToJson;
  Map<String, dynamic> toJson() => _$FieldFilterToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String field;
  @JsonKey(
    name: 'fieldType',
    includeIfNull: false,
    toJson: fieldFilterFieldTypeToJson,
    fromJson: fieldFilterFieldTypeFromJson,
  )
  final enums.FieldFilterFieldType fieldType;
  @JsonKey(
    name: 'condition',
    includeIfNull: false,
    toJson: fieldFilterConditionToJson,
    fromJson: fieldFilterConditionFromJson,
  )
  final enums.FieldFilterCondition condition;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'leftValue', includeIfNull: false, defaultValue: '')
  final String? leftValue;
  @JsonKey(name: 'rightValue', includeIfNull: false, defaultValue: '')
  final String? rightValue;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: fieldFilterTargetToJson,
    fromJson: fieldFilterTargetFromJson,
  )
  final enums.FieldFilterTarget target;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$FieldFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilter &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.fieldType, fieldType) ||
                const DeepCollectionEquality().equals(
                  other.fieldType,
                  fieldType,
                )) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality().equals(
                  other.condition,
                  condition,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.leftValue, leftValue) ||
                const DeepCollectionEquality().equals(
                  other.leftValue,
                  leftValue,
                )) &&
            (identical(other.rightValue, rightValue) ||
                const DeepCollectionEquality().equals(
                  other.rightValue,
                  rightValue,
                )) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(fieldType) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(leftValue) ^
      const DeepCollectionEquality().hash(rightValue) ^
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $FieldFilterExtension on FieldFilter {
  FieldFilter copyWith({
    String? name,
    String? description,
    String? icon,
    String? field,
    enums.FieldFilterFieldType? fieldType,
    enums.FieldFilterCondition? condition,
    String? $value,
    String? leftValue,
    String? rightValue,
    List<String>? values,
    List<String>? tags,
    enums.FieldFilterTarget? target,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return FieldFilter(
      name: name ?? this.name,
      description: description ?? this.description,
      icon: icon ?? this.icon,
      field: field ?? this.field,
      fieldType: fieldType ?? this.fieldType,
      condition: condition ?? this.condition,
      $value: $value ?? this.$value,
      leftValue: leftValue ?? this.leftValue,
      rightValue: rightValue ?? this.rightValue,
      values: values ?? this.values,
      tags: tags ?? this.tags,
      target: target ?? this.target,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  FieldFilter copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? icon,
    Wrapped<String>? field,
    Wrapped<enums.FieldFilterFieldType>? fieldType,
    Wrapped<enums.FieldFilterCondition>? condition,
    Wrapped<String?>? $value,
    Wrapped<String?>? leftValue,
    Wrapped<String?>? rightValue,
    Wrapped<List<String>?>? values,
    Wrapped<List<String>?>? tags,
    Wrapped<enums.FieldFilterTarget>? target,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return FieldFilter(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      icon: (icon != null ? icon.value : this.icon),
      field: (field != null ? field.value : this.field),
      fieldType: (fieldType != null ? fieldType.value : this.fieldType),
      condition: (condition != null ? condition.value : this.condition),
      $value: ($value != null ? $value.value : this.$value),
      leftValue: (leftValue != null ? leftValue.value : this.leftValue),
      rightValue: (rightValue != null ? rightValue.value : this.rightValue),
      values: (values != null ? values.value : this.values),
      tags: (tags != null ? tags.value : this.tags),
      target: (target != null ? target.value : this.target),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterEntity {
  const FieldFilterEntity({this.entity});

  factory FieldFilterEntity.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterEntityFromJson(json);

  static const toJsonFactory = _$FieldFilterEntityToJson;
  Map<String, dynamic> toJson() => _$FieldFilterEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final FieldFilter? entity;
  static const fromJsonFactory = _$FieldFilterEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FieldFilterEntityExtension on FieldFilterEntity {
  FieldFilterEntity copyWith({FieldFilter? entity}) {
    return FieldFilterEntity(entity: entity ?? this.entity);
  }

  FieldFilterEntity copyWithWrapped({Wrapped<FieldFilter?>? entity}) {
    return FieldFilterEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterEntityRes {
  const FieldFilterEntityRes({
    this.entity,
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory FieldFilterEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterEntityResFromJson(json);

  static const toJsonFactory = _$FieldFilterEntityResToJson;
  Map<String, dynamic> toJson() => _$FieldFilterEntityResToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final FieldFilter? entity;
  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$FieldFilterEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterEntityRes &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $FieldFilterEntityResExtension on FieldFilterEntityRes {
  FieldFilterEntityRes copyWith({
    FieldFilter? entity,
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
  }) {
    return FieldFilterEntityRes(
      entity: entity ?? this.entity,
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
    );
  }

  FieldFilterEntityRes copyWithWrapped({
    Wrapped<FieldFilter?>? entity,
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
  }) {
    return FieldFilterEntityRes(
      entity: (entity != null ? entity.value : this.entity),
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterArray {
  const FieldFilterArray({this.values});

  factory FieldFilterArray.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterArrayFromJson(json);

  static const toJsonFactory = _$FieldFilterArrayToJson;
  Map<String, dynamic> toJson() => _$FieldFilterArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <FieldFilter>[])
  final List<FieldFilter>? values;
  static const fromJsonFactory = _$FieldFilterArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $FieldFilterArrayExtension on FieldFilterArray {
  FieldFilterArray copyWith({List<FieldFilter>? values}) {
    return FieldFilterArray(values: values ?? this.values);
  }

  FieldFilterArray copyWithWrapped({Wrapped<List<FieldFilter>?>? values}) {
    return FieldFilterArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterArrayRes {
  const FieldFilterArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory FieldFilterArrayRes.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterArrayResFromJson(json);

  static const toJsonFactory = _$FieldFilterArrayResToJson;
  Map<String, dynamic> toJson() => _$FieldFilterArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <FieldFilter>[])
  final List<FieldFilter>? values;
  static const fromJsonFactory = _$FieldFilterArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $FieldFilterArrayResExtension on FieldFilterArrayRes {
  FieldFilterArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<FieldFilter>? values,
  }) {
    return FieldFilterArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  FieldFilterArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<FieldFilter>?>? values,
  }) {
    return FieldFilterArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterArray {
  const ParameterArray({this.values});

  factory ParameterArray.fromJson(Map<String, dynamic> json) =>
      _$ParameterArrayFromJson(json);

  static const toJsonFactory = _$ParameterArrayToJson;
  Map<String, dynamic> toJson() => _$ParameterArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Parameter>[])
  final List<Parameter>? values;
  static const fromJsonFactory = _$ParameterArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ParameterArrayExtension on ParameterArray {
  ParameterArray copyWith({List<Parameter>? values}) {
    return ParameterArray(values: values ?? this.values);
  }

  ParameterArray copyWithWrapped({Wrapped<List<Parameter>?>? values}) {
    return ParameterArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterArrayRes {
  const ParameterArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ParameterArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ParameterArrayResFromJson(json);

  static const toJsonFactory = _$ParameterArrayResToJson;
  Map<String, dynamic> toJson() => _$ParameterArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Parameter>[])
  final List<Parameter>? values;
  static const fromJsonFactory = _$ParameterArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ParameterArrayResExtension on ParameterArrayRes {
  ParameterArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Parameter>? values,
  }) {
    return ParameterArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  ParameterArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Parameter>?>? values,
  }) {
    return ParameterArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AddressInfo {
  const AddressInfo({
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
  });

  factory AddressInfo.fromJson(Map<String, dynamic> json) =>
      _$AddressInfoFromJson(json);

  static const toJsonFactory = _$AddressInfoToJson;
  Map<String, dynamic> toJson() => _$AddressInfoToJson(this);

  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  static const fromJsonFactory = _$AddressInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddressInfo &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(other.zipcode, zipcode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      runtimeType.hashCode;
}

extension $AddressInfoExtension on AddressInfo {
  AddressInfo copyWith({
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
  }) {
    return AddressInfo(
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
    );
  }

  AddressInfo copyWithWrapped({
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
  }) {
    return AddressInfo(
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ClientInfoBase {
  const ClientInfoBase({
    required this.name,
    this.description,
    this.tags,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.allowRegistration,
    this.location,
  });

  factory ClientInfoBase.fromJson(Map<String, dynamic> json) =>
      _$ClientInfoBaseFromJson(json);

  static const toJsonFactory = _$ClientInfoBaseToJson;
  Map<String, dynamic> toJson() => _$ClientInfoBaseToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'allowRegistration', includeIfNull: false)
  final bool? allowRegistration;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  static const fromJsonFactory = _$ClientInfoBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientInfoBase &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.allowRegistration, allowRegistration) ||
                const DeepCollectionEquality().equals(
                  other.allowRegistration,
                  allowRegistration,
                )) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(allowRegistration) ^
      const DeepCollectionEquality().hash(location) ^
      runtimeType.hashCode;
}

extension $ClientInfoBaseExtension on ClientInfoBase {
  ClientInfoBase copyWith({
    String? name,
    String? description,
    List<String>? tags,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    bool? allowRegistration,
    GeoLocation? location,
  }) {
    return ClientInfoBase(
      name: name ?? this.name,
      description: description ?? this.description,
      tags: tags ?? this.tags,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      allowRegistration: allowRegistration ?? this.allowRegistration,
      location: location ?? this.location,
    );
  }

  ClientInfoBase copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<bool?>? allowRegistration,
    Wrapped<GeoLocation?>? location,
  }) {
    return ClientInfoBase(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      allowRegistration: (allowRegistration != null
          ? allowRegistration.value
          : this.allowRegistration),
      location: (location != null ? location.value : this.location),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ClientInfo {
  const ClientInfo({
    this.description,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
    required this.name,
    this.tags,
    this.email,
    this.phone,
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    this.allowRegistration,
    this.location,
  });

  factory ClientInfo.fromJson(Map<String, dynamic> json) =>
      _$ClientInfoFromJson(json);

  static const toJsonFactory = _$ClientInfoToJson;
  Map<String, dynamic> toJson() => _$ClientInfoToJson(this);

  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'allowRegistration', includeIfNull: false)
  final bool? allowRegistration;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  static const fromJsonFactory = _$ClientInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientInfo &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.allowRegistration, allowRegistration) ||
                const DeepCollectionEquality().equals(
                  other.allowRegistration,
                  allowRegistration,
                )) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(allowRegistration) ^
      const DeepCollectionEquality().hash(location) ^
      runtimeType.hashCode;
}

extension $ClientInfoExtension on ClientInfo {
  ClientInfo copyWith({
    String? description,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
    String? name,
    List<String>? tags,
    String? email,
    String? phone,
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    bool? allowRegistration,
    GeoLocation? location,
  }) {
    return ClientInfo(
      description: description ?? this.description,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
      name: name ?? this.name,
      tags: tags ?? this.tags,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      allowRegistration: allowRegistration ?? this.allowRegistration,
      location: location ?? this.location,
    );
  }

  ClientInfo copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
    Wrapped<String>? name,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<bool?>? allowRegistration,
    Wrapped<GeoLocation?>? location,
  }) {
    return ClientInfo(
      description: (description != null ? description.value : this.description),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
      name: (name != null ? name.value : this.name),
      tags: (tags != null ? tags.value : this.tags),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      allowRegistration: (allowRegistration != null
          ? allowRegistration.value
          : this.allowRegistration),
      location: (location != null ? location.value : this.location),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Client {
  const Client({
    this.address,
    this.country,
    this.countryCode,
    this.stateProvince,
    this.city,
    this.zipcode,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
    this.description,
    this.iconId,
    this.selectedImageId,
    this.selectedBannerId,
    required this.name,
    this.tags,
    this.email,
    this.phone,
    this.allowRegistration,
    this.location,
  });

  factory Client.fromJson(Map<String, dynamic> json) => _$ClientFromJson(json);

  static const toJsonFactory = _$ClientToJson;
  Map<String, dynamic> toJson() => _$ClientToJson(this);

  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: '')
  final String? country;
  @JsonKey(name: 'countryCode', includeIfNull: false, defaultValue: '')
  final String? countryCode;
  @JsonKey(name: 'stateProvince', includeIfNull: false, defaultValue: '')
  final String? stateProvince;
  @JsonKey(name: 'city', includeIfNull: false, defaultValue: '')
  final String? city;
  @JsonKey(name: 'zipcode', includeIfNull: false, defaultValue: '')
  final String? zipcode;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'iconId', includeIfNull: false, defaultValue: '')
  final String? iconId;
  @JsonKey(name: 'selectedImageId', includeIfNull: false, defaultValue: '')
  final String? selectedImageId;
  @JsonKey(name: 'selectedBannerId', includeIfNull: false, defaultValue: '')
  final String? selectedBannerId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'allowRegistration', includeIfNull: false)
  final bool? allowRegistration;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  static const fromJsonFactory = _$ClientFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Client &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality().equals(
                  other.countryCode,
                  countryCode,
                )) &&
            (identical(other.stateProvince, stateProvince) ||
                const DeepCollectionEquality().equals(
                  other.stateProvince,
                  stateProvince,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.zipcode, zipcode) ||
                const DeepCollectionEquality().equals(
                  other.zipcode,
                  zipcode,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.iconId, iconId) ||
                const DeepCollectionEquality().equals(other.iconId, iconId)) &&
            (identical(other.selectedImageId, selectedImageId) ||
                const DeepCollectionEquality().equals(
                  other.selectedImageId,
                  selectedImageId,
                )) &&
            (identical(other.selectedBannerId, selectedBannerId) ||
                const DeepCollectionEquality().equals(
                  other.selectedBannerId,
                  selectedBannerId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.allowRegistration, allowRegistration) ||
                const DeepCollectionEquality().equals(
                  other.allowRegistration,
                  allowRegistration,
                )) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(stateProvince) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(zipcode) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(iconId) ^
      const DeepCollectionEquality().hash(selectedImageId) ^
      const DeepCollectionEquality().hash(selectedBannerId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(allowRegistration) ^
      const DeepCollectionEquality().hash(location) ^
      runtimeType.hashCode;
}

extension $ClientExtension on Client {
  Client copyWith({
    String? address,
    String? country,
    String? countryCode,
    String? stateProvince,
    String? city,
    String? zipcode,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
    String? description,
    String? iconId,
    String? selectedImageId,
    String? selectedBannerId,
    String? name,
    List<String>? tags,
    String? email,
    String? phone,
    bool? allowRegistration,
    GeoLocation? location,
  }) {
    return Client(
      address: address ?? this.address,
      country: country ?? this.country,
      countryCode: countryCode ?? this.countryCode,
      stateProvince: stateProvince ?? this.stateProvince,
      city: city ?? this.city,
      zipcode: zipcode ?? this.zipcode,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
      description: description ?? this.description,
      iconId: iconId ?? this.iconId,
      selectedImageId: selectedImageId ?? this.selectedImageId,
      selectedBannerId: selectedBannerId ?? this.selectedBannerId,
      name: name ?? this.name,
      tags: tags ?? this.tags,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      allowRegistration: allowRegistration ?? this.allowRegistration,
      location: location ?? this.location,
    );
  }

  Client copyWithWrapped({
    Wrapped<String?>? address,
    Wrapped<String?>? country,
    Wrapped<String?>? countryCode,
    Wrapped<String?>? stateProvince,
    Wrapped<String?>? city,
    Wrapped<String?>? zipcode,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
    Wrapped<String?>? description,
    Wrapped<String?>? iconId,
    Wrapped<String?>? selectedImageId,
    Wrapped<String?>? selectedBannerId,
    Wrapped<String>? name,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<bool?>? allowRegistration,
    Wrapped<GeoLocation?>? location,
  }) {
    return Client(
      address: (address != null ? address.value : this.address),
      country: (country != null ? country.value : this.country),
      countryCode: (countryCode != null ? countryCode.value : this.countryCode),
      stateProvince: (stateProvince != null
          ? stateProvince.value
          : this.stateProvince),
      city: (city != null ? city.value : this.city),
      zipcode: (zipcode != null ? zipcode.value : this.zipcode),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
      description: (description != null ? description.value : this.description),
      iconId: (iconId != null ? iconId.value : this.iconId),
      selectedImageId: (selectedImageId != null
          ? selectedImageId.value
          : this.selectedImageId),
      selectedBannerId: (selectedBannerId != null
          ? selectedBannerId.value
          : this.selectedBannerId),
      name: (name != null ? name.value : this.name),
      tags: (tags != null ? tags.value : this.tags),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      allowRegistration: (allowRegistration != null
          ? allowRegistration.value
          : this.allowRegistration),
      location: (location != null ? location.value : this.location),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ClientEntity {
  const ClientEntity({this.entity});

  factory ClientEntity.fromJson(Map<String, dynamic> json) =>
      _$ClientEntityFromJson(json);

  static const toJsonFactory = _$ClientEntityToJson;
  Map<String, dynamic> toJson() => _$ClientEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Client? entity;
  static const fromJsonFactory = _$ClientEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ClientEntityExtension on ClientEntity {
  ClientEntity copyWith({Client? entity}) {
    return ClientEntity(entity: entity ?? this.entity);
  }

  ClientEntity copyWithWrapped({Wrapped<Client?>? entity}) {
    return ClientEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientEntityRes {
  const ClientEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ClientEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ClientEntityResFromJson(json);

  static const toJsonFactory = _$ClientEntityResToJson;
  Map<String, dynamic> toJson() => _$ClientEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Client? entity;
  static const fromJsonFactory = _$ClientEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ClientEntityResExtension on ClientEntityRes {
  ClientEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Client? entity,
  }) {
    return ClientEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  ClientEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Client?>? entity,
  }) {
    return ClientEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ClientArray {
  const ClientArray({this.values});

  factory ClientArray.fromJson(Map<String, dynamic> json) =>
      _$ClientArrayFromJson(json);

  static const toJsonFactory = _$ClientArrayToJson;
  Map<String, dynamic> toJson() => _$ClientArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Client>[])
  final List<Client>? values;
  static const fromJsonFactory = _$ClientArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ClientArrayExtension on ClientArray {
  ClientArray copyWith({List<Client>? values}) {
    return ClientArray(values: values ?? this.values);
  }

  ClientArray copyWithWrapped({Wrapped<List<Client>?>? values}) {
    return ClientArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientArrayRes {
  const ClientArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ClientArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ClientArrayResFromJson(json);

  static const toJsonFactory = _$ClientArrayResToJson;
  Map<String, dynamic> toJson() => _$ClientArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Client>[])
  final List<Client>? values;
  static const fromJsonFactory = _$ClientArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ClientArrayResExtension on ClientArrayRes {
  ClientArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Client>? values,
  }) {
    return ClientArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  ClientArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Client>?>? values,
  }) {
    return ClientArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BaseQueryRes {
  const BaseQueryRes({this.result});

  factory BaseQueryRes.fromJson(Map<String, dynamic> json) =>
      _$BaseQueryResFromJson(json);

  static const toJsonFactory = _$BaseQueryResToJson;
  Map<String, dynamic> toJson() => _$BaseQueryResToJson(this);

  @JsonKey(name: 'result', includeIfNull: false)
  final Object? result;
  static const fromJsonFactory = _$BaseQueryResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseQueryRes &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(result) ^ runtimeType.hashCode;
}

extension $BaseQueryResExtension on BaseQueryRes {
  BaseQueryRes copyWith({Object? result}) {
    return BaseQueryRes(result: result ?? this.result);
  }

  BaseQueryRes copyWithWrapped({Wrapped<Object?>? result}) {
    return BaseQueryRes(result: (result != null ? result.value : this.result));
  }
}

@JsonSerializable(explicitToJson: true)
class QueryRes {
  const QueryRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.result,
  });

  factory QueryRes.fromJson(Map<String, dynamic> json) =>
      _$QueryResFromJson(json);

  static const toJsonFactory = _$QueryResToJson;
  Map<String, dynamic> toJson() => _$QueryResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'result', includeIfNull: false)
  final Object? result;
  static const fromJsonFactory = _$QueryResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QueryRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(result) ^
      runtimeType.hashCode;
}

extension $QueryResExtension on QueryRes {
  QueryRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Object? result,
  }) {
    return QueryRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      result: result ?? this.result,
    );
  }

  QueryRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Object?>? result,
  }) {
    return QueryRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      result: (result != null ? result.value : this.result),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCountRes {
  const BaseCountRes({required this.total});

  factory BaseCountRes.fromJson(Map<String, dynamic> json) =>
      _$BaseCountResFromJson(json);

  static const toJsonFactory = _$BaseCountResToJson;
  Map<String, dynamic> toJson() => _$BaseCountResToJson(this);

  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  static const fromJsonFactory = _$BaseCountResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseCountRes &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^ runtimeType.hashCode;
}

extension $BaseCountResExtension on BaseCountRes {
  BaseCountRes copyWith({int? total}) {
    return BaseCountRes(total: total ?? this.total);
  }

  BaseCountRes copyWithWrapped({Wrapped<int>? total}) {
    return BaseCountRes(total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class CountRes {
  const CountRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.total,
  });

  factory CountRes.fromJson(Map<String, dynamic> json) =>
      _$CountResFromJson(json);

  static const toJsonFactory = _$CountResToJson;
  Map<String, dynamic> toJson() => _$CountResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  static const fromJsonFactory = _$CountResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CountRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $CountResExtension on CountRes {
  CountRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? total,
  }) {
    return CountRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      total: total ?? this.total,
    );
  }

  CountRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? total,
  }) {
    return CountRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterUnits {
  const ParameterUnits({required this.units});

  factory ParameterUnits.fromJson(Map<String, dynamic> json) =>
      _$ParameterUnitsFromJson(json);

  static const toJsonFactory = _$ParameterUnitsToJson;
  Map<String, dynamic> toJson() => _$ParameterUnitsToJson(this);

  @JsonKey(name: 'units', includeIfNull: false, defaultValue: <String>[])
  final List<String> units;
  static const fromJsonFactory = _$ParameterUnitsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterUnits &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(units) ^ runtimeType.hashCode;
}

extension $ParameterUnitsExtension on ParameterUnits {
  ParameterUnits copyWith({List<String>? units}) {
    return ParameterUnits(units: units ?? this.units);
  }

  ParameterUnits copyWithWrapped({Wrapped<List<String>>? units}) {
    return ParameterUnits(units: (units != null ? units.value : this.units));
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterUnitsEntity {
  const ParameterUnitsEntity({this.entity});

  factory ParameterUnitsEntity.fromJson(Map<String, dynamic> json) =>
      _$ParameterUnitsEntityFromJson(json);

  static const toJsonFactory = _$ParameterUnitsEntityToJson;
  Map<String, dynamic> toJson() => _$ParameterUnitsEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ParameterUnits? entity;
  static const fromJsonFactory = _$ParameterUnitsEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterUnitsEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ParameterUnitsEntityExtension on ParameterUnitsEntity {
  ParameterUnitsEntity copyWith({ParameterUnits? entity}) {
    return ParameterUnitsEntity(entity: entity ?? this.entity);
  }

  ParameterUnitsEntity copyWithWrapped({Wrapped<ParameterUnits?>? entity}) {
    return ParameterUnitsEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterUnitsEntityRes {
  const ParameterUnitsEntityRes({
    this.entity,
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory ParameterUnitsEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ParameterUnitsEntityResFromJson(json);

  static const toJsonFactory = _$ParameterUnitsEntityResToJson;
  Map<String, dynamic> toJson() => _$ParameterUnitsEntityResToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ParameterUnits? entity;
  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$ParameterUnitsEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterUnitsEntityRes &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $ParameterUnitsEntityResExtension on ParameterUnitsEntityRes {
  ParameterUnitsEntityRes copyWith({
    ParameterUnits? entity,
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
  }) {
    return ParameterUnitsEntityRes(
      entity: entity ?? this.entity,
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
    );
  }

  ParameterUnitsEntityRes copyWithWrapped({
    Wrapped<ParameterUnits?>? entity,
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
  }) {
    return ParameterUnitsEntityRes(
      entity: (entity != null ? entity.value : this.entity),
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserRegistration {
  const UserRegistration({
    required this.domainKey,
    required this.email,
    required this.name,
    this.phone,
    this.clientId,
    this.properties,
  });

  factory UserRegistration.fromJson(Map<String, dynamic> json) =>
      _$UserRegistrationFromJson(json);

  static const toJsonFactory = _$UserRegistrationToJson;
  Map<String, dynamic> toJson() => _$UserRegistrationToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'properties', includeIfNull: false)
  final Object? properties;
  static const fromJsonFactory = _$UserRegistrationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserRegistration &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality().equals(
                  other.properties,
                  properties,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(properties) ^
      runtimeType.hashCode;
}

extension $UserRegistrationExtension on UserRegistration {
  UserRegistration copyWith({
    String? domainKey,
    String? email,
    String? name,
    String? phone,
    String? clientId,
    Object? properties,
  }) {
    return UserRegistration(
      domainKey: domainKey ?? this.domainKey,
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      clientId: clientId ?? this.clientId,
      properties: properties ?? this.properties,
    );
  }

  UserRegistration copyWithWrapped({
    Wrapped<String>? domainKey,
    Wrapped<String>? email,
    Wrapped<String>? name,
    Wrapped<String?>? phone,
    Wrapped<String?>? clientId,
    Wrapped<Object?>? properties,
  }) {
    return UserRegistration(
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      email: (email != null ? email.value : this.email),
      name: (name != null ? name.value : this.name),
      phone: (phone != null ? phone.value : this.phone),
      clientId: (clientId != null ? clientId.value : this.clientId),
      properties: (properties != null ? properties.value : this.properties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RegistrationRes {
  const RegistrationRes({
    required this.status,
    this.msg,
    this.trace,
    this.domainKey,
    this.clientId,
    this.pinToken,
    this.pin,
  });

  factory RegistrationRes.fromJson(Map<String, dynamic> json) =>
      _$RegistrationResFromJson(json);

  static const toJsonFactory = _$RegistrationResToJson;
  Map<String, dynamic> toJson() => _$RegistrationResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'pinToken', includeIfNull: false, defaultValue: '')
  final String? pinToken;
  @JsonKey(name: 'pin', includeIfNull: false, defaultValue: '')
  final String? pin;
  static const fromJsonFactory = _$RegistrationResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RegistrationRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.pinToken, pinToken) ||
                const DeepCollectionEquality().equals(
                  other.pinToken,
                  pinToken,
                )) &&
            (identical(other.pin, pin) ||
                const DeepCollectionEquality().equals(other.pin, pin)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(pinToken) ^
      const DeepCollectionEquality().hash(pin) ^
      runtimeType.hashCode;
}

extension $RegistrationResExtension on RegistrationRes {
  RegistrationRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? domainKey,
    String? clientId,
    String? pinToken,
    String? pin,
  }) {
    return RegistrationRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      domainKey: domainKey ?? this.domainKey,
      clientId: clientId ?? this.clientId,
      pinToken: pinToken ?? this.pinToken,
      pin: pin ?? this.pin,
    );
  }

  RegistrationRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? domainKey,
    Wrapped<String?>? clientId,
    Wrapped<String?>? pinToken,
    Wrapped<String?>? pin,
  }) {
    return RegistrationRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      clientId: (clientId != null ? clientId.value : this.clientId),
      pinToken: (pinToken != null ? pinToken.value : this.pinToken),
      pin: (pin != null ? pin.value : this.pin),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class VerificationReq {
  const VerificationReq({
    required this.domainKey,
    required this.pinToken,
    required this.pin,
    this.clientId,
  });

  factory VerificationReq.fromJson(Map<String, dynamic> json) =>
      _$VerificationReqFromJson(json);

  static const toJsonFactory = _$VerificationReqToJson;
  Map<String, dynamic> toJson() => _$VerificationReqToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'pinToken', includeIfNull: false, defaultValue: '')
  final String pinToken;
  @JsonKey(name: 'pin', includeIfNull: false, defaultValue: '')
  final String pin;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$VerificationReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VerificationReq &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.pinToken, pinToken) ||
                const DeepCollectionEquality().equals(
                  other.pinToken,
                  pinToken,
                )) &&
            (identical(other.pin, pin) ||
                const DeepCollectionEquality().equals(other.pin, pin)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(pinToken) ^
      const DeepCollectionEquality().hash(pin) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $VerificationReqExtension on VerificationReq {
  VerificationReq copyWith({
    String? domainKey,
    String? pinToken,
    String? pin,
    String? clientId,
  }) {
    return VerificationReq(
      domainKey: domainKey ?? this.domainKey,
      pinToken: pinToken ?? this.pinToken,
      pin: pin ?? this.pin,
      clientId: clientId ?? this.clientId,
    );
  }

  VerificationReq copyWithWrapped({
    Wrapped<String>? domainKey,
    Wrapped<String>? pinToken,
    Wrapped<String>? pin,
    Wrapped<String?>? clientId,
  }) {
    return VerificationReq(
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      pinToken: (pinToken != null ? pinToken.value : this.pinToken),
      pin: (pin != null ? pin.value : this.pin),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Login {
  const Login({
    required this.userId,
    required this.password,
    this.domainKey,
    this.clientId,
  });

  factory Login.fromJson(Map<String, dynamic> json) => _$LoginFromJson(json);

  static const toJsonFactory = _$LoginToJson;
  Map<String, dynamic> toJson() => _$LoginToJson(this);

  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String userId;
  @JsonKey(name: 'password', includeIfNull: false, defaultValue: '')
  final String password;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$LoginFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Login &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality().equals(
                  other.password,
                  password,
                )) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $LoginExtension on Login {
  Login copyWith({
    String? userId,
    String? password,
    String? domainKey,
    String? clientId,
  }) {
    return Login(
      userId: userId ?? this.userId,
      password: password ?? this.password,
      domainKey: domainKey ?? this.domainKey,
      clientId: clientId ?? this.clientId,
    );
  }

  Login copyWithWrapped({
    Wrapped<String>? userId,
    Wrapped<String>? password,
    Wrapped<String?>? domainKey,
    Wrapped<String?>? clientId,
  }) {
    return Login(
      userId: (userId != null ? userId.value : this.userId),
      password: (password != null ? password.value : this.password),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForgotPassword {
  const ForgotPassword({required this.userId, this.domainKey, this.clientId});

  factory ForgotPassword.fromJson(Map<String, dynamic> json) =>
      _$ForgotPasswordFromJson(json);

  static const toJsonFactory = _$ForgotPasswordToJson;
  Map<String, dynamic> toJson() => _$ForgotPasswordToJson(this);

  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String userId;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$ForgotPasswordFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForgotPassword &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $ForgotPasswordExtension on ForgotPassword {
  ForgotPassword copyWith({
    String? userId,
    String? domainKey,
    String? clientId,
  }) {
    return ForgotPassword(
      userId: userId ?? this.userId,
      domainKey: domainKey ?? this.domainKey,
      clientId: clientId ?? this.clientId,
    );
  }

  ForgotPassword copyWithWrapped({
    Wrapped<String>? userId,
    Wrapped<String?>? domainKey,
    Wrapped<String?>? clientId,
  }) {
    return ForgotPassword(
      userId: (userId != null ? userId.value : this.userId),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ResetPassword {
  const ResetPassword({
    required this.pinToken,
    required this.pin,
    required this.password,
    required this.domainKey,
    this.clientId,
  });

  factory ResetPassword.fromJson(Map<String, dynamic> json) =>
      _$ResetPasswordFromJson(json);

  static const toJsonFactory = _$ResetPasswordToJson;
  Map<String, dynamic> toJson() => _$ResetPasswordToJson(this);

  @JsonKey(name: 'pinToken', includeIfNull: false, defaultValue: '')
  final String pinToken;
  @JsonKey(name: 'pin', includeIfNull: false, defaultValue: '')
  final String pin;
  @JsonKey(name: 'password', includeIfNull: false, defaultValue: '')
  final String password;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$ResetPasswordFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ResetPassword &&
            (identical(other.pinToken, pinToken) ||
                const DeepCollectionEquality().equals(
                  other.pinToken,
                  pinToken,
                )) &&
            (identical(other.pin, pin) ||
                const DeepCollectionEquality().equals(other.pin, pin)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality().equals(
                  other.password,
                  password,
                )) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pinToken) ^
      const DeepCollectionEquality().hash(pin) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $ResetPasswordExtension on ResetPassword {
  ResetPassword copyWith({
    String? pinToken,
    String? pin,
    String? password,
    String? domainKey,
    String? clientId,
  }) {
    return ResetPassword(
      pinToken: pinToken ?? this.pinToken,
      pin: pin ?? this.pin,
      password: password ?? this.password,
      domainKey: domainKey ?? this.domainKey,
      clientId: clientId ?? this.clientId,
    );
  }

  ResetPassword copyWithWrapped({
    Wrapped<String>? pinToken,
    Wrapped<String>? pin,
    Wrapped<String>? password,
    Wrapped<String>? domainKey,
    Wrapped<String?>? clientId,
  }) {
    return ResetPassword(
      pinToken: (pinToken != null ? pinToken.value : this.pinToken),
      pin: (pin != null ? pin.value : this.pin),
      password: (password != null ? password.value : this.password),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChangePassword {
  const ChangePassword({required this.oldPassword, required this.newPassword});

  factory ChangePassword.fromJson(Map<String, dynamic> json) =>
      _$ChangePasswordFromJson(json);

  static const toJsonFactory = _$ChangePasswordToJson;
  Map<String, dynamic> toJson() => _$ChangePasswordToJson(this);

  @JsonKey(name: 'oldPassword', includeIfNull: false, defaultValue: '')
  final String oldPassword;
  @JsonKey(name: 'newPassword', includeIfNull: false, defaultValue: '')
  final String newPassword;
  static const fromJsonFactory = _$ChangePasswordFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChangePassword &&
            (identical(other.oldPassword, oldPassword) ||
                const DeepCollectionEquality().equals(
                  other.oldPassword,
                  oldPassword,
                )) &&
            (identical(other.newPassword, newPassword) ||
                const DeepCollectionEquality().equals(
                  other.newPassword,
                  newPassword,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oldPassword) ^
      const DeepCollectionEquality().hash(newPassword) ^
      runtimeType.hashCode;
}

extension $ChangePasswordExtension on ChangePassword {
  ChangePassword copyWith({String? oldPassword, String? newPassword}) {
    return ChangePassword(
      oldPassword: oldPassword ?? this.oldPassword,
      newPassword: newPassword ?? this.newPassword,
    );
  }

  ChangePassword copyWithWrapped({
    Wrapped<String>? oldPassword,
    Wrapped<String>? newPassword,
  }) {
    return ChangePassword(
      oldPassword: (oldPassword != null ? oldPassword.value : this.oldPassword),
      newPassword: (newPassword != null ? newPassword.value : this.newPassword),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChangeEmail {
  const ChangeEmail({required this.email});

  factory ChangeEmail.fromJson(Map<String, dynamic> json) =>
      _$ChangeEmailFromJson(json);

  static const toJsonFactory = _$ChangeEmailToJson;
  Map<String, dynamic> toJson() => _$ChangeEmailToJson(this);

  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  static const fromJsonFactory = _$ChangeEmailFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChangeEmail &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^ runtimeType.hashCode;
}

extension $ChangeEmailExtension on ChangeEmail {
  ChangeEmail copyWith({String? email}) {
    return ChangeEmail(email: email ?? this.email);
  }

  ChangeEmail copyWithWrapped({Wrapped<String>? email}) {
    return ChangeEmail(email: (email != null ? email.value : this.email));
  }
}

@JsonSerializable(explicitToJson: true)
class ReprocessInfo {
  const ReprocessInfo({
    required this.hardwareDeviceId,
    required this.clearHistory,
    required this.clearStatus,
  });

  factory ReprocessInfo.fromJson(Map<String, dynamic> json) =>
      _$ReprocessInfoFromJson(json);

  static const toJsonFactory = _$ReprocessInfoToJson;
  Map<String, dynamic> toJson() => _$ReprocessInfoToJson(this);

  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String hardwareDeviceId;
  @JsonKey(name: 'clearHistory', includeIfNull: false, defaultValue: false)
  final bool clearHistory;
  @JsonKey(name: 'clearStatus', includeIfNull: false, defaultValue: false)
  final bool clearStatus;
  static const fromJsonFactory = _$ReprocessInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReprocessInfo &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality().equals(
                  other.hardwareDeviceId,
                  hardwareDeviceId,
                )) &&
            (identical(other.clearHistory, clearHistory) ||
                const DeepCollectionEquality().equals(
                  other.clearHistory,
                  clearHistory,
                )) &&
            (identical(other.clearStatus, clearStatus) ||
                const DeepCollectionEquality().equals(
                  other.clearStatus,
                  clearStatus,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      const DeepCollectionEquality().hash(clearHistory) ^
      const DeepCollectionEquality().hash(clearStatus) ^
      runtimeType.hashCode;
}

extension $ReprocessInfoExtension on ReprocessInfo {
  ReprocessInfo copyWith({
    String? hardwareDeviceId,
    bool? clearHistory,
    bool? clearStatus,
  }) {
    return ReprocessInfo(
      hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId,
      clearHistory: clearHistory ?? this.clearHistory,
      clearStatus: clearStatus ?? this.clearStatus,
    );
  }

  ReprocessInfo copyWithWrapped({
    Wrapped<String>? hardwareDeviceId,
    Wrapped<bool>? clearHistory,
    Wrapped<bool>? clearStatus,
  }) {
    return ReprocessInfo(
      hardwareDeviceId: (hardwareDeviceId != null
          ? hardwareDeviceId.value
          : this.hardwareDeviceId),
      clearHistory: (clearHistory != null
          ? clearHistory.value
          : this.clearHistory),
      clearStatus: (clearStatus != null ? clearStatus.value : this.clearStatus),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NonReportingReq {
  const NonReportingReq({this.intervalHours, this.timeZone, this.size});

  factory NonReportingReq.fromJson(Map<String, dynamic> json) =>
      _$NonReportingReqFromJson(json);

  static const toJsonFactory = _$NonReportingReqToJson;
  Map<String, dynamic> toJson() => _$NonReportingReqToJson(this);

  @JsonKey(name: 'intervalHours', includeIfNull: false)
  final int? intervalHours;
  @JsonKey(name: 'timeZone', includeIfNull: false, defaultValue: '')
  final String? timeZone;
  @JsonKey(name: 'size', includeIfNull: false)
  final int? size;
  static const fromJsonFactory = _$NonReportingReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NonReportingReq &&
            (identical(other.intervalHours, intervalHours) ||
                const DeepCollectionEquality().equals(
                  other.intervalHours,
                  intervalHours,
                )) &&
            (identical(other.timeZone, timeZone) ||
                const DeepCollectionEquality().equals(
                  other.timeZone,
                  timeZone,
                )) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(intervalHours) ^
      const DeepCollectionEquality().hash(timeZone) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $NonReportingReqExtension on NonReportingReq {
  NonReportingReq copyWith({int? intervalHours, String? timeZone, int? size}) {
    return NonReportingReq(
      intervalHours: intervalHours ?? this.intervalHours,
      timeZone: timeZone ?? this.timeZone,
      size: size ?? this.size,
    );
  }

  NonReportingReq copyWithWrapped({
    Wrapped<int?>? intervalHours,
    Wrapped<String?>? timeZone,
    Wrapped<int?>? size,
  }) {
    return NonReportingReq(
      intervalHours: (intervalHours != null
          ? intervalHours.value
          : this.intervalHours),
      timeZone: (timeZone != null ? timeZone.value : this.timeZone),
      size: (size != null ? size.value : this.size),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UnregisterAccount {
  const UnregisterAccount({
    required this.reason,
    required this.password,
    this.domainKey,
    this.clientId,
  });

  factory UnregisterAccount.fromJson(Map<String, dynamic> json) =>
      _$UnregisterAccountFromJson(json);

  static const toJsonFactory = _$UnregisterAccountToJson;
  Map<String, dynamic> toJson() => _$UnregisterAccountToJson(this);

  @JsonKey(name: 'reason', includeIfNull: false, defaultValue: '')
  final String reason;
  @JsonKey(name: 'password', includeIfNull: false, defaultValue: '')
  final String password;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$UnregisterAccountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UnregisterAccount &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality().equals(
                  other.password,
                  password,
                )) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(reason) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $UnregisterAccountExtension on UnregisterAccount {
  UnregisterAccount copyWith({
    String? reason,
    String? password,
    String? domainKey,
    String? clientId,
  }) {
    return UnregisterAccount(
      reason: reason ?? this.reason,
      password: password ?? this.password,
      domainKey: domainKey ?? this.domainKey,
      clientId: clientId ?? this.clientId,
    );
  }

  UnregisterAccount copyWithWrapped({
    Wrapped<String>? reason,
    Wrapped<String>? password,
    Wrapped<String?>? domainKey,
    Wrapped<String?>? clientId,
  }) {
    return UnregisterAccount(
      reason: (reason != null ? reason.value : this.reason),
      password: (password != null ? password.value : this.password),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomSearchReqBase {
  const CustomSearchReqBase({required this.fields, this.sort});

  factory CustomSearchReqBase.fromJson(Map<String, dynamic> json) =>
      _$CustomSearchReqBaseFromJson(json);

  static const toJsonFactory = _$CustomSearchReqBaseToJson;
  Map<String, dynamic> toJson() => _$CustomSearchReqBaseToJson(this);

  @JsonKey(name: 'fields', includeIfNull: false, defaultValue: <String>[])
  final List<String> fields;
  @JsonKey(name: 'sort', includeIfNull: false)
  final Object? sort;
  static const fromJsonFactory = _$CustomSearchReqBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomSearchReqBase &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)) &&
            (identical(other.sort, sort) ||
                const DeepCollectionEquality().equals(other.sort, sort)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fields) ^
      const DeepCollectionEquality().hash(sort) ^
      runtimeType.hashCode;
}

extension $CustomSearchReqBaseExtension on CustomSearchReqBase {
  CustomSearchReqBase copyWith({List<String>? fields, Object? sort}) {
    return CustomSearchReqBase(
      fields: fields ?? this.fields,
      sort: sort ?? this.sort,
    );
  }

  CustomSearchReqBase copyWithWrapped({
    Wrapped<List<String>>? fields,
    Wrapped<Object?>? sort,
  }) {
    return CustomSearchReqBase(
      fields: (fields != null ? fields.value : this.fields),
      sort: (sort != null ? sort.value : this.sort),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomSearchReq {
  const CustomSearchReq({
    required this.query,
    required this.fields,
    this.sort,
    required this.page,
    required this.size,
  });

  factory CustomSearchReq.fromJson(Map<String, dynamic> json) =>
      _$CustomSearchReqFromJson(json);

  static const toJsonFactory = _$CustomSearchReqToJson;
  Map<String, dynamic> toJson() => _$CustomSearchReqToJson(this);

  @JsonKey(name: 'query', includeIfNull: false)
  final Object query;
  @JsonKey(name: 'fields', includeIfNull: false, defaultValue: <String>[])
  final List<String> fields;
  @JsonKey(name: 'sort', includeIfNull: false)
  final Object? sort;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  static const fromJsonFactory = _$CustomSearchReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomSearchReq &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)) &&
            (identical(other.sort, sort) ||
                const DeepCollectionEquality().equals(other.sort, sort)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(fields) ^
      const DeepCollectionEquality().hash(sort) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $CustomSearchReqExtension on CustomSearchReq {
  CustomSearchReq copyWith({
    Object? query,
    List<String>? fields,
    Object? sort,
    int? page,
    int? size,
  }) {
    return CustomSearchReq(
      query: query ?? this.query,
      fields: fields ?? this.fields,
      sort: sort ?? this.sort,
      page: page ?? this.page,
      size: size ?? this.size,
    );
  }

  CustomSearchReq copyWithWrapped({
    Wrapped<Object>? query,
    Wrapped<List<String>>? fields,
    Wrapped<Object?>? sort,
    Wrapped<int>? page,
    Wrapped<int>? size,
  }) {
    return CustomSearchReq(
      query: (query != null ? query.value : this.query),
      fields: (fields != null ? fields.value : this.fields),
      sort: (sort != null ? sort.value : this.sort),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntity {
  const CustomEntity({this.entity});

  factory CustomEntity.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityFromJson(json);

  static const toJsonFactory = _$CustomEntityToJson;
  Map<String, dynamic> toJson() => _$CustomEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Object? entity;
  static const fromJsonFactory = _$CustomEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $CustomEntityExtension on CustomEntity {
  CustomEntity copyWith({Object? entity}) {
    return CustomEntity(entity: entity ?? this.entity);
  }

  CustomEntity copyWithWrapped({Wrapped<Object?>? entity}) {
    return CustomEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityRes {
  const CustomEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory CustomEntityRes.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityResFromJson(json);

  static const toJsonFactory = _$CustomEntityResToJson;
  Map<String, dynamic> toJson() => _$CustomEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Object? entity;
  static const fromJsonFactory = _$CustomEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $CustomEntityResExtension on CustomEntityRes {
  CustomEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    Object? entity,
  }) {
    return CustomEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  CustomEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<Object?>? entity,
  }) {
    return CustomEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityArray {
  const CustomEntityArray({this.values});

  factory CustomEntityArray.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityArrayFromJson(json);

  static const toJsonFactory = _$CustomEntityArrayToJson;
  Map<String, dynamic> toJson() => _$CustomEntityArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? values;
  static const fromJsonFactory = _$CustomEntityArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $CustomEntityArrayExtension on CustomEntityArray {
  CustomEntityArray copyWith({List<Object>? values}) {
    return CustomEntityArray(values: values ?? this.values);
  }

  CustomEntityArray copyWithWrapped({Wrapped<List<Object>?>? values}) {
    return CustomEntityArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityArrayRes {
  const CustomEntityArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory CustomEntityArrayRes.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityArrayResFromJson(json);

  static const toJsonFactory = _$CustomEntityArrayResToJson;
  Map<String, dynamic> toJson() => _$CustomEntityArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? values;
  static const fromJsonFactory = _$CustomEntityArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $CustomEntityArrayResExtension on CustomEntityArrayRes {
  CustomEntityArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<Object>? values,
  }) {
    return CustomEntityArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  CustomEntityArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<Object>?>? values,
  }) {
    return CustomEntityArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityField {
  const CustomEntityField({
    required this.name,
    this.scalingFactor,
    this.aliasPath,
    required this.type,
  });

  factory CustomEntityField.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityFieldFromJson(json);

  static const toJsonFactory = _$CustomEntityFieldToJson;
  Map<String, dynamic> toJson() => _$CustomEntityFieldToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'scalingFactor', includeIfNull: false)
  final double? scalingFactor;
  @JsonKey(name: 'aliasPath', includeIfNull: false, defaultValue: '')
  final String? aliasPath;
  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: customEntityFieldTypeToJson,
    fromJson: customEntityFieldTypeFromJson,
  )
  final enums.CustomEntityFieldType type;
  static const fromJsonFactory = _$CustomEntityFieldFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityField &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.scalingFactor, scalingFactor) ||
                const DeepCollectionEquality().equals(
                  other.scalingFactor,
                  scalingFactor,
                )) &&
            (identical(other.aliasPath, aliasPath) ||
                const DeepCollectionEquality().equals(
                  other.aliasPath,
                  aliasPath,
                )) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(scalingFactor) ^
      const DeepCollectionEquality().hash(aliasPath) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $CustomEntityFieldExtension on CustomEntityField {
  CustomEntityField copyWith({
    String? name,
    double? scalingFactor,
    String? aliasPath,
    enums.CustomEntityFieldType? type,
  }) {
    return CustomEntityField(
      name: name ?? this.name,
      scalingFactor: scalingFactor ?? this.scalingFactor,
      aliasPath: aliasPath ?? this.aliasPath,
      type: type ?? this.type,
    );
  }

  CustomEntityField copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<double?>? scalingFactor,
    Wrapped<String?>? aliasPath,
    Wrapped<enums.CustomEntityFieldType>? type,
  }) {
    return CustomEntityField(
      name: (name != null ? name.value : this.name),
      scalingFactor: (scalingFactor != null
          ? scalingFactor.value
          : this.scalingFactor),
      aliasPath: (aliasPath != null ? aliasPath.value : this.aliasPath),
      type: (type != null ? type.value : this.type),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityMappingInfo {
  const CustomEntityMappingInfo({
    required this.name,
    required this.relaxed,
    required this.fields,
  });

  factory CustomEntityMappingInfo.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityMappingInfoFromJson(json);

  static const toJsonFactory = _$CustomEntityMappingInfoToJson;
  Map<String, dynamic> toJson() => _$CustomEntityMappingInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'relaxed', includeIfNull: false)
  final bool relaxed;
  @JsonKey(
    name: 'fields',
    includeIfNull: false,
    defaultValue: <CustomEntityField>[],
  )
  final List<CustomEntityField> fields;
  static const fromJsonFactory = _$CustomEntityMappingInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityMappingInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.relaxed, relaxed) ||
                const DeepCollectionEquality().equals(
                  other.relaxed,
                  relaxed,
                )) &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(relaxed) ^
      const DeepCollectionEquality().hash(fields) ^
      runtimeType.hashCode;
}

extension $CustomEntityMappingInfoExtension on CustomEntityMappingInfo {
  CustomEntityMappingInfo copyWith({
    String? name,
    bool? relaxed,
    List<CustomEntityField>? fields,
  }) {
    return CustomEntityMappingInfo(
      name: name ?? this.name,
      relaxed: relaxed ?? this.relaxed,
      fields: fields ?? this.fields,
    );
  }

  CustomEntityMappingInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<bool>? relaxed,
    Wrapped<List<CustomEntityField>>? fields,
  }) {
    return CustomEntityMappingInfo(
      name: (name != null ? name.value : this.name),
      relaxed: (relaxed != null ? relaxed.value : this.relaxed),
      fields: (fields != null ? fields.value : this.fields),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityMapping {
  const CustomEntityMapping({
    required this.name,
    required this.relaxed,
    required this.fields,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory CustomEntityMapping.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityMappingFromJson(json);

  static const toJsonFactory = _$CustomEntityMappingToJson;
  Map<String, dynamic> toJson() => _$CustomEntityMappingToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'relaxed', includeIfNull: false)
  final bool relaxed;
  @JsonKey(
    name: 'fields',
    includeIfNull: false,
    defaultValue: <CustomEntityField>[],
  )
  final List<CustomEntityField> fields;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$CustomEntityMappingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityMapping &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.relaxed, relaxed) ||
                const DeepCollectionEquality().equals(
                  other.relaxed,
                  relaxed,
                )) &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(relaxed) ^
      const DeepCollectionEquality().hash(fields) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $CustomEntityMappingExtension on CustomEntityMapping {
  CustomEntityMapping copyWith({
    String? name,
    bool? relaxed,
    List<CustomEntityField>? fields,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return CustomEntityMapping(
      name: name ?? this.name,
      relaxed: relaxed ?? this.relaxed,
      fields: fields ?? this.fields,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  CustomEntityMapping copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<bool>? relaxed,
    Wrapped<List<CustomEntityField>>? fields,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return CustomEntityMapping(
      name: (name != null ? name.value : this.name),
      relaxed: (relaxed != null ? relaxed.value : this.relaxed),
      fields: (fields != null ? fields.value : this.fields),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityMappingEntity {
  const CustomEntityMappingEntity({this.entity});

  factory CustomEntityMappingEntity.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityMappingEntityFromJson(json);

  static const toJsonFactory = _$CustomEntityMappingEntityToJson;
  Map<String, dynamic> toJson() => _$CustomEntityMappingEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final CustomEntityMapping? entity;
  static const fromJsonFactory = _$CustomEntityMappingEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityMappingEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $CustomEntityMappingEntityExtension on CustomEntityMappingEntity {
  CustomEntityMappingEntity copyWith({CustomEntityMapping? entity}) {
    return CustomEntityMappingEntity(entity: entity ?? this.entity);
  }

  CustomEntityMappingEntity copyWithWrapped({
    Wrapped<CustomEntityMapping?>? entity,
  }) {
    return CustomEntityMappingEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityMappingRes {
  const CustomEntityMappingRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory CustomEntityMappingRes.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityMappingResFromJson(json);

  static const toJsonFactory = _$CustomEntityMappingResToJson;
  Map<String, dynamic> toJson() => _$CustomEntityMappingResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final CustomEntityMapping? entity;
  static const fromJsonFactory = _$CustomEntityMappingResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityMappingRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $CustomEntityMappingResExtension on CustomEntityMappingRes {
  CustomEntityMappingRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    CustomEntityMapping? entity,
  }) {
    return CustomEntityMappingRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  CustomEntityMappingRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<CustomEntityMapping?>? entity,
  }) {
    return CustomEntityMappingRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityMappingArray {
  const CustomEntityMappingArray({this.values});

  factory CustomEntityMappingArray.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityMappingArrayFromJson(json);

  static const toJsonFactory = _$CustomEntityMappingArrayToJson;
  Map<String, dynamic> toJson() => _$CustomEntityMappingArrayToJson(this);

  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <CustomEntityMapping>[],
  )
  final List<CustomEntityMapping>? values;
  static const fromJsonFactory = _$CustomEntityMappingArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityMappingArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $CustomEntityMappingArrayExtension on CustomEntityMappingArray {
  CustomEntityMappingArray copyWith({List<CustomEntityMapping>? values}) {
    return CustomEntityMappingArray(values: values ?? this.values);
  }

  CustomEntityMappingArray copyWithWrapped({
    Wrapped<List<CustomEntityMapping>?>? values,
  }) {
    return CustomEntityMappingArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CustomEntityMappingArrayRes {
  const CustomEntityMappingArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory CustomEntityMappingArrayRes.fromJson(Map<String, dynamic> json) =>
      _$CustomEntityMappingArrayResFromJson(json);

  static const toJsonFactory = _$CustomEntityMappingArrayResToJson;
  Map<String, dynamic> toJson() => _$CustomEntityMappingArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
    name: 'values',
    includeIfNull: false,
    defaultValue: <CustomEntityMapping>[],
  )
  final List<CustomEntityMapping>? values;
  static const fromJsonFactory = _$CustomEntityMappingArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomEntityMappingArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $CustomEntityMappingArrayResExtension on CustomEntityMappingArrayRes {
  CustomEntityMappingArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<CustomEntityMapping>? values,
  }) {
    return CustomEntityMappingArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  CustomEntityMappingArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<CustomEntityMapping>?>? values,
  }) {
    return CustomEntityMappingArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ApiTokenInfo {
  const ApiTokenInfo({required this.role, this.domainKey, this.clientId});

  factory ApiTokenInfo.fromJson(Map<String, dynamic> json) =>
      _$ApiTokenInfoFromJson(json);

  static const toJsonFactory = _$ApiTokenInfoToJson;
  Map<String, dynamic> toJson() => _$ApiTokenInfoToJson(this);

  @JsonKey(
    name: 'role',
    includeIfNull: false,
    toJson: apiTokenInfoRoleToJson,
    fromJson: apiTokenInfoRoleFromJson,
  )
  final enums.ApiTokenInfoRole role;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  static const fromJsonFactory = _$ApiTokenInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiTokenInfo &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $ApiTokenInfoExtension on ApiTokenInfo {
  ApiTokenInfo copyWith({
    enums.ApiTokenInfoRole? role,
    String? domainKey,
    String? clientId,
  }) {
    return ApiTokenInfo(
      role: role ?? this.role,
      domainKey: domainKey ?? this.domainKey,
      clientId: clientId ?? this.clientId,
    );
  }

  ApiTokenInfo copyWithWrapped({
    Wrapped<enums.ApiTokenInfoRole>? role,
    Wrapped<String?>? domainKey,
    Wrapped<String?>? clientId,
  }) {
    return ApiTokenInfo(
      role: (role != null ? role.value : this.role),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      clientId: (clientId != null ? clientId.value : this.clientId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ApiToken {
  const ApiToken({
    required this.role,
    this.domainKey,
    this.clientId,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory ApiToken.fromJson(Map<String, dynamic> json) =>
      _$ApiTokenFromJson(json);

  static const toJsonFactory = _$ApiTokenToJson;
  Map<String, dynamic> toJson() => _$ApiTokenToJson(this);

  @JsonKey(
    name: 'role',
    includeIfNull: false,
    toJson: apiTokenRoleToJson,
    fromJson: apiTokenRoleFromJson,
  )
  final enums.ApiTokenRole role;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String? domainKey;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$ApiTokenFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiToken &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality().equals(
                  other.domainKey,
                  domainKey,
                )) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality().equals(
                  other.clientId,
                  clientId,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $ApiTokenExtension on ApiToken {
  ApiToken copyWith({
    enums.ApiTokenRole? role,
    String? domainKey,
    String? clientId,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return ApiToken(
      role: role ?? this.role,
      domainKey: domainKey ?? this.domainKey,
      clientId: clientId ?? this.clientId,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  ApiToken copyWithWrapped({
    Wrapped<enums.ApiTokenRole>? role,
    Wrapped<String?>? domainKey,
    Wrapped<String?>? clientId,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return ApiToken(
      role: (role != null ? role.value : this.role),
      domainKey: (domainKey != null ? domainKey.value : this.domainKey),
      clientId: (clientId != null ? clientId.value : this.clientId),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ApiTokenEntity {
  const ApiTokenEntity({this.entity});

  factory ApiTokenEntity.fromJson(Map<String, dynamic> json) =>
      _$ApiTokenEntityFromJson(json);

  static const toJsonFactory = _$ApiTokenEntityToJson;
  Map<String, dynamic> toJson() => _$ApiTokenEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ApiToken? entity;
  static const fromJsonFactory = _$ApiTokenEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiTokenEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ApiTokenEntityExtension on ApiTokenEntity {
  ApiTokenEntity copyWith({ApiToken? entity}) {
    return ApiTokenEntity(entity: entity ?? this.entity);
  }

  ApiTokenEntity copyWithWrapped({Wrapped<ApiToken?>? entity}) {
    return ApiTokenEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ApiTokenEntityRes {
  const ApiTokenEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ApiTokenEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ApiTokenEntityResFromJson(json);

  static const toJsonFactory = _$ApiTokenEntityResToJson;
  Map<String, dynamic> toJson() => _$ApiTokenEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final ApiToken? entity;
  static const fromJsonFactory = _$ApiTokenEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiTokenEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ApiTokenEntityResExtension on ApiTokenEntityRes {
  ApiTokenEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    ApiToken? entity,
  }) {
    return ApiTokenEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  ApiTokenEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<ApiToken?>? entity,
  }) {
    return ApiTokenEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ApiTokenArray {
  const ApiTokenArray({this.values});

  factory ApiTokenArray.fromJson(Map<String, dynamic> json) =>
      _$ApiTokenArrayFromJson(json);

  static const toJsonFactory = _$ApiTokenArrayToJson;
  Map<String, dynamic> toJson() => _$ApiTokenArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <ApiToken>[])
  final List<ApiToken>? values;
  static const fromJsonFactory = _$ApiTokenArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiTokenArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ApiTokenArrayExtension on ApiTokenArray {
  ApiTokenArray copyWith({List<ApiToken>? values}) {
    return ApiTokenArray(values: values ?? this.values);
  }

  ApiTokenArray copyWithWrapped({Wrapped<List<ApiToken>?>? values}) {
    return ApiTokenArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ApiTokenArrayRes {
  const ApiTokenArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ApiTokenArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ApiTokenArrayResFromJson(json);

  static const toJsonFactory = _$ApiTokenArrayResToJson;
  Map<String, dynamic> toJson() => _$ApiTokenArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <ApiToken>[])
  final List<ApiToken>? values;
  static const fromJsonFactory = _$ApiTokenArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiTokenArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ApiTokenArrayResExtension on ApiTokenArrayRes {
  ApiTokenArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<ApiToken>? values,
  }) {
    return ApiTokenArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  ApiTokenArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<ApiToken>?>? values,
  }) {
    return ApiTokenArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EqlTemplateInfo {
  const EqlTemplateInfo({
    required this.name,
    required this.query,
    this.transformerCode,
    this.protocol,
    this.extraPath,
  });

  factory EqlTemplateInfo.fromJson(Map<String, dynamic> json) =>
      _$EqlTemplateInfoFromJson(json);

  static const toJsonFactory = _$EqlTemplateInfoToJson;
  Map<String, dynamic> toJson() => _$EqlTemplateInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'query', includeIfNull: false, defaultValue: '')
  final String query;
  @JsonKey(name: 'transformerCode', includeIfNull: false, defaultValue: '')
  final String? transformerCode;
  @JsonKey(
    name: 'protocol',
    includeIfNull: false,
    toJson: eqlTemplateInfoProtocolNullableToJson,
    fromJson: eqlTemplateInfoProtocolProtocolNullableFromJson,
  )
  final enums.EqlTemplateInfoProtocol? protocol;
  static enums.EqlTemplateInfoProtocol?
  eqlTemplateInfoProtocolProtocolNullableFromJson(Object? value) =>
      eqlTemplateInfoProtocolNullableFromJson(
        value,
        enums.EqlTemplateInfoProtocol.post,
      );

  @JsonKey(name: 'extraPath', includeIfNull: false, defaultValue: '')
  final String? extraPath;
  static const fromJsonFactory = _$EqlTemplateInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlTemplateInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.transformerCode, transformerCode) ||
                const DeepCollectionEquality().equals(
                  other.transformerCode,
                  transformerCode,
                )) &&
            (identical(other.protocol, protocol) ||
                const DeepCollectionEquality().equals(
                  other.protocol,
                  protocol,
                )) &&
            (identical(other.extraPath, extraPath) ||
                const DeepCollectionEquality().equals(
                  other.extraPath,
                  extraPath,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(transformerCode) ^
      const DeepCollectionEquality().hash(protocol) ^
      const DeepCollectionEquality().hash(extraPath) ^
      runtimeType.hashCode;
}

extension $EqlTemplateInfoExtension on EqlTemplateInfo {
  EqlTemplateInfo copyWith({
    String? name,
    String? query,
    String? transformerCode,
    enums.EqlTemplateInfoProtocol? protocol,
    String? extraPath,
  }) {
    return EqlTemplateInfo(
      name: name ?? this.name,
      query: query ?? this.query,
      transformerCode: transformerCode ?? this.transformerCode,
      protocol: protocol ?? this.protocol,
      extraPath: extraPath ?? this.extraPath,
    );
  }

  EqlTemplateInfo copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? query,
    Wrapped<String?>? transformerCode,
    Wrapped<enums.EqlTemplateInfoProtocol?>? protocol,
    Wrapped<String?>? extraPath,
  }) {
    return EqlTemplateInfo(
      name: (name != null ? name.value : this.name),
      query: (query != null ? query.value : this.query),
      transformerCode: (transformerCode != null
          ? transformerCode.value
          : this.transformerCode),
      protocol: (protocol != null ? protocol.value : this.protocol),
      extraPath: (extraPath != null ? extraPath.value : this.extraPath),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EqlTemplate {
  const EqlTemplate({
    required this.name,
    required this.query,
    this.transformerCode,
    this.protocol,
    this.extraPath,
    required this.id,
    required this.rtype,
    this.stype,
    required this.createdStamp,
    required this.updatedStamp,
    required this.createdBy,
    required this.updatedBy,
  });

  factory EqlTemplate.fromJson(Map<String, dynamic> json) =>
      _$EqlTemplateFromJson(json);

  static const toJsonFactory = _$EqlTemplateToJson;
  Map<String, dynamic> toJson() => _$EqlTemplateToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'query', includeIfNull: false, defaultValue: '')
  final String query;
  @JsonKey(name: 'transformerCode', includeIfNull: false, defaultValue: '')
  final String? transformerCode;
  @JsonKey(
    name: 'protocol',
    includeIfNull: false,
    toJson: eqlTemplateProtocolNullableToJson,
    fromJson: eqlTemplateProtocolProtocolNullableFromJson,
  )
  final enums.EqlTemplateProtocol? protocol;
  static enums.EqlTemplateProtocol? eqlTemplateProtocolProtocolNullableFromJson(
    Object? value,
  ) => eqlTemplateProtocolNullableFromJson(
    value,
    enums.EqlTemplateProtocol.post,
  );

  @JsonKey(name: 'extraPath', includeIfNull: false, defaultValue: '')
  final String? extraPath;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'stype', includeIfNull: false, defaultValue: '')
  final String? stype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  static const fromJsonFactory = _$EqlTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlTemplate &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.transformerCode, transformerCode) ||
                const DeepCollectionEquality().equals(
                  other.transformerCode,
                  transformerCode,
                )) &&
            (identical(other.protocol, protocol) ||
                const DeepCollectionEquality().equals(
                  other.protocol,
                  protocol,
                )) &&
            (identical(other.extraPath, extraPath) ||
                const DeepCollectionEquality().equals(
                  other.extraPath,
                  extraPath,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.stype, stype) ||
                const DeepCollectionEquality().equals(other.stype, stype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(
                  other.createdStamp,
                  createdStamp,
                )) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality().equals(
                  other.updatedStamp,
                  updatedStamp,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality().equals(
                  other.updatedBy,
                  updatedBy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(transformerCode) ^
      const DeepCollectionEquality().hash(protocol) ^
      const DeepCollectionEquality().hash(extraPath) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(stype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      runtimeType.hashCode;
}

extension $EqlTemplateExtension on EqlTemplate {
  EqlTemplate copyWith({
    String? name,
    String? query,
    String? transformerCode,
    enums.EqlTemplateProtocol? protocol,
    String? extraPath,
    String? id,
    String? rtype,
    String? stype,
    int? createdStamp,
    int? updatedStamp,
    String? createdBy,
    String? updatedBy,
  }) {
    return EqlTemplate(
      name: name ?? this.name,
      query: query ?? this.query,
      transformerCode: transformerCode ?? this.transformerCode,
      protocol: protocol ?? this.protocol,
      extraPath: extraPath ?? this.extraPath,
      id: id ?? this.id,
      rtype: rtype ?? this.rtype,
      stype: stype ?? this.stype,
      createdStamp: createdStamp ?? this.createdStamp,
      updatedStamp: updatedStamp ?? this.updatedStamp,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
    );
  }

  EqlTemplate copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? query,
    Wrapped<String?>? transformerCode,
    Wrapped<enums.EqlTemplateProtocol?>? protocol,
    Wrapped<String?>? extraPath,
    Wrapped<String>? id,
    Wrapped<String>? rtype,
    Wrapped<String?>? stype,
    Wrapped<int>? createdStamp,
    Wrapped<int>? updatedStamp,
    Wrapped<String>? createdBy,
    Wrapped<String>? updatedBy,
  }) {
    return EqlTemplate(
      name: (name != null ? name.value : this.name),
      query: (query != null ? query.value : this.query),
      transformerCode: (transformerCode != null
          ? transformerCode.value
          : this.transformerCode),
      protocol: (protocol != null ? protocol.value : this.protocol),
      extraPath: (extraPath != null ? extraPath.value : this.extraPath),
      id: (id != null ? id.value : this.id),
      rtype: (rtype != null ? rtype.value : this.rtype),
      stype: (stype != null ? stype.value : this.stype),
      createdStamp: (createdStamp != null
          ? createdStamp.value
          : this.createdStamp),
      updatedStamp: (updatedStamp != null
          ? updatedStamp.value
          : this.updatedStamp),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EqlTemplateEntity {
  const EqlTemplateEntity({this.entity});

  factory EqlTemplateEntity.fromJson(Map<String, dynamic> json) =>
      _$EqlTemplateEntityFromJson(json);

  static const toJsonFactory = _$EqlTemplateEntityToJson;
  Map<String, dynamic> toJson() => _$EqlTemplateEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final EqlTemplate? entity;
  static const fromJsonFactory = _$EqlTemplateEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlTemplateEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $EqlTemplateEntityExtension on EqlTemplateEntity {
  EqlTemplateEntity copyWith({EqlTemplate? entity}) {
    return EqlTemplateEntity(entity: entity ?? this.entity);
  }

  EqlTemplateEntity copyWithWrapped({Wrapped<EqlTemplate?>? entity}) {
    return EqlTemplateEntity(
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EqlTemplateEntityRes {
  const EqlTemplateEntityRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory EqlTemplateEntityRes.fromJson(Map<String, dynamic> json) =>
      _$EqlTemplateEntityResFromJson(json);

  static const toJsonFactory = _$EqlTemplateEntityResToJson;
  Map<String, dynamic> toJson() => _$EqlTemplateEntityResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final EqlTemplate? entity;
  static const fromJsonFactory = _$EqlTemplateEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlTemplateEntityRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $EqlTemplateEntityResExtension on EqlTemplateEntityRes {
  EqlTemplateEntityRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    EqlTemplate? entity,
  }) {
    return EqlTemplateEntityRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      entity: entity ?? this.entity,
    );
  }

  EqlTemplateEntityRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<EqlTemplate?>? entity,
  }) {
    return EqlTemplateEntityRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      entity: (entity != null ? entity.value : this.entity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EqlTemplateArray {
  const EqlTemplateArray({this.values});

  factory EqlTemplateArray.fromJson(Map<String, dynamic> json) =>
      _$EqlTemplateArrayFromJson(json);

  static const toJsonFactory = _$EqlTemplateArrayToJson;
  Map<String, dynamic> toJson() => _$EqlTemplateArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <EqlTemplate>[])
  final List<EqlTemplate>? values;
  static const fromJsonFactory = _$EqlTemplateArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlTemplateArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $EqlTemplateArrayExtension on EqlTemplateArray {
  EqlTemplateArray copyWith({List<EqlTemplate>? values}) {
    return EqlTemplateArray(values: values ?? this.values);
  }

  EqlTemplateArray copyWithWrapped({Wrapped<List<EqlTemplate>?>? values}) {
    return EqlTemplateArray(
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EqlTemplateArrayRes {
  const EqlTemplateArrayRes({
    required this.status,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory EqlTemplateArrayRes.fromJson(Map<String, dynamic> json) =>
      _$EqlTemplateArrayResFromJson(json);

  static const toJsonFactory = _$EqlTemplateArrayResToJson;
  Map<String, dynamic> toJson() => _$EqlTemplateArrayResToJson(this);

  @JsonKey(name: 'status', includeIfNull: false)
  final int status;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <EqlTemplate>[])
  final List<EqlTemplate>? values;
  static const fromJsonFactory = _$EqlTemplateArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlTemplateArrayRes &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality().equals(
                  other.errorCode,
                  errorCode,
                )) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $EqlTemplateArrayResExtension on EqlTemplateArrayRes {
  EqlTemplateArrayRes copyWith({
    int? status,
    String? msg,
    String? trace,
    String? errorCode,
    int? page,
    int? size,
    int? total,
    List<EqlTemplate>? values,
  }) {
    return EqlTemplateArrayRes(
      status: status ?? this.status,
      msg: msg ?? this.msg,
      trace: trace ?? this.trace,
      errorCode: errorCode ?? this.errorCode,
      page: page ?? this.page,
      size: size ?? this.size,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }

  EqlTemplateArrayRes copyWithWrapped({
    Wrapped<int>? status,
    Wrapped<String?>? msg,
    Wrapped<String?>? trace,
    Wrapped<String?>? errorCode,
    Wrapped<int>? page,
    Wrapped<int>? size,
    Wrapped<int>? total,
    Wrapped<List<EqlTemplate>?>? values,
  }) {
    return EqlTemplateArrayRes(
      status: (status != null ? status.value : this.status),
      msg: (msg != null ? msg.value : this.msg),
      trace: (trace != null ? trace.value : this.trace),
      errorCode: (errorCode != null ? errorCode.value : this.errorCode),
      page: (page != null ? page.value : this.page),
      size: (size != null ? size.value : this.size),
      total: (total != null ? total.value : this.total),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EqlExecuteReq {
  const EqlExecuteReq({
    required this.eqlTemplateName,
    required this.index,
    this.mergeContext,
    this.bindingContext,
  });

  factory EqlExecuteReq.fromJson(Map<String, dynamic> json) =>
      _$EqlExecuteReqFromJson(json);

  static const toJsonFactory = _$EqlExecuteReqToJson;
  Map<String, dynamic> toJson() => _$EqlExecuteReqToJson(this);

  @JsonKey(name: 'eqlTemplateName', includeIfNull: false, defaultValue: '')
  final String eqlTemplateName;
  @JsonKey(name: 'index', includeIfNull: false, defaultValue: '')
  final String index;
  @JsonKey(name: 'mergeContext', includeIfNull: false)
  final Object? mergeContext;
  @JsonKey(name: 'bindingContext', includeIfNull: false)
  final Object? bindingContext;
  static const fromJsonFactory = _$EqlExecuteReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlExecuteReq &&
            (identical(other.eqlTemplateName, eqlTemplateName) ||
                const DeepCollectionEquality().equals(
                  other.eqlTemplateName,
                  eqlTemplateName,
                )) &&
            (identical(other.index, index) ||
                const DeepCollectionEquality().equals(other.index, index)) &&
            (identical(other.mergeContext, mergeContext) ||
                const DeepCollectionEquality().equals(
                  other.mergeContext,
                  mergeContext,
                )) &&
            (identical(other.bindingContext, bindingContext) ||
                const DeepCollectionEquality().equals(
                  other.bindingContext,
                  bindingContext,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eqlTemplateName) ^
      const DeepCollectionEquality().hash(index) ^
      const DeepCollectionEquality().hash(mergeContext) ^
      const DeepCollectionEquality().hash(bindingContext) ^
      runtimeType.hashCode;
}

extension $EqlExecuteReqExtension on EqlExecuteReq {
  EqlExecuteReq copyWith({
    String? eqlTemplateName,
    String? index,
    Object? mergeContext,
    Object? bindingContext,
  }) {
    return EqlExecuteReq(
      eqlTemplateName: eqlTemplateName ?? this.eqlTemplateName,
      index: index ?? this.index,
      mergeContext: mergeContext ?? this.mergeContext,
      bindingContext: bindingContext ?? this.bindingContext,
    );
  }

  EqlExecuteReq copyWithWrapped({
    Wrapped<String>? eqlTemplateName,
    Wrapped<String>? index,
    Wrapped<Object?>? mergeContext,
    Wrapped<Object?>? bindingContext,
  }) {
    return EqlExecuteReq(
      eqlTemplateName: (eqlTemplateName != null
          ? eqlTemplateName.value
          : this.eqlTemplateName),
      index: (index != null ? index.value : this.index),
      mergeContext: (mergeContext != null
          ? mergeContext.value
          : this.mergeContext),
      bindingContext: (bindingContext != null
          ? bindingContext.value
          : this.bindingContext),
    );
  }
}

String? baseDomainEntityEntityStateNullableToJson(
  enums.BaseDomainEntityEntityState? baseDomainEntityEntityState,
) {
  return baseDomainEntityEntityState?.value;
}

String? baseDomainEntityEntityStateToJson(
  enums.BaseDomainEntityEntityState baseDomainEntityEntityState,
) {
  return baseDomainEntityEntityState.value;
}

enums.BaseDomainEntityEntityState baseDomainEntityEntityStateFromJson(
  Object? baseDomainEntityEntityState, [
  enums.BaseDomainEntityEntityState? defaultValue,
]) {
  return enums.BaseDomainEntityEntityState.values.firstWhereOrNull(
        (e) => e.value == baseDomainEntityEntityState,
      ) ??
      defaultValue ??
      enums.BaseDomainEntityEntityState.swaggerGeneratedUnknown;
}

enums.BaseDomainEntityEntityState? baseDomainEntityEntityStateNullableFromJson(
  Object? baseDomainEntityEntityState, [
  enums.BaseDomainEntityEntityState? defaultValue,
]) {
  if (baseDomainEntityEntityState == null) {
    return null;
  }
  return enums.BaseDomainEntityEntityState.values.firstWhereOrNull(
        (e) => e.value == baseDomainEntityEntityState,
      ) ??
      defaultValue;
}

String baseDomainEntityEntityStateExplodedListToJson(
  List<enums.BaseDomainEntityEntityState>? baseDomainEntityEntityState,
) {
  return baseDomainEntityEntityState?.map((e) => e.value!).join(',') ?? '';
}

List<String> baseDomainEntityEntityStateListToJson(
  List<enums.BaseDomainEntityEntityState>? baseDomainEntityEntityState,
) {
  if (baseDomainEntityEntityState == null) {
    return [];
  }

  return baseDomainEntityEntityState.map((e) => e.value!).toList();
}

List<enums.BaseDomainEntityEntityState> baseDomainEntityEntityStateListFromJson(
  List? baseDomainEntityEntityState, [
  List<enums.BaseDomainEntityEntityState>? defaultValue,
]) {
  if (baseDomainEntityEntityState == null) {
    return defaultValue ?? [];
  }

  return baseDomainEntityEntityState
      .map((e) => baseDomainEntityEntityStateFromJson(e.toString()))
      .toList();
}

List<enums.BaseDomainEntityEntityState>?
baseDomainEntityEntityStateNullableListFromJson(
  List? baseDomainEntityEntityState, [
  List<enums.BaseDomainEntityEntityState>? defaultValue,
]) {
  if (baseDomainEntityEntityState == null) {
    return defaultValue;
  }

  return baseDomainEntityEntityState
      .map((e) => baseDomainEntityEntityStateFromJson(e.toString()))
      .toList();
}

String? domainEntityStateNullableToJson(
  enums.DomainEntityState? domainEntityState,
) {
  return domainEntityState?.value;
}

String? domainEntityStateToJson(enums.DomainEntityState domainEntityState) {
  return domainEntityState.value;
}

enums.DomainEntityState domainEntityStateFromJson(
  Object? domainEntityState, [
  enums.DomainEntityState? defaultValue,
]) {
  return enums.DomainEntityState.values.firstWhereOrNull(
        (e) => e.value == domainEntityState,
      ) ??
      defaultValue ??
      enums.DomainEntityState.swaggerGeneratedUnknown;
}

enums.DomainEntityState? domainEntityStateNullableFromJson(
  Object? domainEntityState, [
  enums.DomainEntityState? defaultValue,
]) {
  if (domainEntityState == null) {
    return null;
  }
  return enums.DomainEntityState.values.firstWhereOrNull(
        (e) => e.value == domainEntityState,
      ) ??
      defaultValue;
}

String domainEntityStateExplodedListToJson(
  List<enums.DomainEntityState>? domainEntityState,
) {
  return domainEntityState?.map((e) => e.value!).join(',') ?? '';
}

List<String> domainEntityStateListToJson(
  List<enums.DomainEntityState>? domainEntityState,
) {
  if (domainEntityState == null) {
    return [];
  }

  return domainEntityState.map((e) => e.value!).toList();
}

List<enums.DomainEntityState> domainEntityStateListFromJson(
  List? domainEntityState, [
  List<enums.DomainEntityState>? defaultValue,
]) {
  if (domainEntityState == null) {
    return defaultValue ?? [];
  }

  return domainEntityState
      .map((e) => domainEntityStateFromJson(e.toString()))
      .toList();
}

List<enums.DomainEntityState>? domainEntityStateNullableListFromJson(
  List? domainEntityState, [
  List<enums.DomainEntityState>? defaultValue,
]) {
  if (domainEntityState == null) {
    return defaultValue;
  }

  return domainEntityState
      .map((e) => domainEntityStateFromJson(e.toString()))
      .toList();
}

String? rangeFilterFilterNullableToJson(
  enums.RangeFilterFilter? rangeFilterFilter,
) {
  return rangeFilterFilter?.value;
}

String? rangeFilterFilterToJson(enums.RangeFilterFilter rangeFilterFilter) {
  return rangeFilterFilter.value;
}

enums.RangeFilterFilter rangeFilterFilterFromJson(
  Object? rangeFilterFilter, [
  enums.RangeFilterFilter? defaultValue,
]) {
  return enums.RangeFilterFilter.values.firstWhereOrNull(
        (e) => e.value == rangeFilterFilter,
      ) ??
      defaultValue ??
      enums.RangeFilterFilter.swaggerGeneratedUnknown;
}

enums.RangeFilterFilter? rangeFilterFilterNullableFromJson(
  Object? rangeFilterFilter, [
  enums.RangeFilterFilter? defaultValue,
]) {
  if (rangeFilterFilter == null) {
    return null;
  }
  return enums.RangeFilterFilter.values.firstWhereOrNull(
        (e) => e.value == rangeFilterFilter,
      ) ??
      defaultValue;
}

String rangeFilterFilterExplodedListToJson(
  List<enums.RangeFilterFilter>? rangeFilterFilter,
) {
  return rangeFilterFilter?.map((e) => e.value!).join(',') ?? '';
}

List<String> rangeFilterFilterListToJson(
  List<enums.RangeFilterFilter>? rangeFilterFilter,
) {
  if (rangeFilterFilter == null) {
    return [];
  }

  return rangeFilterFilter.map((e) => e.value!).toList();
}

List<enums.RangeFilterFilter> rangeFilterFilterListFromJson(
  List? rangeFilterFilter, [
  List<enums.RangeFilterFilter>? defaultValue,
]) {
  if (rangeFilterFilter == null) {
    return defaultValue ?? [];
  }

  return rangeFilterFilter
      .map((e) => rangeFilterFilterFromJson(e.toString()))
      .toList();
}

List<enums.RangeFilterFilter>? rangeFilterFilterNullableListFromJson(
  List? rangeFilterFilter, [
  List<enums.RangeFilterFilter>? defaultValue,
]) {
  if (rangeFilterFilter == null) {
    return defaultValue;
  }

  return rangeFilterFilter
      .map((e) => rangeFilterFilterFromJson(e.toString()))
      .toList();
}

String? parameterParameterTypeNullableToJson(
  enums.ParameterParameterType? parameterParameterType,
) {
  return parameterParameterType?.value;
}

String? parameterParameterTypeToJson(
  enums.ParameterParameterType parameterParameterType,
) {
  return parameterParameterType.value;
}

enums.ParameterParameterType parameterParameterTypeFromJson(
  Object? parameterParameterType, [
  enums.ParameterParameterType? defaultValue,
]) {
  return enums.ParameterParameterType.values.firstWhereOrNull(
        (e) => e.value == parameterParameterType,
      ) ??
      defaultValue ??
      enums.ParameterParameterType.swaggerGeneratedUnknown;
}

enums.ParameterParameterType? parameterParameterTypeNullableFromJson(
  Object? parameterParameterType, [
  enums.ParameterParameterType? defaultValue,
]) {
  if (parameterParameterType == null) {
    return null;
  }
  return enums.ParameterParameterType.values.firstWhereOrNull(
        (e) => e.value == parameterParameterType,
      ) ??
      defaultValue;
}

String parameterParameterTypeExplodedListToJson(
  List<enums.ParameterParameterType>? parameterParameterType,
) {
  return parameterParameterType?.map((e) => e.value!).join(',') ?? '';
}

List<String> parameterParameterTypeListToJson(
  List<enums.ParameterParameterType>? parameterParameterType,
) {
  if (parameterParameterType == null) {
    return [];
  }

  return parameterParameterType.map((e) => e.value!).toList();
}

List<enums.ParameterParameterType> parameterParameterTypeListFromJson(
  List? parameterParameterType, [
  List<enums.ParameterParameterType>? defaultValue,
]) {
  if (parameterParameterType == null) {
    return defaultValue ?? [];
  }

  return parameterParameterType
      .map((e) => parameterParameterTypeFromJson(e.toString()))
      .toList();
}

List<enums.ParameterParameterType>? parameterParameterTypeNullableListFromJson(
  List? parameterParameterType, [
  List<enums.ParameterParameterType>? defaultValue,
]) {
  if (parameterParameterType == null) {
    return defaultValue;
  }

  return parameterParameterType
      .map((e) => parameterParameterTypeFromJson(e.toString()))
      .toList();
}

String? deviceEntityStateNullableToJson(
  enums.DeviceEntityState? deviceEntityState,
) {
  return deviceEntityState?.value;
}

String? deviceEntityStateToJson(enums.DeviceEntityState deviceEntityState) {
  return deviceEntityState.value;
}

enums.DeviceEntityState deviceEntityStateFromJson(
  Object? deviceEntityState, [
  enums.DeviceEntityState? defaultValue,
]) {
  return enums.DeviceEntityState.values.firstWhereOrNull(
        (e) => e.value == deviceEntityState,
      ) ??
      defaultValue ??
      enums.DeviceEntityState.swaggerGeneratedUnknown;
}

enums.DeviceEntityState? deviceEntityStateNullableFromJson(
  Object? deviceEntityState, [
  enums.DeviceEntityState? defaultValue,
]) {
  if (deviceEntityState == null) {
    return null;
  }
  return enums.DeviceEntityState.values.firstWhereOrNull(
        (e) => e.value == deviceEntityState,
      ) ??
      defaultValue;
}

String deviceEntityStateExplodedListToJson(
  List<enums.DeviceEntityState>? deviceEntityState,
) {
  return deviceEntityState?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceEntityStateListToJson(
  List<enums.DeviceEntityState>? deviceEntityState,
) {
  if (deviceEntityState == null) {
    return [];
  }

  return deviceEntityState.map((e) => e.value!).toList();
}

List<enums.DeviceEntityState> deviceEntityStateListFromJson(
  List? deviceEntityState, [
  List<enums.DeviceEntityState>? defaultValue,
]) {
  if (deviceEntityState == null) {
    return defaultValue ?? [];
  }

  return deviceEntityState
      .map((e) => deviceEntityStateFromJson(e.toString()))
      .toList();
}

List<enums.DeviceEntityState>? deviceEntityStateNullableListFromJson(
  List? deviceEntityState, [
  List<enums.DeviceEntityState>? defaultValue,
]) {
  if (deviceEntityState == null) {
    return defaultValue;
  }

  return deviceEntityState
      .map((e) => deviceEntityStateFromJson(e.toString()))
      .toList();
}

String? conditionInfoConditionNullableToJson(
  enums.ConditionInfoCondition? conditionInfoCondition,
) {
  return conditionInfoCondition?.value;
}

String? conditionInfoConditionToJson(
  enums.ConditionInfoCondition conditionInfoCondition,
) {
  return conditionInfoCondition.value;
}

enums.ConditionInfoCondition conditionInfoConditionFromJson(
  Object? conditionInfoCondition, [
  enums.ConditionInfoCondition? defaultValue,
]) {
  return enums.ConditionInfoCondition.values.firstWhereOrNull(
        (e) => e.value == conditionInfoCondition,
      ) ??
      defaultValue ??
      enums.ConditionInfoCondition.swaggerGeneratedUnknown;
}

enums.ConditionInfoCondition? conditionInfoConditionNullableFromJson(
  Object? conditionInfoCondition, [
  enums.ConditionInfoCondition? defaultValue,
]) {
  if (conditionInfoCondition == null) {
    return null;
  }
  return enums.ConditionInfoCondition.values.firstWhereOrNull(
        (e) => e.value == conditionInfoCondition,
      ) ??
      defaultValue;
}

String conditionInfoConditionExplodedListToJson(
  List<enums.ConditionInfoCondition>? conditionInfoCondition,
) {
  return conditionInfoCondition?.map((e) => e.value!).join(',') ?? '';
}

List<String> conditionInfoConditionListToJson(
  List<enums.ConditionInfoCondition>? conditionInfoCondition,
) {
  if (conditionInfoCondition == null) {
    return [];
  }

  return conditionInfoCondition.map((e) => e.value!).toList();
}

List<enums.ConditionInfoCondition> conditionInfoConditionListFromJson(
  List? conditionInfoCondition, [
  List<enums.ConditionInfoCondition>? defaultValue,
]) {
  if (conditionInfoCondition == null) {
    return defaultValue ?? [];
  }

  return conditionInfoCondition
      .map((e) => conditionInfoConditionFromJson(e.toString()))
      .toList();
}

List<enums.ConditionInfoCondition>? conditionInfoConditionNullableListFromJson(
  List? conditionInfoCondition, [
  List<enums.ConditionInfoCondition>? defaultValue,
]) {
  if (conditionInfoCondition == null) {
    return defaultValue;
  }

  return conditionInfoCondition
      .map((e) => conditionInfoConditionFromJson(e.toString()))
      .toList();
}

String? conditionConditionNullableToJson(
  enums.ConditionCondition? conditionCondition,
) {
  return conditionCondition?.value;
}

String? conditionConditionToJson(enums.ConditionCondition conditionCondition) {
  return conditionCondition.value;
}

enums.ConditionCondition conditionConditionFromJson(
  Object? conditionCondition, [
  enums.ConditionCondition? defaultValue,
]) {
  return enums.ConditionCondition.values.firstWhereOrNull(
        (e) => e.value == conditionCondition,
      ) ??
      defaultValue ??
      enums.ConditionCondition.swaggerGeneratedUnknown;
}

enums.ConditionCondition? conditionConditionNullableFromJson(
  Object? conditionCondition, [
  enums.ConditionCondition? defaultValue,
]) {
  if (conditionCondition == null) {
    return null;
  }
  return enums.ConditionCondition.values.firstWhereOrNull(
        (e) => e.value == conditionCondition,
      ) ??
      defaultValue;
}

String conditionConditionExplodedListToJson(
  List<enums.ConditionCondition>? conditionCondition,
) {
  return conditionCondition?.map((e) => e.value!).join(',') ?? '';
}

List<String> conditionConditionListToJson(
  List<enums.ConditionCondition>? conditionCondition,
) {
  if (conditionCondition == null) {
    return [];
  }

  return conditionCondition.map((e) => e.value!).toList();
}

List<enums.ConditionCondition> conditionConditionListFromJson(
  List? conditionCondition, [
  List<enums.ConditionCondition>? defaultValue,
]) {
  if (conditionCondition == null) {
    return defaultValue ?? [];
  }

  return conditionCondition
      .map((e) => conditionConditionFromJson(e.toString()))
      .toList();
}

List<enums.ConditionCondition>? conditionConditionNullableListFromJson(
  List? conditionCondition, [
  List<enums.ConditionCondition>? defaultValue,
]) {
  if (conditionCondition == null) {
    return defaultValue;
  }

  return conditionCondition
      .map((e) => conditionConditionFromJson(e.toString()))
      .toList();
}

String? matchGroupMatchTypeNullableToJson(
  enums.MatchGroupMatchType? matchGroupMatchType,
) {
  return matchGroupMatchType?.value;
}

String? matchGroupMatchTypeToJson(
  enums.MatchGroupMatchType matchGroupMatchType,
) {
  return matchGroupMatchType.value;
}

enums.MatchGroupMatchType matchGroupMatchTypeFromJson(
  Object? matchGroupMatchType, [
  enums.MatchGroupMatchType? defaultValue,
]) {
  return enums.MatchGroupMatchType.values.firstWhereOrNull(
        (e) => e.value == matchGroupMatchType,
      ) ??
      defaultValue ??
      enums.MatchGroupMatchType.swaggerGeneratedUnknown;
}

enums.MatchGroupMatchType? matchGroupMatchTypeNullableFromJson(
  Object? matchGroupMatchType, [
  enums.MatchGroupMatchType? defaultValue,
]) {
  if (matchGroupMatchType == null) {
    return null;
  }
  return enums.MatchGroupMatchType.values.firstWhereOrNull(
        (e) => e.value == matchGroupMatchType,
      ) ??
      defaultValue;
}

String matchGroupMatchTypeExplodedListToJson(
  List<enums.MatchGroupMatchType>? matchGroupMatchType,
) {
  return matchGroupMatchType?.map((e) => e.value!).join(',') ?? '';
}

List<String> matchGroupMatchTypeListToJson(
  List<enums.MatchGroupMatchType>? matchGroupMatchType,
) {
  if (matchGroupMatchType == null) {
    return [];
  }

  return matchGroupMatchType.map((e) => e.value!).toList();
}

List<enums.MatchGroupMatchType> matchGroupMatchTypeListFromJson(
  List? matchGroupMatchType, [
  List<enums.MatchGroupMatchType>? defaultValue,
]) {
  if (matchGroupMatchType == null) {
    return defaultValue ?? [];
  }

  return matchGroupMatchType
      .map((e) => matchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

List<enums.MatchGroupMatchType>? matchGroupMatchTypeNullableListFromJson(
  List? matchGroupMatchType, [
  List<enums.MatchGroupMatchType>? defaultValue,
]) {
  if (matchGroupMatchType == null) {
    return defaultValue;
  }

  return matchGroupMatchType
      .map((e) => matchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

String? alarmMatchGroupMatchTypeNullableToJson(
  enums.AlarmMatchGroupMatchType? alarmMatchGroupMatchType,
) {
  return alarmMatchGroupMatchType?.value;
}

String? alarmMatchGroupMatchTypeToJson(
  enums.AlarmMatchGroupMatchType alarmMatchGroupMatchType,
) {
  return alarmMatchGroupMatchType.value;
}

enums.AlarmMatchGroupMatchType alarmMatchGroupMatchTypeFromJson(
  Object? alarmMatchGroupMatchType, [
  enums.AlarmMatchGroupMatchType? defaultValue,
]) {
  return enums.AlarmMatchGroupMatchType.values.firstWhereOrNull(
        (e) => e.value == alarmMatchGroupMatchType,
      ) ??
      defaultValue ??
      enums.AlarmMatchGroupMatchType.swaggerGeneratedUnknown;
}

enums.AlarmMatchGroupMatchType? alarmMatchGroupMatchTypeNullableFromJson(
  Object? alarmMatchGroupMatchType, [
  enums.AlarmMatchGroupMatchType? defaultValue,
]) {
  if (alarmMatchGroupMatchType == null) {
    return null;
  }
  return enums.AlarmMatchGroupMatchType.values.firstWhereOrNull(
        (e) => e.value == alarmMatchGroupMatchType,
      ) ??
      defaultValue;
}

String alarmMatchGroupMatchTypeExplodedListToJson(
  List<enums.AlarmMatchGroupMatchType>? alarmMatchGroupMatchType,
) {
  return alarmMatchGroupMatchType?.map((e) => e.value!).join(',') ?? '';
}

List<String> alarmMatchGroupMatchTypeListToJson(
  List<enums.AlarmMatchGroupMatchType>? alarmMatchGroupMatchType,
) {
  if (alarmMatchGroupMatchType == null) {
    return [];
  }

  return alarmMatchGroupMatchType.map((e) => e.value!).toList();
}

List<enums.AlarmMatchGroupMatchType> alarmMatchGroupMatchTypeListFromJson(
  List? alarmMatchGroupMatchType, [
  List<enums.AlarmMatchGroupMatchType>? defaultValue,
]) {
  if (alarmMatchGroupMatchType == null) {
    return defaultValue ?? [];
  }

  return alarmMatchGroupMatchType
      .map((e) => alarmMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

List<enums.AlarmMatchGroupMatchType>?
alarmMatchGroupMatchTypeNullableListFromJson(
  List? alarmMatchGroupMatchType, [
  List<enums.AlarmMatchGroupMatchType>? defaultValue,
]) {
  if (alarmMatchGroupMatchType == null) {
    return defaultValue;
  }

  return alarmMatchGroupMatchType
      .map((e) => alarmMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

String? commandParameterParameterTypeNullableToJson(
  enums.CommandParameterParameterType? commandParameterParameterType,
) {
  return commandParameterParameterType?.value;
}

String? commandParameterParameterTypeToJson(
  enums.CommandParameterParameterType commandParameterParameterType,
) {
  return commandParameterParameterType.value;
}

enums.CommandParameterParameterType commandParameterParameterTypeFromJson(
  Object? commandParameterParameterType, [
  enums.CommandParameterParameterType? defaultValue,
]) {
  return enums.CommandParameterParameterType.values.firstWhereOrNull(
        (e) => e.value == commandParameterParameterType,
      ) ??
      defaultValue ??
      enums.CommandParameterParameterType.swaggerGeneratedUnknown;
}

enums.CommandParameterParameterType?
commandParameterParameterTypeNullableFromJson(
  Object? commandParameterParameterType, [
  enums.CommandParameterParameterType? defaultValue,
]) {
  if (commandParameterParameterType == null) {
    return null;
  }
  return enums.CommandParameterParameterType.values.firstWhereOrNull(
        (e) => e.value == commandParameterParameterType,
      ) ??
      defaultValue;
}

String commandParameterParameterTypeExplodedListToJson(
  List<enums.CommandParameterParameterType>? commandParameterParameterType,
) {
  return commandParameterParameterType?.map((e) => e.value!).join(',') ?? '';
}

List<String> commandParameterParameterTypeListToJson(
  List<enums.CommandParameterParameterType>? commandParameterParameterType,
) {
  if (commandParameterParameterType == null) {
    return [];
  }

  return commandParameterParameterType.map((e) => e.value!).toList();
}

List<enums.CommandParameterParameterType>
commandParameterParameterTypeListFromJson(
  List? commandParameterParameterType, [
  List<enums.CommandParameterParameterType>? defaultValue,
]) {
  if (commandParameterParameterType == null) {
    return defaultValue ?? [];
  }

  return commandParameterParameterType
      .map((e) => commandParameterParameterTypeFromJson(e.toString()))
      .toList();
}

List<enums.CommandParameterParameterType>?
commandParameterParameterTypeNullableListFromJson(
  List? commandParameterParameterType, [
  List<enums.CommandParameterParameterType>? defaultValue,
]) {
  if (commandParameterParameterType == null) {
    return defaultValue;
  }

  return commandParameterParameterType
      .map((e) => commandParameterParameterTypeFromJson(e.toString()))
      .toList();
}

String? controlCommandTypeNullableToJson(
  enums.ControlCommandType? controlCommandType,
) {
  return controlCommandType?.value;
}

String? controlCommandTypeToJson(enums.ControlCommandType controlCommandType) {
  return controlCommandType.value;
}

enums.ControlCommandType controlCommandTypeFromJson(
  Object? controlCommandType, [
  enums.ControlCommandType? defaultValue,
]) {
  return enums.ControlCommandType.values.firstWhereOrNull(
        (e) => e.value == controlCommandType,
      ) ??
      defaultValue ??
      enums.ControlCommandType.swaggerGeneratedUnknown;
}

enums.ControlCommandType? controlCommandTypeNullableFromJson(
  Object? controlCommandType, [
  enums.ControlCommandType? defaultValue,
]) {
  if (controlCommandType == null) {
    return null;
  }
  return enums.ControlCommandType.values.firstWhereOrNull(
        (e) => e.value == controlCommandType,
      ) ??
      defaultValue;
}

String controlCommandTypeExplodedListToJson(
  List<enums.ControlCommandType>? controlCommandType,
) {
  return controlCommandType?.map((e) => e.value!).join(',') ?? '';
}

List<String> controlCommandTypeListToJson(
  List<enums.ControlCommandType>? controlCommandType,
) {
  if (controlCommandType == null) {
    return [];
  }

  return controlCommandType.map((e) => e.value!).toList();
}

List<enums.ControlCommandType> controlCommandTypeListFromJson(
  List? controlCommandType, [
  List<enums.ControlCommandType>? defaultValue,
]) {
  if (controlCommandType == null) {
    return defaultValue ?? [];
  }

  return controlCommandType
      .map((e) => controlCommandTypeFromJson(e.toString()))
      .toList();
}

List<enums.ControlCommandType>? controlCommandTypeNullableListFromJson(
  List? controlCommandType, [
  List<enums.ControlCommandType>? defaultValue,
]) {
  if (controlCommandType == null) {
    return defaultValue;
  }

  return controlCommandType
      .map((e) => controlCommandTypeFromJson(e.toString()))
      .toList();
}

String? controlCommandCommandTypeNullableToJson(
  enums.ControlCommandCommandType? controlCommandCommandType,
) {
  return controlCommandCommandType?.value;
}

String? controlCommandCommandTypeToJson(
  enums.ControlCommandCommandType controlCommandCommandType,
) {
  return controlCommandCommandType.value;
}

enums.ControlCommandCommandType controlCommandCommandTypeFromJson(
  Object? controlCommandCommandType, [
  enums.ControlCommandCommandType? defaultValue,
]) {
  return enums.ControlCommandCommandType.values.firstWhereOrNull(
        (e) => e.value == controlCommandCommandType,
      ) ??
      defaultValue ??
      enums.ControlCommandCommandType.swaggerGeneratedUnknown;
}

enums.ControlCommandCommandType? controlCommandCommandTypeNullableFromJson(
  Object? controlCommandCommandType, [
  enums.ControlCommandCommandType? defaultValue,
]) {
  if (controlCommandCommandType == null) {
    return null;
  }
  return enums.ControlCommandCommandType.values.firstWhereOrNull(
        (e) => e.value == controlCommandCommandType,
      ) ??
      defaultValue;
}

String controlCommandCommandTypeExplodedListToJson(
  List<enums.ControlCommandCommandType>? controlCommandCommandType,
) {
  return controlCommandCommandType?.map((e) => e.value!).join(',') ?? '';
}

List<String> controlCommandCommandTypeListToJson(
  List<enums.ControlCommandCommandType>? controlCommandCommandType,
) {
  if (controlCommandCommandType == null) {
    return [];
  }

  return controlCommandCommandType.map((e) => e.value!).toList();
}

List<enums.ControlCommandCommandType> controlCommandCommandTypeListFromJson(
  List? controlCommandCommandType, [
  List<enums.ControlCommandCommandType>? defaultValue,
]) {
  if (controlCommandCommandType == null) {
    return defaultValue ?? [];
  }

  return controlCommandCommandType
      .map((e) => controlCommandCommandTypeFromJson(e.toString()))
      .toList();
}

List<enums.ControlCommandCommandType>?
controlCommandCommandTypeNullableListFromJson(
  List? controlCommandCommandType, [
  List<enums.ControlCommandCommandType>? defaultValue,
]) {
  if (controlCommandCommandType == null) {
    return defaultValue;
  }

  return controlCommandCommandType
      .map((e) => controlCommandCommandTypeFromJson(e.toString()))
      .toList();
}

String? controlTargetHttpProtocolNullableToJson(
  enums.ControlTargetHttpProtocol? controlTargetHttpProtocol,
) {
  return controlTargetHttpProtocol?.value;
}

String? controlTargetHttpProtocolToJson(
  enums.ControlTargetHttpProtocol controlTargetHttpProtocol,
) {
  return controlTargetHttpProtocol.value;
}

enums.ControlTargetHttpProtocol controlTargetHttpProtocolFromJson(
  Object? controlTargetHttpProtocol, [
  enums.ControlTargetHttpProtocol? defaultValue,
]) {
  return enums.ControlTargetHttpProtocol.values.firstWhereOrNull(
        (e) => e.value == controlTargetHttpProtocol,
      ) ??
      defaultValue ??
      enums.ControlTargetHttpProtocol.swaggerGeneratedUnknown;
}

enums.ControlTargetHttpProtocol? controlTargetHttpProtocolNullableFromJson(
  Object? controlTargetHttpProtocol, [
  enums.ControlTargetHttpProtocol? defaultValue,
]) {
  if (controlTargetHttpProtocol == null) {
    return null;
  }
  return enums.ControlTargetHttpProtocol.values.firstWhereOrNull(
        (e) => e.value == controlTargetHttpProtocol,
      ) ??
      defaultValue;
}

String controlTargetHttpProtocolExplodedListToJson(
  List<enums.ControlTargetHttpProtocol>? controlTargetHttpProtocol,
) {
  return controlTargetHttpProtocol?.map((e) => e.value!).join(',') ?? '';
}

List<String> controlTargetHttpProtocolListToJson(
  List<enums.ControlTargetHttpProtocol>? controlTargetHttpProtocol,
) {
  if (controlTargetHttpProtocol == null) {
    return [];
  }

  return controlTargetHttpProtocol.map((e) => e.value!).toList();
}

List<enums.ControlTargetHttpProtocol> controlTargetHttpProtocolListFromJson(
  List? controlTargetHttpProtocol, [
  List<enums.ControlTargetHttpProtocol>? defaultValue,
]) {
  if (controlTargetHttpProtocol == null) {
    return defaultValue ?? [];
  }

  return controlTargetHttpProtocol
      .map((e) => controlTargetHttpProtocolFromJson(e.toString()))
      .toList();
}

List<enums.ControlTargetHttpProtocol>?
controlTargetHttpProtocolNullableListFromJson(
  List? controlTargetHttpProtocol, [
  List<enums.ControlTargetHttpProtocol>? defaultValue,
]) {
  if (controlTargetHttpProtocol == null) {
    return defaultValue;
  }

  return controlTargetHttpProtocol
      .map((e) => controlTargetHttpProtocolFromJson(e.toString()))
      .toList();
}

String? controlInfoTargetNullableToJson(
  enums.ControlInfoTarget? controlInfoTarget,
) {
  return controlInfoTarget?.value;
}

String? controlInfoTargetToJson(enums.ControlInfoTarget controlInfoTarget) {
  return controlInfoTarget.value;
}

enums.ControlInfoTarget controlInfoTargetFromJson(
  Object? controlInfoTarget, [
  enums.ControlInfoTarget? defaultValue,
]) {
  return enums.ControlInfoTarget.values.firstWhereOrNull(
        (e) => e.value == controlInfoTarget,
      ) ??
      defaultValue ??
      enums.ControlInfoTarget.swaggerGeneratedUnknown;
}

enums.ControlInfoTarget? controlInfoTargetNullableFromJson(
  Object? controlInfoTarget, [
  enums.ControlInfoTarget? defaultValue,
]) {
  if (controlInfoTarget == null) {
    return null;
  }
  return enums.ControlInfoTarget.values.firstWhereOrNull(
        (e) => e.value == controlInfoTarget,
      ) ??
      defaultValue;
}

String controlInfoTargetExplodedListToJson(
  List<enums.ControlInfoTarget>? controlInfoTarget,
) {
  return controlInfoTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> controlInfoTargetListToJson(
  List<enums.ControlInfoTarget>? controlInfoTarget,
) {
  if (controlInfoTarget == null) {
    return [];
  }

  return controlInfoTarget.map((e) => e.value!).toList();
}

List<enums.ControlInfoTarget> controlInfoTargetListFromJson(
  List? controlInfoTarget, [
  List<enums.ControlInfoTarget>? defaultValue,
]) {
  if (controlInfoTarget == null) {
    return defaultValue ?? [];
  }

  return controlInfoTarget
      .map((e) => controlInfoTargetFromJson(e.toString()))
      .toList();
}

List<enums.ControlInfoTarget>? controlInfoTargetNullableListFromJson(
  List? controlInfoTarget, [
  List<enums.ControlInfoTarget>? defaultValue,
]) {
  if (controlInfoTarget == null) {
    return defaultValue;
  }

  return controlInfoTarget
      .map((e) => controlInfoTargetFromJson(e.toString()))
      .toList();
}

String? controlTargetNullableToJson(enums.ControlTarget? controlTarget) {
  return controlTarget?.value;
}

String? controlTargetToJson(enums.ControlTarget controlTarget) {
  return controlTarget.value;
}

enums.ControlTarget controlTargetFromJson(
  Object? controlTarget, [
  enums.ControlTarget? defaultValue,
]) {
  return enums.ControlTarget.values.firstWhereOrNull(
        (e) => e.value == controlTarget,
      ) ??
      defaultValue ??
      enums.ControlTarget.swaggerGeneratedUnknown;
}

enums.ControlTarget? controlTargetNullableFromJson(
  Object? controlTarget, [
  enums.ControlTarget? defaultValue,
]) {
  if (controlTarget == null) {
    return null;
  }
  return enums.ControlTarget.values.firstWhereOrNull(
        (e) => e.value == controlTarget,
      ) ??
      defaultValue;
}

String controlTargetExplodedListToJson(
  List<enums.ControlTarget>? controlTarget,
) {
  return controlTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> controlTargetListToJson(List<enums.ControlTarget>? controlTarget) {
  if (controlTarget == null) {
    return [];
  }

  return controlTarget.map((e) => e.value!).toList();
}

List<enums.ControlTarget> controlTargetListFromJson(
  List? controlTarget, [
  List<enums.ControlTarget>? defaultValue,
]) {
  if (controlTarget == null) {
    return defaultValue ?? [];
  }

  return controlTarget.map((e) => controlTargetFromJson(e.toString())).toList();
}

List<enums.ControlTarget>? controlTargetNullableListFromJson(
  List? controlTarget, [
  List<enums.ControlTarget>? defaultValue,
]) {
  if (controlTarget == null) {
    return defaultValue;
  }

  return controlTarget.map((e) => controlTargetFromJson(e.toString())).toList();
}

String? eventInfoSourceTypeNullableToJson(
  enums.EventInfoSourceType? eventInfoSourceType,
) {
  return eventInfoSourceType?.value;
}

String? eventInfoSourceTypeToJson(
  enums.EventInfoSourceType eventInfoSourceType,
) {
  return eventInfoSourceType.value;
}

enums.EventInfoSourceType eventInfoSourceTypeFromJson(
  Object? eventInfoSourceType, [
  enums.EventInfoSourceType? defaultValue,
]) {
  return enums.EventInfoSourceType.values.firstWhereOrNull(
        (e) => e.value == eventInfoSourceType,
      ) ??
      defaultValue ??
      enums.EventInfoSourceType.swaggerGeneratedUnknown;
}

enums.EventInfoSourceType? eventInfoSourceTypeNullableFromJson(
  Object? eventInfoSourceType, [
  enums.EventInfoSourceType? defaultValue,
]) {
  if (eventInfoSourceType == null) {
    return null;
  }
  return enums.EventInfoSourceType.values.firstWhereOrNull(
        (e) => e.value == eventInfoSourceType,
      ) ??
      defaultValue;
}

String eventInfoSourceTypeExplodedListToJson(
  List<enums.EventInfoSourceType>? eventInfoSourceType,
) {
  return eventInfoSourceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventInfoSourceTypeListToJson(
  List<enums.EventInfoSourceType>? eventInfoSourceType,
) {
  if (eventInfoSourceType == null) {
    return [];
  }

  return eventInfoSourceType.map((e) => e.value!).toList();
}

List<enums.EventInfoSourceType> eventInfoSourceTypeListFromJson(
  List? eventInfoSourceType, [
  List<enums.EventInfoSourceType>? defaultValue,
]) {
  if (eventInfoSourceType == null) {
    return defaultValue ?? [];
  }

  return eventInfoSourceType
      .map((e) => eventInfoSourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.EventInfoSourceType>? eventInfoSourceTypeNullableListFromJson(
  List? eventInfoSourceType, [
  List<enums.EventInfoSourceType>? defaultValue,
]) {
  if (eventInfoSourceType == null) {
    return defaultValue;
  }

  return eventInfoSourceType
      .map((e) => eventInfoSourceTypeFromJson(e.toString()))
      .toList();
}

String? eventSourceTypeNullableToJson(enums.EventSourceType? eventSourceType) {
  return eventSourceType?.value;
}

String? eventSourceTypeToJson(enums.EventSourceType eventSourceType) {
  return eventSourceType.value;
}

enums.EventSourceType eventSourceTypeFromJson(
  Object? eventSourceType, [
  enums.EventSourceType? defaultValue,
]) {
  return enums.EventSourceType.values.firstWhereOrNull(
        (e) => e.value == eventSourceType,
      ) ??
      defaultValue ??
      enums.EventSourceType.swaggerGeneratedUnknown;
}

enums.EventSourceType? eventSourceTypeNullableFromJson(
  Object? eventSourceType, [
  enums.EventSourceType? defaultValue,
]) {
  if (eventSourceType == null) {
    return null;
  }
  return enums.EventSourceType.values.firstWhereOrNull(
        (e) => e.value == eventSourceType,
      ) ??
      defaultValue;
}

String eventSourceTypeExplodedListToJson(
  List<enums.EventSourceType>? eventSourceType,
) {
  return eventSourceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventSourceTypeListToJson(
  List<enums.EventSourceType>? eventSourceType,
) {
  if (eventSourceType == null) {
    return [];
  }

  return eventSourceType.map((e) => e.value!).toList();
}

List<enums.EventSourceType> eventSourceTypeListFromJson(
  List? eventSourceType, [
  List<enums.EventSourceType>? defaultValue,
]) {
  if (eventSourceType == null) {
    return defaultValue ?? [];
  }

  return eventSourceType
      .map((e) => eventSourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.EventSourceType>? eventSourceTypeNullableListFromJson(
  List? eventSourceType, [
  List<enums.EventSourceType>? defaultValue,
]) {
  if (eventSourceType == null) {
    return defaultValue;
  }

  return eventSourceType
      .map((e) => eventSourceTypeFromJson(e.toString()))
      .toList();
}

String? httpConfigProtocolNullableToJson(
  enums.HttpConfigProtocol? httpConfigProtocol,
) {
  return httpConfigProtocol?.value;
}

String? httpConfigProtocolToJson(enums.HttpConfigProtocol httpConfigProtocol) {
  return httpConfigProtocol.value;
}

enums.HttpConfigProtocol httpConfigProtocolFromJson(
  Object? httpConfigProtocol, [
  enums.HttpConfigProtocol? defaultValue,
]) {
  return enums.HttpConfigProtocol.values.firstWhereOrNull(
        (e) => e.value == httpConfigProtocol,
      ) ??
      defaultValue ??
      enums.HttpConfigProtocol.swaggerGeneratedUnknown;
}

enums.HttpConfigProtocol? httpConfigProtocolNullableFromJson(
  Object? httpConfigProtocol, [
  enums.HttpConfigProtocol? defaultValue,
]) {
  if (httpConfigProtocol == null) {
    return null;
  }
  return enums.HttpConfigProtocol.values.firstWhereOrNull(
        (e) => e.value == httpConfigProtocol,
      ) ??
      defaultValue;
}

String httpConfigProtocolExplodedListToJson(
  List<enums.HttpConfigProtocol>? httpConfigProtocol,
) {
  return httpConfigProtocol?.map((e) => e.value!).join(',') ?? '';
}

List<String> httpConfigProtocolListToJson(
  List<enums.HttpConfigProtocol>? httpConfigProtocol,
) {
  if (httpConfigProtocol == null) {
    return [];
  }

  return httpConfigProtocol.map((e) => e.value!).toList();
}

List<enums.HttpConfigProtocol> httpConfigProtocolListFromJson(
  List? httpConfigProtocol, [
  List<enums.HttpConfigProtocol>? defaultValue,
]) {
  if (httpConfigProtocol == null) {
    return defaultValue ?? [];
  }

  return httpConfigProtocol
      .map((e) => httpConfigProtocolFromJson(e.toString()))
      .toList();
}

List<enums.HttpConfigProtocol>? httpConfigProtocolNullableListFromJson(
  List? httpConfigProtocol, [
  List<enums.HttpConfigProtocol>? defaultValue,
]) {
  if (httpConfigProtocol == null) {
    return defaultValue;
  }

  return httpConfigProtocol
      .map((e) => httpConfigProtocolFromJson(e.toString()))
      .toList();
}

String? triggerControlTriggerTargetNullableToJson(
  enums.TriggerControlTriggerTarget? triggerControlTriggerTarget,
) {
  return triggerControlTriggerTarget?.value;
}

String? triggerControlTriggerTargetToJson(
  enums.TriggerControlTriggerTarget triggerControlTriggerTarget,
) {
  return triggerControlTriggerTarget.value;
}

enums.TriggerControlTriggerTarget triggerControlTriggerTargetFromJson(
  Object? triggerControlTriggerTarget, [
  enums.TriggerControlTriggerTarget? defaultValue,
]) {
  return enums.TriggerControlTriggerTarget.values.firstWhereOrNull(
        (e) => e.value == triggerControlTriggerTarget,
      ) ??
      defaultValue ??
      enums.TriggerControlTriggerTarget.swaggerGeneratedUnknown;
}

enums.TriggerControlTriggerTarget? triggerControlTriggerTargetNullableFromJson(
  Object? triggerControlTriggerTarget, [
  enums.TriggerControlTriggerTarget? defaultValue,
]) {
  if (triggerControlTriggerTarget == null) {
    return null;
  }
  return enums.TriggerControlTriggerTarget.values.firstWhereOrNull(
        (e) => e.value == triggerControlTriggerTarget,
      ) ??
      defaultValue;
}

String triggerControlTriggerTargetExplodedListToJson(
  List<enums.TriggerControlTriggerTarget>? triggerControlTriggerTarget,
) {
  return triggerControlTriggerTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggerControlTriggerTargetListToJson(
  List<enums.TriggerControlTriggerTarget>? triggerControlTriggerTarget,
) {
  if (triggerControlTriggerTarget == null) {
    return [];
  }

  return triggerControlTriggerTarget.map((e) => e.value!).toList();
}

List<enums.TriggerControlTriggerTarget> triggerControlTriggerTargetListFromJson(
  List? triggerControlTriggerTarget, [
  List<enums.TriggerControlTriggerTarget>? defaultValue,
]) {
  if (triggerControlTriggerTarget == null) {
    return defaultValue ?? [];
  }

  return triggerControlTriggerTarget
      .map((e) => triggerControlTriggerTargetFromJson(e.toString()))
      .toList();
}

List<enums.TriggerControlTriggerTarget>?
triggerControlTriggerTargetNullableListFromJson(
  List? triggerControlTriggerTarget, [
  List<enums.TriggerControlTriggerTarget>? defaultValue,
]) {
  if (triggerControlTriggerTarget == null) {
    return defaultValue;
  }

  return triggerControlTriggerTarget
      .map((e) => triggerControlTriggerTargetFromJson(e.toString()))
      .toList();
}

String? triggerControlTriggerTypeNullableToJson(
  enums.TriggerControlTriggerType? triggerControlTriggerType,
) {
  return triggerControlTriggerType?.value;
}

String? triggerControlTriggerTypeToJson(
  enums.TriggerControlTriggerType triggerControlTriggerType,
) {
  return triggerControlTriggerType.value;
}

enums.TriggerControlTriggerType triggerControlTriggerTypeFromJson(
  Object? triggerControlTriggerType, [
  enums.TriggerControlTriggerType? defaultValue,
]) {
  return enums.TriggerControlTriggerType.values.firstWhereOrNull(
        (e) => e.value == triggerControlTriggerType,
      ) ??
      defaultValue ??
      enums.TriggerControlTriggerType.swaggerGeneratedUnknown;
}

enums.TriggerControlTriggerType? triggerControlTriggerTypeNullableFromJson(
  Object? triggerControlTriggerType, [
  enums.TriggerControlTriggerType? defaultValue,
]) {
  if (triggerControlTriggerType == null) {
    return null;
  }
  return enums.TriggerControlTriggerType.values.firstWhereOrNull(
        (e) => e.value == triggerControlTriggerType,
      ) ??
      defaultValue;
}

String triggerControlTriggerTypeExplodedListToJson(
  List<enums.TriggerControlTriggerType>? triggerControlTriggerType,
) {
  return triggerControlTriggerType?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggerControlTriggerTypeListToJson(
  List<enums.TriggerControlTriggerType>? triggerControlTriggerType,
) {
  if (triggerControlTriggerType == null) {
    return [];
  }

  return triggerControlTriggerType.map((e) => e.value!).toList();
}

List<enums.TriggerControlTriggerType> triggerControlTriggerTypeListFromJson(
  List? triggerControlTriggerType, [
  List<enums.TriggerControlTriggerType>? defaultValue,
]) {
  if (triggerControlTriggerType == null) {
    return defaultValue ?? [];
  }

  return triggerControlTriggerType
      .map((e) => triggerControlTriggerTypeFromJson(e.toString()))
      .toList();
}

List<enums.TriggerControlTriggerType>?
triggerControlTriggerTypeNullableListFromJson(
  List? triggerControlTriggerType, [
  List<enums.TriggerControlTriggerType>? defaultValue,
]) {
  if (triggerControlTriggerType == null) {
    return defaultValue;
  }

  return triggerControlTriggerType
      .map((e) => triggerControlTriggerTypeFromJson(e.toString()))
      .toList();
}

String? triggerControlDeliveryTargetNullableToJson(
  enums.TriggerControlDeliveryTarget? triggerControlDeliveryTarget,
) {
  return triggerControlDeliveryTarget?.value;
}

String? triggerControlDeliveryTargetToJson(
  enums.TriggerControlDeliveryTarget triggerControlDeliveryTarget,
) {
  return triggerControlDeliveryTarget.value;
}

enums.TriggerControlDeliveryTarget triggerControlDeliveryTargetFromJson(
  Object? triggerControlDeliveryTarget, [
  enums.TriggerControlDeliveryTarget? defaultValue,
]) {
  return enums.TriggerControlDeliveryTarget.values.firstWhereOrNull(
        (e) => e.value == triggerControlDeliveryTarget,
      ) ??
      defaultValue ??
      enums.TriggerControlDeliveryTarget.swaggerGeneratedUnknown;
}

enums.TriggerControlDeliveryTarget?
triggerControlDeliveryTargetNullableFromJson(
  Object? triggerControlDeliveryTarget, [
  enums.TriggerControlDeliveryTarget? defaultValue,
]) {
  if (triggerControlDeliveryTarget == null) {
    return null;
  }
  return enums.TriggerControlDeliveryTarget.values.firstWhereOrNull(
        (e) => e.value == triggerControlDeliveryTarget,
      ) ??
      defaultValue;
}

String triggerControlDeliveryTargetExplodedListToJson(
  List<enums.TriggerControlDeliveryTarget>? triggerControlDeliveryTarget,
) {
  return triggerControlDeliveryTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggerControlDeliveryTargetListToJson(
  List<enums.TriggerControlDeliveryTarget>? triggerControlDeliveryTarget,
) {
  if (triggerControlDeliveryTarget == null) {
    return [];
  }

  return triggerControlDeliveryTarget.map((e) => e.value!).toList();
}

List<enums.TriggerControlDeliveryTarget>
triggerControlDeliveryTargetListFromJson(
  List? triggerControlDeliveryTarget, [
  List<enums.TriggerControlDeliveryTarget>? defaultValue,
]) {
  if (triggerControlDeliveryTarget == null) {
    return defaultValue ?? [];
  }

  return triggerControlDeliveryTarget
      .map((e) => triggerControlDeliveryTargetFromJson(e.toString()))
      .toList();
}

List<enums.TriggerControlDeliveryTarget>?
triggerControlDeliveryTargetNullableListFromJson(
  List? triggerControlDeliveryTarget, [
  List<enums.TriggerControlDeliveryTarget>? defaultValue,
]) {
  if (triggerControlDeliveryTarget == null) {
    return defaultValue;
  }

  return triggerControlDeliveryTarget
      .map((e) => triggerControlDeliveryTargetFromJson(e.toString()))
      .toList();
}

String? displayMatchGroupMatchTypeNullableToJson(
  enums.DisplayMatchGroupMatchType? displayMatchGroupMatchType,
) {
  return displayMatchGroupMatchType?.value;
}

String? displayMatchGroupMatchTypeToJson(
  enums.DisplayMatchGroupMatchType displayMatchGroupMatchType,
) {
  return displayMatchGroupMatchType.value;
}

enums.DisplayMatchGroupMatchType displayMatchGroupMatchTypeFromJson(
  Object? displayMatchGroupMatchType, [
  enums.DisplayMatchGroupMatchType? defaultValue,
]) {
  return enums.DisplayMatchGroupMatchType.values.firstWhereOrNull(
        (e) => e.value == displayMatchGroupMatchType,
      ) ??
      defaultValue ??
      enums.DisplayMatchGroupMatchType.swaggerGeneratedUnknown;
}

enums.DisplayMatchGroupMatchType? displayMatchGroupMatchTypeNullableFromJson(
  Object? displayMatchGroupMatchType, [
  enums.DisplayMatchGroupMatchType? defaultValue,
]) {
  if (displayMatchGroupMatchType == null) {
    return null;
  }
  return enums.DisplayMatchGroupMatchType.values.firstWhereOrNull(
        (e) => e.value == displayMatchGroupMatchType,
      ) ??
      defaultValue;
}

String displayMatchGroupMatchTypeExplodedListToJson(
  List<enums.DisplayMatchGroupMatchType>? displayMatchGroupMatchType,
) {
  return displayMatchGroupMatchType?.map((e) => e.value!).join(',') ?? '';
}

List<String> displayMatchGroupMatchTypeListToJson(
  List<enums.DisplayMatchGroupMatchType>? displayMatchGroupMatchType,
) {
  if (displayMatchGroupMatchType == null) {
    return [];
  }

  return displayMatchGroupMatchType.map((e) => e.value!).toList();
}

List<enums.DisplayMatchGroupMatchType> displayMatchGroupMatchTypeListFromJson(
  List? displayMatchGroupMatchType, [
  List<enums.DisplayMatchGroupMatchType>? defaultValue,
]) {
  if (displayMatchGroupMatchType == null) {
    return defaultValue ?? [];
  }

  return displayMatchGroupMatchType
      .map((e) => displayMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

List<enums.DisplayMatchGroupMatchType>?
displayMatchGroupMatchTypeNullableListFromJson(
  List? displayMatchGroupMatchType, [
  List<enums.DisplayMatchGroupMatchType>? defaultValue,
]) {
  if (displayMatchGroupMatchType == null) {
    return defaultValue;
  }

  return displayMatchGroupMatchType
      .map((e) => displayMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

String? displayMatchGroupBorderTypeNullableToJson(
  enums.DisplayMatchGroupBorderType? displayMatchGroupBorderType,
) {
  return displayMatchGroupBorderType?.value;
}

String? displayMatchGroupBorderTypeToJson(
  enums.DisplayMatchGroupBorderType displayMatchGroupBorderType,
) {
  return displayMatchGroupBorderType.value;
}

enums.DisplayMatchGroupBorderType displayMatchGroupBorderTypeFromJson(
  Object? displayMatchGroupBorderType, [
  enums.DisplayMatchGroupBorderType? defaultValue,
]) {
  return enums.DisplayMatchGroupBorderType.values.firstWhereOrNull(
        (e) => e.value == displayMatchGroupBorderType,
      ) ??
      defaultValue ??
      enums.DisplayMatchGroupBorderType.swaggerGeneratedUnknown;
}

enums.DisplayMatchGroupBorderType? displayMatchGroupBorderTypeNullableFromJson(
  Object? displayMatchGroupBorderType, [
  enums.DisplayMatchGroupBorderType? defaultValue,
]) {
  if (displayMatchGroupBorderType == null) {
    return null;
  }
  return enums.DisplayMatchGroupBorderType.values.firstWhereOrNull(
        (e) => e.value == displayMatchGroupBorderType,
      ) ??
      defaultValue;
}

String displayMatchGroupBorderTypeExplodedListToJson(
  List<enums.DisplayMatchGroupBorderType>? displayMatchGroupBorderType,
) {
  return displayMatchGroupBorderType?.map((e) => e.value!).join(',') ?? '';
}

List<String> displayMatchGroupBorderTypeListToJson(
  List<enums.DisplayMatchGroupBorderType>? displayMatchGroupBorderType,
) {
  if (displayMatchGroupBorderType == null) {
    return [];
  }

  return displayMatchGroupBorderType.map((e) => e.value!).toList();
}

List<enums.DisplayMatchGroupBorderType> displayMatchGroupBorderTypeListFromJson(
  List? displayMatchGroupBorderType, [
  List<enums.DisplayMatchGroupBorderType>? defaultValue,
]) {
  if (displayMatchGroupBorderType == null) {
    return defaultValue ?? [];
  }

  return displayMatchGroupBorderType
      .map((e) => displayMatchGroupBorderTypeFromJson(e.toString()))
      .toList();
}

List<enums.DisplayMatchGroupBorderType>?
displayMatchGroupBorderTypeNullableListFromJson(
  List? displayMatchGroupBorderType, [
  List<enums.DisplayMatchGroupBorderType>? defaultValue,
]) {
  if (displayMatchGroupBorderType == null) {
    return defaultValue;
  }

  return displayMatchGroupBorderType
      .map((e) => displayMatchGroupBorderTypeFromJson(e.toString()))
      .toList();
}

String? displayableTypeNullableToJson(enums.DisplayableType? displayableType) {
  return displayableType?.value;
}

String? displayableTypeToJson(enums.DisplayableType displayableType) {
  return displayableType.value;
}

enums.DisplayableType displayableTypeFromJson(
  Object? displayableType, [
  enums.DisplayableType? defaultValue,
]) {
  return enums.DisplayableType.values.firstWhereOrNull(
        (e) => e.value == displayableType,
      ) ??
      defaultValue ??
      enums.DisplayableType.swaggerGeneratedUnknown;
}

enums.DisplayableType? displayableTypeNullableFromJson(
  Object? displayableType, [
  enums.DisplayableType? defaultValue,
]) {
  if (displayableType == null) {
    return null;
  }
  return enums.DisplayableType.values.firstWhereOrNull(
        (e) => e.value == displayableType,
      ) ??
      defaultValue;
}

String displayableTypeExplodedListToJson(
  List<enums.DisplayableType>? displayableType,
) {
  return displayableType?.map((e) => e.value!).join(',') ?? '';
}

List<String> displayableTypeListToJson(
  List<enums.DisplayableType>? displayableType,
) {
  if (displayableType == null) {
    return [];
  }

  return displayableType.map((e) => e.value!).toList();
}

List<enums.DisplayableType> displayableTypeListFromJson(
  List? displayableType, [
  List<enums.DisplayableType>? defaultValue,
]) {
  if (displayableType == null) {
    return defaultValue ?? [];
  }

  return displayableType
      .map((e) => displayableTypeFromJson(e.toString()))
      .toList();
}

List<enums.DisplayableType>? displayableTypeNullableListFromJson(
  List? displayableType, [
  List<enums.DisplayableType>? defaultValue,
]) {
  if (displayableType == null) {
    return defaultValue;
  }

  return displayableType
      .map((e) => displayableTypeFromJson(e.toString()))
      .toList();
}

String? deviceViewInfoInfoPositionNullableToJson(
  enums.DeviceViewInfoInfoPosition? deviceViewInfoInfoPosition,
) {
  return deviceViewInfoInfoPosition?.value;
}

String? deviceViewInfoInfoPositionToJson(
  enums.DeviceViewInfoInfoPosition deviceViewInfoInfoPosition,
) {
  return deviceViewInfoInfoPosition.value;
}

enums.DeviceViewInfoInfoPosition deviceViewInfoInfoPositionFromJson(
  Object? deviceViewInfoInfoPosition, [
  enums.DeviceViewInfoInfoPosition? defaultValue,
]) {
  return enums.DeviceViewInfoInfoPosition.values.firstWhereOrNull(
        (e) => e.value == deviceViewInfoInfoPosition,
      ) ??
      defaultValue ??
      enums.DeviceViewInfoInfoPosition.swaggerGeneratedUnknown;
}

enums.DeviceViewInfoInfoPosition? deviceViewInfoInfoPositionNullableFromJson(
  Object? deviceViewInfoInfoPosition, [
  enums.DeviceViewInfoInfoPosition? defaultValue,
]) {
  if (deviceViewInfoInfoPosition == null) {
    return null;
  }
  return enums.DeviceViewInfoInfoPosition.values.firstWhereOrNull(
        (e) => e.value == deviceViewInfoInfoPosition,
      ) ??
      defaultValue;
}

String deviceViewInfoInfoPositionExplodedListToJson(
  List<enums.DeviceViewInfoInfoPosition>? deviceViewInfoInfoPosition,
) {
  return deviceViewInfoInfoPosition?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceViewInfoInfoPositionListToJson(
  List<enums.DeviceViewInfoInfoPosition>? deviceViewInfoInfoPosition,
) {
  if (deviceViewInfoInfoPosition == null) {
    return [];
  }

  return deviceViewInfoInfoPosition.map((e) => e.value!).toList();
}

List<enums.DeviceViewInfoInfoPosition> deviceViewInfoInfoPositionListFromJson(
  List? deviceViewInfoInfoPosition, [
  List<enums.DeviceViewInfoInfoPosition>? defaultValue,
]) {
  if (deviceViewInfoInfoPosition == null) {
    return defaultValue ?? [];
  }

  return deviceViewInfoInfoPosition
      .map((e) => deviceViewInfoInfoPositionFromJson(e.toString()))
      .toList();
}

List<enums.DeviceViewInfoInfoPosition>?
deviceViewInfoInfoPositionNullableListFromJson(
  List? deviceViewInfoInfoPosition, [
  List<enums.DeviceViewInfoInfoPosition>? defaultValue,
]) {
  if (deviceViewInfoInfoPosition == null) {
    return defaultValue;
  }

  return deviceViewInfoInfoPosition
      .map((e) => deviceViewInfoInfoPositionFromJson(e.toString()))
      .toList();
}

String? deviceViewInfoBorderNullableToJson(
  enums.DeviceViewInfoBorder? deviceViewInfoBorder,
) {
  return deviceViewInfoBorder?.value;
}

String? deviceViewInfoBorderToJson(
  enums.DeviceViewInfoBorder deviceViewInfoBorder,
) {
  return deviceViewInfoBorder.value;
}

enums.DeviceViewInfoBorder deviceViewInfoBorderFromJson(
  Object? deviceViewInfoBorder, [
  enums.DeviceViewInfoBorder? defaultValue,
]) {
  return enums.DeviceViewInfoBorder.values.firstWhereOrNull(
        (e) => e.value == deviceViewInfoBorder,
      ) ??
      defaultValue ??
      enums.DeviceViewInfoBorder.swaggerGeneratedUnknown;
}

enums.DeviceViewInfoBorder? deviceViewInfoBorderNullableFromJson(
  Object? deviceViewInfoBorder, [
  enums.DeviceViewInfoBorder? defaultValue,
]) {
  if (deviceViewInfoBorder == null) {
    return null;
  }
  return enums.DeviceViewInfoBorder.values.firstWhereOrNull(
        (e) => e.value == deviceViewInfoBorder,
      ) ??
      defaultValue;
}

String deviceViewInfoBorderExplodedListToJson(
  List<enums.DeviceViewInfoBorder>? deviceViewInfoBorder,
) {
  return deviceViewInfoBorder?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceViewInfoBorderListToJson(
  List<enums.DeviceViewInfoBorder>? deviceViewInfoBorder,
) {
  if (deviceViewInfoBorder == null) {
    return [];
  }

  return deviceViewInfoBorder.map((e) => e.value!).toList();
}

List<enums.DeviceViewInfoBorder> deviceViewInfoBorderListFromJson(
  List? deviceViewInfoBorder, [
  List<enums.DeviceViewInfoBorder>? defaultValue,
]) {
  if (deviceViewInfoBorder == null) {
    return defaultValue ?? [];
  }

  return deviceViewInfoBorder
      .map((e) => deviceViewInfoBorderFromJson(e.toString()))
      .toList();
}

List<enums.DeviceViewInfoBorder>? deviceViewInfoBorderNullableListFromJson(
  List? deviceViewInfoBorder, [
  List<enums.DeviceViewInfoBorder>? defaultValue,
]) {
  if (deviceViewInfoBorder == null) {
    return defaultValue;
  }

  return deviceViewInfoBorder
      .map((e) => deviceViewInfoBorderFromJson(e.toString()))
      .toList();
}

String? deviceViewInfoPositionNullableToJson(
  enums.DeviceViewInfoPosition? deviceViewInfoPosition,
) {
  return deviceViewInfoPosition?.value;
}

String? deviceViewInfoPositionToJson(
  enums.DeviceViewInfoPosition deviceViewInfoPosition,
) {
  return deviceViewInfoPosition.value;
}

enums.DeviceViewInfoPosition deviceViewInfoPositionFromJson(
  Object? deviceViewInfoPosition, [
  enums.DeviceViewInfoPosition? defaultValue,
]) {
  return enums.DeviceViewInfoPosition.values.firstWhereOrNull(
        (e) => e.value == deviceViewInfoPosition,
      ) ??
      defaultValue ??
      enums.DeviceViewInfoPosition.swaggerGeneratedUnknown;
}

enums.DeviceViewInfoPosition? deviceViewInfoPositionNullableFromJson(
  Object? deviceViewInfoPosition, [
  enums.DeviceViewInfoPosition? defaultValue,
]) {
  if (deviceViewInfoPosition == null) {
    return null;
  }
  return enums.DeviceViewInfoPosition.values.firstWhereOrNull(
        (e) => e.value == deviceViewInfoPosition,
      ) ??
      defaultValue;
}

String deviceViewInfoPositionExplodedListToJson(
  List<enums.DeviceViewInfoPosition>? deviceViewInfoPosition,
) {
  return deviceViewInfoPosition?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceViewInfoPositionListToJson(
  List<enums.DeviceViewInfoPosition>? deviceViewInfoPosition,
) {
  if (deviceViewInfoPosition == null) {
    return [];
  }

  return deviceViewInfoPosition.map((e) => e.value!).toList();
}

List<enums.DeviceViewInfoPosition> deviceViewInfoPositionListFromJson(
  List? deviceViewInfoPosition, [
  List<enums.DeviceViewInfoPosition>? defaultValue,
]) {
  if (deviceViewInfoPosition == null) {
    return defaultValue ?? [];
  }

  return deviceViewInfoPosition
      .map((e) => deviceViewInfoPositionFromJson(e.toString()))
      .toList();
}

List<enums.DeviceViewInfoPosition>? deviceViewInfoPositionNullableListFromJson(
  List? deviceViewInfoPosition, [
  List<enums.DeviceViewInfoPosition>? defaultValue,
]) {
  if (deviceViewInfoPosition == null) {
    return defaultValue;
  }

  return deviceViewInfoPosition
      .map((e) => deviceViewInfoPositionFromJson(e.toString()))
      .toList();
}

String? deviceViewBorderNullableToJson(
  enums.DeviceViewBorder? deviceViewBorder,
) {
  return deviceViewBorder?.value;
}

String? deviceViewBorderToJson(enums.DeviceViewBorder deviceViewBorder) {
  return deviceViewBorder.value;
}

enums.DeviceViewBorder deviceViewBorderFromJson(
  Object? deviceViewBorder, [
  enums.DeviceViewBorder? defaultValue,
]) {
  return enums.DeviceViewBorder.values.firstWhereOrNull(
        (e) => e.value == deviceViewBorder,
      ) ??
      defaultValue ??
      enums.DeviceViewBorder.swaggerGeneratedUnknown;
}

enums.DeviceViewBorder? deviceViewBorderNullableFromJson(
  Object? deviceViewBorder, [
  enums.DeviceViewBorder? defaultValue,
]) {
  if (deviceViewBorder == null) {
    return null;
  }
  return enums.DeviceViewBorder.values.firstWhereOrNull(
        (e) => e.value == deviceViewBorder,
      ) ??
      defaultValue;
}

String deviceViewBorderExplodedListToJson(
  List<enums.DeviceViewBorder>? deviceViewBorder,
) {
  return deviceViewBorder?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceViewBorderListToJson(
  List<enums.DeviceViewBorder>? deviceViewBorder,
) {
  if (deviceViewBorder == null) {
    return [];
  }

  return deviceViewBorder.map((e) => e.value!).toList();
}

List<enums.DeviceViewBorder> deviceViewBorderListFromJson(
  List? deviceViewBorder, [
  List<enums.DeviceViewBorder>? defaultValue,
]) {
  if (deviceViewBorder == null) {
    return defaultValue ?? [];
  }

  return deviceViewBorder
      .map((e) => deviceViewBorderFromJson(e.toString()))
      .toList();
}

List<enums.DeviceViewBorder>? deviceViewBorderNullableListFromJson(
  List? deviceViewBorder, [
  List<enums.DeviceViewBorder>? defaultValue,
]) {
  if (deviceViewBorder == null) {
    return defaultValue;
  }

  return deviceViewBorder
      .map((e) => deviceViewBorderFromJson(e.toString()))
      .toList();
}

String? triggeredControlDeliveryStatusNullableToJson(
  enums.TriggeredControlDeliveryStatus? triggeredControlDeliveryStatus,
) {
  return triggeredControlDeliveryStatus?.value;
}

String? triggeredControlDeliveryStatusToJson(
  enums.TriggeredControlDeliveryStatus triggeredControlDeliveryStatus,
) {
  return triggeredControlDeliveryStatus.value;
}

enums.TriggeredControlDeliveryStatus triggeredControlDeliveryStatusFromJson(
  Object? triggeredControlDeliveryStatus, [
  enums.TriggeredControlDeliveryStatus? defaultValue,
]) {
  return enums.TriggeredControlDeliveryStatus.values.firstWhereOrNull(
        (e) => e.value == triggeredControlDeliveryStatus,
      ) ??
      defaultValue ??
      enums.TriggeredControlDeliveryStatus.swaggerGeneratedUnknown;
}

enums.TriggeredControlDeliveryStatus?
triggeredControlDeliveryStatusNullableFromJson(
  Object? triggeredControlDeliveryStatus, [
  enums.TriggeredControlDeliveryStatus? defaultValue,
]) {
  if (triggeredControlDeliveryStatus == null) {
    return null;
  }
  return enums.TriggeredControlDeliveryStatus.values.firstWhereOrNull(
        (e) => e.value == triggeredControlDeliveryStatus,
      ) ??
      defaultValue;
}

String triggeredControlDeliveryStatusExplodedListToJson(
  List<enums.TriggeredControlDeliveryStatus>? triggeredControlDeliveryStatus,
) {
  return triggeredControlDeliveryStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggeredControlDeliveryStatusListToJson(
  List<enums.TriggeredControlDeliveryStatus>? triggeredControlDeliveryStatus,
) {
  if (triggeredControlDeliveryStatus == null) {
    return [];
  }

  return triggeredControlDeliveryStatus.map((e) => e.value!).toList();
}

List<enums.TriggeredControlDeliveryStatus>
triggeredControlDeliveryStatusListFromJson(
  List? triggeredControlDeliveryStatus, [
  List<enums.TriggeredControlDeliveryStatus>? defaultValue,
]) {
  if (triggeredControlDeliveryStatus == null) {
    return defaultValue ?? [];
  }

  return triggeredControlDeliveryStatus
      .map((e) => triggeredControlDeliveryStatusFromJson(e.toString()))
      .toList();
}

List<enums.TriggeredControlDeliveryStatus>?
triggeredControlDeliveryStatusNullableListFromJson(
  List? triggeredControlDeliveryStatus, [
  List<enums.TriggeredControlDeliveryStatus>? defaultValue,
]) {
  if (triggeredControlDeliveryStatus == null) {
    return defaultValue;
  }

  return triggeredControlDeliveryStatus
      .map((e) => triggeredControlDeliveryStatusFromJson(e.toString()))
      .toList();
}

String? radiusConfigRadTypeNullableToJson(
  enums.RadiusConfigRadType? radiusConfigRadType,
) {
  return radiusConfigRadType?.value;
}

String? radiusConfigRadTypeToJson(
  enums.RadiusConfigRadType radiusConfigRadType,
) {
  return radiusConfigRadType.value;
}

enums.RadiusConfigRadType radiusConfigRadTypeFromJson(
  Object? radiusConfigRadType, [
  enums.RadiusConfigRadType? defaultValue,
]) {
  return enums.RadiusConfigRadType.values.firstWhereOrNull(
        (e) => e.value == radiusConfigRadType,
      ) ??
      defaultValue ??
      enums.RadiusConfigRadType.swaggerGeneratedUnknown;
}

enums.RadiusConfigRadType? radiusConfigRadTypeNullableFromJson(
  Object? radiusConfigRadType, [
  enums.RadiusConfigRadType? defaultValue,
]) {
  if (radiusConfigRadType == null) {
    return null;
  }
  return enums.RadiusConfigRadType.values.firstWhereOrNull(
        (e) => e.value == radiusConfigRadType,
      ) ??
      defaultValue;
}

String radiusConfigRadTypeExplodedListToJson(
  List<enums.RadiusConfigRadType>? radiusConfigRadType,
) {
  return radiusConfigRadType?.map((e) => e.value!).join(',') ?? '';
}

List<String> radiusConfigRadTypeListToJson(
  List<enums.RadiusConfigRadType>? radiusConfigRadType,
) {
  if (radiusConfigRadType == null) {
    return [];
  }

  return radiusConfigRadType.map((e) => e.value!).toList();
}

List<enums.RadiusConfigRadType> radiusConfigRadTypeListFromJson(
  List? radiusConfigRadType, [
  List<enums.RadiusConfigRadType>? defaultValue,
]) {
  if (radiusConfigRadType == null) {
    return defaultValue ?? [];
  }

  return radiusConfigRadType
      .map((e) => radiusConfigRadTypeFromJson(e.toString()))
      .toList();
}

List<enums.RadiusConfigRadType>? radiusConfigRadTypeNullableListFromJson(
  List? radiusConfigRadType, [
  List<enums.RadiusConfigRadType>? defaultValue,
]) {
  if (radiusConfigRadType == null) {
    return defaultValue;
  }

  return radiusConfigRadType
      .map((e) => radiusConfigRadTypeFromJson(e.toString()))
      .toList();
}

String? imageFitConfigFitNullableToJson(
  enums.ImageFitConfigFit? imageFitConfigFit,
) {
  return imageFitConfigFit?.value;
}

String? imageFitConfigFitToJson(enums.ImageFitConfigFit imageFitConfigFit) {
  return imageFitConfigFit.value;
}

enums.ImageFitConfigFit imageFitConfigFitFromJson(
  Object? imageFitConfigFit, [
  enums.ImageFitConfigFit? defaultValue,
]) {
  return enums.ImageFitConfigFit.values.firstWhereOrNull(
        (e) => e.value == imageFitConfigFit,
      ) ??
      defaultValue ??
      enums.ImageFitConfigFit.swaggerGeneratedUnknown;
}

enums.ImageFitConfigFit? imageFitConfigFitNullableFromJson(
  Object? imageFitConfigFit, [
  enums.ImageFitConfigFit? defaultValue,
]) {
  if (imageFitConfigFit == null) {
    return null;
  }
  return enums.ImageFitConfigFit.values.firstWhereOrNull(
        (e) => e.value == imageFitConfigFit,
      ) ??
      defaultValue;
}

String imageFitConfigFitExplodedListToJson(
  List<enums.ImageFitConfigFit>? imageFitConfigFit,
) {
  return imageFitConfigFit?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageFitConfigFitListToJson(
  List<enums.ImageFitConfigFit>? imageFitConfigFit,
) {
  if (imageFitConfigFit == null) {
    return [];
  }

  return imageFitConfigFit.map((e) => e.value!).toList();
}

List<enums.ImageFitConfigFit> imageFitConfigFitListFromJson(
  List? imageFitConfigFit, [
  List<enums.ImageFitConfigFit>? defaultValue,
]) {
  if (imageFitConfigFit == null) {
    return defaultValue ?? [];
  }

  return imageFitConfigFit
      .map((e) => imageFitConfigFitFromJson(e.toString()))
      .toList();
}

List<enums.ImageFitConfigFit>? imageFitConfigFitNullableListFromJson(
  List? imageFitConfigFit, [
  List<enums.ImageFitConfigFit>? defaultValue,
]) {
  if (imageFitConfigFit == null) {
    return defaultValue;
  }

  return imageFitConfigFit
      .map((e) => imageFitConfigFitFromJson(e.toString()))
      .toList();
}

String? alignmentConfigAlignmentNullableToJson(
  enums.AlignmentConfigAlignment? alignmentConfigAlignment,
) {
  return alignmentConfigAlignment?.value;
}

String? alignmentConfigAlignmentToJson(
  enums.AlignmentConfigAlignment alignmentConfigAlignment,
) {
  return alignmentConfigAlignment.value;
}

enums.AlignmentConfigAlignment alignmentConfigAlignmentFromJson(
  Object? alignmentConfigAlignment, [
  enums.AlignmentConfigAlignment? defaultValue,
]) {
  return enums.AlignmentConfigAlignment.values.firstWhereOrNull(
        (e) => e.value == alignmentConfigAlignment,
      ) ??
      defaultValue ??
      enums.AlignmentConfigAlignment.swaggerGeneratedUnknown;
}

enums.AlignmentConfigAlignment? alignmentConfigAlignmentNullableFromJson(
  Object? alignmentConfigAlignment, [
  enums.AlignmentConfigAlignment? defaultValue,
]) {
  if (alignmentConfigAlignment == null) {
    return null;
  }
  return enums.AlignmentConfigAlignment.values.firstWhereOrNull(
        (e) => e.value == alignmentConfigAlignment,
      ) ??
      defaultValue;
}

String alignmentConfigAlignmentExplodedListToJson(
  List<enums.AlignmentConfigAlignment>? alignmentConfigAlignment,
) {
  return alignmentConfigAlignment?.map((e) => e.value!).join(',') ?? '';
}

List<String> alignmentConfigAlignmentListToJson(
  List<enums.AlignmentConfigAlignment>? alignmentConfigAlignment,
) {
  if (alignmentConfigAlignment == null) {
    return [];
  }

  return alignmentConfigAlignment.map((e) => e.value!).toList();
}

List<enums.AlignmentConfigAlignment> alignmentConfigAlignmentListFromJson(
  List? alignmentConfigAlignment, [
  List<enums.AlignmentConfigAlignment>? defaultValue,
]) {
  if (alignmentConfigAlignment == null) {
    return defaultValue ?? [];
  }

  return alignmentConfigAlignment
      .map((e) => alignmentConfigAlignmentFromJson(e.toString()))
      .toList();
}

List<enums.AlignmentConfigAlignment>?
alignmentConfigAlignmentNullableListFromJson(
  List? alignmentConfigAlignment, [
  List<enums.AlignmentConfigAlignment>? defaultValue,
]) {
  if (alignmentConfigAlignment == null) {
    return defaultValue;
  }

  return alignmentConfigAlignment
      .map((e) => alignmentConfigAlignmentFromJson(e.toString()))
      .toList();
}

String? borderConfigTypeNullableToJson(
  enums.BorderConfigType? borderConfigType,
) {
  return borderConfigType?.value;
}

String? borderConfigTypeToJson(enums.BorderConfigType borderConfigType) {
  return borderConfigType.value;
}

enums.BorderConfigType borderConfigTypeFromJson(
  Object? borderConfigType, [
  enums.BorderConfigType? defaultValue,
]) {
  return enums.BorderConfigType.values.firstWhereOrNull(
        (e) => e.value == borderConfigType,
      ) ??
      defaultValue ??
      enums.BorderConfigType.swaggerGeneratedUnknown;
}

enums.BorderConfigType? borderConfigTypeNullableFromJson(
  Object? borderConfigType, [
  enums.BorderConfigType? defaultValue,
]) {
  if (borderConfigType == null) {
    return null;
  }
  return enums.BorderConfigType.values.firstWhereOrNull(
        (e) => e.value == borderConfigType,
      ) ??
      defaultValue;
}

String borderConfigTypeExplodedListToJson(
  List<enums.BorderConfigType>? borderConfigType,
) {
  return borderConfigType?.map((e) => e.value!).join(',') ?? '';
}

List<String> borderConfigTypeListToJson(
  List<enums.BorderConfigType>? borderConfigType,
) {
  if (borderConfigType == null) {
    return [];
  }

  return borderConfigType.map((e) => e.value!).toList();
}

List<enums.BorderConfigType> borderConfigTypeListFromJson(
  List? borderConfigType, [
  List<enums.BorderConfigType>? defaultValue,
]) {
  if (borderConfigType == null) {
    return defaultValue ?? [];
  }

  return borderConfigType
      .map((e) => borderConfigTypeFromJson(e.toString()))
      .toList();
}

List<enums.BorderConfigType>? borderConfigTypeNullableListFromJson(
  List? borderConfigType, [
  List<enums.BorderConfigType>? defaultValue,
]) {
  if (borderConfigType == null) {
    return defaultValue;
  }

  return borderConfigType
      .map((e) => borderConfigTypeFromJson(e.toString()))
      .toList();
}

String? triggeredEventEventTypeNullableToJson(
  enums.TriggeredEventEventType? triggeredEventEventType,
) {
  return triggeredEventEventType?.value;
}

String? triggeredEventEventTypeToJson(
  enums.TriggeredEventEventType triggeredEventEventType,
) {
  return triggeredEventEventType.value;
}

enums.TriggeredEventEventType triggeredEventEventTypeFromJson(
  Object? triggeredEventEventType, [
  enums.TriggeredEventEventType? defaultValue,
]) {
  return enums.TriggeredEventEventType.values.firstWhereOrNull(
        (e) => e.value == triggeredEventEventType,
      ) ??
      defaultValue ??
      enums.TriggeredEventEventType.swaggerGeneratedUnknown;
}

enums.TriggeredEventEventType? triggeredEventEventTypeNullableFromJson(
  Object? triggeredEventEventType, [
  enums.TriggeredEventEventType? defaultValue,
]) {
  if (triggeredEventEventType == null) {
    return null;
  }
  return enums.TriggeredEventEventType.values.firstWhereOrNull(
        (e) => e.value == triggeredEventEventType,
      ) ??
      defaultValue;
}

String triggeredEventEventTypeExplodedListToJson(
  List<enums.TriggeredEventEventType>? triggeredEventEventType,
) {
  return triggeredEventEventType?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggeredEventEventTypeListToJson(
  List<enums.TriggeredEventEventType>? triggeredEventEventType,
) {
  if (triggeredEventEventType == null) {
    return [];
  }

  return triggeredEventEventType.map((e) => e.value!).toList();
}

List<enums.TriggeredEventEventType> triggeredEventEventTypeListFromJson(
  List? triggeredEventEventType, [
  List<enums.TriggeredEventEventType>? defaultValue,
]) {
  if (triggeredEventEventType == null) {
    return defaultValue ?? [];
  }

  return triggeredEventEventType
      .map((e) => triggeredEventEventTypeFromJson(e.toString()))
      .toList();
}

List<enums.TriggeredEventEventType>?
triggeredEventEventTypeNullableListFromJson(
  List? triggeredEventEventType, [
  List<enums.TriggeredEventEventType>? defaultValue,
]) {
  if (triggeredEventEventType == null) {
    return defaultValue;
  }

  return triggeredEventEventType
      .map((e) => triggeredEventEventTypeFromJson(e.toString()))
      .toList();
}

String? triggeredEventDeliveryStatusNullableToJson(
  enums.TriggeredEventDeliveryStatus? triggeredEventDeliveryStatus,
) {
  return triggeredEventDeliveryStatus?.value;
}

String? triggeredEventDeliveryStatusToJson(
  enums.TriggeredEventDeliveryStatus triggeredEventDeliveryStatus,
) {
  return triggeredEventDeliveryStatus.value;
}

enums.TriggeredEventDeliveryStatus triggeredEventDeliveryStatusFromJson(
  Object? triggeredEventDeliveryStatus, [
  enums.TriggeredEventDeliveryStatus? defaultValue,
]) {
  return enums.TriggeredEventDeliveryStatus.values.firstWhereOrNull(
        (e) => e.value == triggeredEventDeliveryStatus,
      ) ??
      defaultValue ??
      enums.TriggeredEventDeliveryStatus.swaggerGeneratedUnknown;
}

enums.TriggeredEventDeliveryStatus?
triggeredEventDeliveryStatusNullableFromJson(
  Object? triggeredEventDeliveryStatus, [
  enums.TriggeredEventDeliveryStatus? defaultValue,
]) {
  if (triggeredEventDeliveryStatus == null) {
    return null;
  }
  return enums.TriggeredEventDeliveryStatus.values.firstWhereOrNull(
        (e) => e.value == triggeredEventDeliveryStatus,
      ) ??
      defaultValue;
}

String triggeredEventDeliveryStatusExplodedListToJson(
  List<enums.TriggeredEventDeliveryStatus>? triggeredEventDeliveryStatus,
) {
  return triggeredEventDeliveryStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggeredEventDeliveryStatusListToJson(
  List<enums.TriggeredEventDeliveryStatus>? triggeredEventDeliveryStatus,
) {
  if (triggeredEventDeliveryStatus == null) {
    return [];
  }

  return triggeredEventDeliveryStatus.map((e) => e.value!).toList();
}

List<enums.TriggeredEventDeliveryStatus>
triggeredEventDeliveryStatusListFromJson(
  List? triggeredEventDeliveryStatus, [
  List<enums.TriggeredEventDeliveryStatus>? defaultValue,
]) {
  if (triggeredEventDeliveryStatus == null) {
    return defaultValue ?? [];
  }

  return triggeredEventDeliveryStatus
      .map((e) => triggeredEventDeliveryStatusFromJson(e.toString()))
      .toList();
}

List<enums.TriggeredEventDeliveryStatus>?
triggeredEventDeliveryStatusNullableListFromJson(
  List? triggeredEventDeliveryStatus, [
  List<enums.TriggeredEventDeliveryStatus>? defaultValue,
]) {
  if (triggeredEventDeliveryStatus == null) {
    return defaultValue;
  }

  return triggeredEventDeliveryStatus
      .map((e) => triggeredEventDeliveryStatusFromJson(e.toString()))
      .toList();
}

String? triggeredEventSourceTypeNullableToJson(
  enums.TriggeredEventSourceType? triggeredEventSourceType,
) {
  return triggeredEventSourceType?.value;
}

String? triggeredEventSourceTypeToJson(
  enums.TriggeredEventSourceType triggeredEventSourceType,
) {
  return triggeredEventSourceType.value;
}

enums.TriggeredEventSourceType triggeredEventSourceTypeFromJson(
  Object? triggeredEventSourceType, [
  enums.TriggeredEventSourceType? defaultValue,
]) {
  return enums.TriggeredEventSourceType.values.firstWhereOrNull(
        (e) => e.value == triggeredEventSourceType,
      ) ??
      defaultValue ??
      enums.TriggeredEventSourceType.swaggerGeneratedUnknown;
}

enums.TriggeredEventSourceType? triggeredEventSourceTypeNullableFromJson(
  Object? triggeredEventSourceType, [
  enums.TriggeredEventSourceType? defaultValue,
]) {
  if (triggeredEventSourceType == null) {
    return null;
  }
  return enums.TriggeredEventSourceType.values.firstWhereOrNull(
        (e) => e.value == triggeredEventSourceType,
      ) ??
      defaultValue;
}

String triggeredEventSourceTypeExplodedListToJson(
  List<enums.TriggeredEventSourceType>? triggeredEventSourceType,
) {
  return triggeredEventSourceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggeredEventSourceTypeListToJson(
  List<enums.TriggeredEventSourceType>? triggeredEventSourceType,
) {
  if (triggeredEventSourceType == null) {
    return [];
  }

  return triggeredEventSourceType.map((e) => e.value!).toList();
}

List<enums.TriggeredEventSourceType> triggeredEventSourceTypeListFromJson(
  List? triggeredEventSourceType, [
  List<enums.TriggeredEventSourceType>? defaultValue,
]) {
  if (triggeredEventSourceType == null) {
    return defaultValue ?? [];
  }

  return triggeredEventSourceType
      .map((e) => triggeredEventSourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.TriggeredEventSourceType>?
triggeredEventSourceTypeNullableListFromJson(
  List? triggeredEventSourceType, [
  List<enums.TriggeredEventSourceType>? defaultValue,
]) {
  if (triggeredEventSourceType == null) {
    return defaultValue;
  }

  return triggeredEventSourceType
      .map((e) => triggeredEventSourceTypeFromJson(e.toString()))
      .toList();
}

String? screenWidgetInfoTargetNullableToJson(
  enums.ScreenWidgetInfoTarget? screenWidgetInfoTarget,
) {
  return screenWidgetInfoTarget?.value;
}

String? screenWidgetInfoTargetToJson(
  enums.ScreenWidgetInfoTarget screenWidgetInfoTarget,
) {
  return screenWidgetInfoTarget.value;
}

enums.ScreenWidgetInfoTarget screenWidgetInfoTargetFromJson(
  Object? screenWidgetInfoTarget, [
  enums.ScreenWidgetInfoTarget? defaultValue,
]) {
  return enums.ScreenWidgetInfoTarget.values.firstWhereOrNull(
        (e) => e.value == screenWidgetInfoTarget,
      ) ??
      defaultValue ??
      enums.ScreenWidgetInfoTarget.swaggerGeneratedUnknown;
}

enums.ScreenWidgetInfoTarget? screenWidgetInfoTargetNullableFromJson(
  Object? screenWidgetInfoTarget, [
  enums.ScreenWidgetInfoTarget? defaultValue,
]) {
  if (screenWidgetInfoTarget == null) {
    return null;
  }
  return enums.ScreenWidgetInfoTarget.values.firstWhereOrNull(
        (e) => e.value == screenWidgetInfoTarget,
      ) ??
      defaultValue;
}

String screenWidgetInfoTargetExplodedListToJson(
  List<enums.ScreenWidgetInfoTarget>? screenWidgetInfoTarget,
) {
  return screenWidgetInfoTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> screenWidgetInfoTargetListToJson(
  List<enums.ScreenWidgetInfoTarget>? screenWidgetInfoTarget,
) {
  if (screenWidgetInfoTarget == null) {
    return [];
  }

  return screenWidgetInfoTarget.map((e) => e.value!).toList();
}

List<enums.ScreenWidgetInfoTarget> screenWidgetInfoTargetListFromJson(
  List? screenWidgetInfoTarget, [
  List<enums.ScreenWidgetInfoTarget>? defaultValue,
]) {
  if (screenWidgetInfoTarget == null) {
    return defaultValue ?? [];
  }

  return screenWidgetInfoTarget
      .map((e) => screenWidgetInfoTargetFromJson(e.toString()))
      .toList();
}

List<enums.ScreenWidgetInfoTarget>? screenWidgetInfoTargetNullableListFromJson(
  List? screenWidgetInfoTarget, [
  List<enums.ScreenWidgetInfoTarget>? defaultValue,
]) {
  if (screenWidgetInfoTarget == null) {
    return defaultValue;
  }

  return screenWidgetInfoTarget
      .map((e) => screenWidgetInfoTargetFromJson(e.toString()))
      .toList();
}

String? screenWidgetTargetNullableToJson(
  enums.ScreenWidgetTarget? screenWidgetTarget,
) {
  return screenWidgetTarget?.value;
}

String? screenWidgetTargetToJson(enums.ScreenWidgetTarget screenWidgetTarget) {
  return screenWidgetTarget.value;
}

enums.ScreenWidgetTarget screenWidgetTargetFromJson(
  Object? screenWidgetTarget, [
  enums.ScreenWidgetTarget? defaultValue,
]) {
  return enums.ScreenWidgetTarget.values.firstWhereOrNull(
        (e) => e.value == screenWidgetTarget,
      ) ??
      defaultValue ??
      enums.ScreenWidgetTarget.swaggerGeneratedUnknown;
}

enums.ScreenWidgetTarget? screenWidgetTargetNullableFromJson(
  Object? screenWidgetTarget, [
  enums.ScreenWidgetTarget? defaultValue,
]) {
  if (screenWidgetTarget == null) {
    return null;
  }
  return enums.ScreenWidgetTarget.values.firstWhereOrNull(
        (e) => e.value == screenWidgetTarget,
      ) ??
      defaultValue;
}

String screenWidgetTargetExplodedListToJson(
  List<enums.ScreenWidgetTarget>? screenWidgetTarget,
) {
  return screenWidgetTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> screenWidgetTargetListToJson(
  List<enums.ScreenWidgetTarget>? screenWidgetTarget,
) {
  if (screenWidgetTarget == null) {
    return [];
  }

  return screenWidgetTarget.map((e) => e.value!).toList();
}

List<enums.ScreenWidgetTarget> screenWidgetTargetListFromJson(
  List? screenWidgetTarget, [
  List<enums.ScreenWidgetTarget>? defaultValue,
]) {
  if (screenWidgetTarget == null) {
    return defaultValue ?? [];
  }

  return screenWidgetTarget
      .map((e) => screenWidgetTargetFromJson(e.toString()))
      .toList();
}

List<enums.ScreenWidgetTarget>? screenWidgetTargetNullableListFromJson(
  List? screenWidgetTarget, [
  List<enums.ScreenWidgetTarget>? defaultValue,
]) {
  if (screenWidgetTarget == null) {
    return defaultValue;
  }

  return screenWidgetTarget
      .map((e) => screenWidgetTargetFromJson(e.toString()))
      .toList();
}

String? filterMatchGroupMatchTypeNullableToJson(
  enums.FilterMatchGroupMatchType? filterMatchGroupMatchType,
) {
  return filterMatchGroupMatchType?.value;
}

String? filterMatchGroupMatchTypeToJson(
  enums.FilterMatchGroupMatchType filterMatchGroupMatchType,
) {
  return filterMatchGroupMatchType.value;
}

enums.FilterMatchGroupMatchType filterMatchGroupMatchTypeFromJson(
  Object? filterMatchGroupMatchType, [
  enums.FilterMatchGroupMatchType? defaultValue,
]) {
  return enums.FilterMatchGroupMatchType.values.firstWhereOrNull(
        (e) => e.value == filterMatchGroupMatchType,
      ) ??
      defaultValue ??
      enums.FilterMatchGroupMatchType.swaggerGeneratedUnknown;
}

enums.FilterMatchGroupMatchType? filterMatchGroupMatchTypeNullableFromJson(
  Object? filterMatchGroupMatchType, [
  enums.FilterMatchGroupMatchType? defaultValue,
]) {
  if (filterMatchGroupMatchType == null) {
    return null;
  }
  return enums.FilterMatchGroupMatchType.values.firstWhereOrNull(
        (e) => e.value == filterMatchGroupMatchType,
      ) ??
      defaultValue;
}

String filterMatchGroupMatchTypeExplodedListToJson(
  List<enums.FilterMatchGroupMatchType>? filterMatchGroupMatchType,
) {
  return filterMatchGroupMatchType?.map((e) => e.value!).join(',') ?? '';
}

List<String> filterMatchGroupMatchTypeListToJson(
  List<enums.FilterMatchGroupMatchType>? filterMatchGroupMatchType,
) {
  if (filterMatchGroupMatchType == null) {
    return [];
  }

  return filterMatchGroupMatchType.map((e) => e.value!).toList();
}

List<enums.FilterMatchGroupMatchType> filterMatchGroupMatchTypeListFromJson(
  List? filterMatchGroupMatchType, [
  List<enums.FilterMatchGroupMatchType>? defaultValue,
]) {
  if (filterMatchGroupMatchType == null) {
    return defaultValue ?? [];
  }

  return filterMatchGroupMatchType
      .map((e) => filterMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

List<enums.FilterMatchGroupMatchType>?
filterMatchGroupMatchTypeNullableListFromJson(
  List? filterMatchGroupMatchType, [
  List<enums.FilterMatchGroupMatchType>? defaultValue,
]) {
  if (filterMatchGroupMatchType == null) {
    return defaultValue;
  }

  return filterMatchGroupMatchType
      .map((e) => filterMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

String? dataFilterInfoTargetNullableToJson(
  enums.DataFilterInfoTarget? dataFilterInfoTarget,
) {
  return dataFilterInfoTarget?.value;
}

String? dataFilterInfoTargetToJson(
  enums.DataFilterInfoTarget dataFilterInfoTarget,
) {
  return dataFilterInfoTarget.value;
}

enums.DataFilterInfoTarget dataFilterInfoTargetFromJson(
  Object? dataFilterInfoTarget, [
  enums.DataFilterInfoTarget? defaultValue,
]) {
  return enums.DataFilterInfoTarget.values.firstWhereOrNull(
        (e) => e.value == dataFilterInfoTarget,
      ) ??
      defaultValue ??
      enums.DataFilterInfoTarget.swaggerGeneratedUnknown;
}

enums.DataFilterInfoTarget? dataFilterInfoTargetNullableFromJson(
  Object? dataFilterInfoTarget, [
  enums.DataFilterInfoTarget? defaultValue,
]) {
  if (dataFilterInfoTarget == null) {
    return null;
  }
  return enums.DataFilterInfoTarget.values.firstWhereOrNull(
        (e) => e.value == dataFilterInfoTarget,
      ) ??
      defaultValue;
}

String dataFilterInfoTargetExplodedListToJson(
  List<enums.DataFilterInfoTarget>? dataFilterInfoTarget,
) {
  return dataFilterInfoTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> dataFilterInfoTargetListToJson(
  List<enums.DataFilterInfoTarget>? dataFilterInfoTarget,
) {
  if (dataFilterInfoTarget == null) {
    return [];
  }

  return dataFilterInfoTarget.map((e) => e.value!).toList();
}

List<enums.DataFilterInfoTarget> dataFilterInfoTargetListFromJson(
  List? dataFilterInfoTarget, [
  List<enums.DataFilterInfoTarget>? defaultValue,
]) {
  if (dataFilterInfoTarget == null) {
    return defaultValue ?? [];
  }

  return dataFilterInfoTarget
      .map((e) => dataFilterInfoTargetFromJson(e.toString()))
      .toList();
}

List<enums.DataFilterInfoTarget>? dataFilterInfoTargetNullableListFromJson(
  List? dataFilterInfoTarget, [
  List<enums.DataFilterInfoTarget>? defaultValue,
]) {
  if (dataFilterInfoTarget == null) {
    return defaultValue;
  }

  return dataFilterInfoTarget
      .map((e) => dataFilterInfoTargetFromJson(e.toString()))
      .toList();
}

String? dataFilterTargetNullableToJson(
  enums.DataFilterTarget? dataFilterTarget,
) {
  return dataFilterTarget?.value;
}

String? dataFilterTargetToJson(enums.DataFilterTarget dataFilterTarget) {
  return dataFilterTarget.value;
}

enums.DataFilterTarget dataFilterTargetFromJson(
  Object? dataFilterTarget, [
  enums.DataFilterTarget? defaultValue,
]) {
  return enums.DataFilterTarget.values.firstWhereOrNull(
        (e) => e.value == dataFilterTarget,
      ) ??
      defaultValue ??
      enums.DataFilterTarget.swaggerGeneratedUnknown;
}

enums.DataFilterTarget? dataFilterTargetNullableFromJson(
  Object? dataFilterTarget, [
  enums.DataFilterTarget? defaultValue,
]) {
  if (dataFilterTarget == null) {
    return null;
  }
  return enums.DataFilterTarget.values.firstWhereOrNull(
        (e) => e.value == dataFilterTarget,
      ) ??
      defaultValue;
}

String dataFilterTargetExplodedListToJson(
  List<enums.DataFilterTarget>? dataFilterTarget,
) {
  return dataFilterTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> dataFilterTargetListToJson(
  List<enums.DataFilterTarget>? dataFilterTarget,
) {
  if (dataFilterTarget == null) {
    return [];
  }

  return dataFilterTarget.map((e) => e.value!).toList();
}

List<enums.DataFilterTarget> dataFilterTargetListFromJson(
  List? dataFilterTarget, [
  List<enums.DataFilterTarget>? defaultValue,
]) {
  if (dataFilterTarget == null) {
    return defaultValue ?? [];
  }

  return dataFilterTarget
      .map((e) => dataFilterTargetFromJson(e.toString()))
      .toList();
}

List<enums.DataFilterTarget>? dataFilterTargetNullableListFromJson(
  List? dataFilterTarget, [
  List<enums.DataFilterTarget>? defaultValue,
]) {
  if (dataFilterTarget == null) {
    return defaultValue;
  }

  return dataFilterTarget
      .map((e) => dataFilterTargetFromJson(e.toString()))
      .toList();
}

String? geoFenceInfoFenceTypeNullableToJson(
  enums.GeoFenceInfoFenceType? geoFenceInfoFenceType,
) {
  return geoFenceInfoFenceType?.value;
}

String? geoFenceInfoFenceTypeToJson(
  enums.GeoFenceInfoFenceType geoFenceInfoFenceType,
) {
  return geoFenceInfoFenceType.value;
}

enums.GeoFenceInfoFenceType geoFenceInfoFenceTypeFromJson(
  Object? geoFenceInfoFenceType, [
  enums.GeoFenceInfoFenceType? defaultValue,
]) {
  return enums.GeoFenceInfoFenceType.values.firstWhereOrNull(
        (e) => e.value == geoFenceInfoFenceType,
      ) ??
      defaultValue ??
      enums.GeoFenceInfoFenceType.swaggerGeneratedUnknown;
}

enums.GeoFenceInfoFenceType? geoFenceInfoFenceTypeNullableFromJson(
  Object? geoFenceInfoFenceType, [
  enums.GeoFenceInfoFenceType? defaultValue,
]) {
  if (geoFenceInfoFenceType == null) {
    return null;
  }
  return enums.GeoFenceInfoFenceType.values.firstWhereOrNull(
        (e) => e.value == geoFenceInfoFenceType,
      ) ??
      defaultValue;
}

String geoFenceInfoFenceTypeExplodedListToJson(
  List<enums.GeoFenceInfoFenceType>? geoFenceInfoFenceType,
) {
  return geoFenceInfoFenceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> geoFenceInfoFenceTypeListToJson(
  List<enums.GeoFenceInfoFenceType>? geoFenceInfoFenceType,
) {
  if (geoFenceInfoFenceType == null) {
    return [];
  }

  return geoFenceInfoFenceType.map((e) => e.value!).toList();
}

List<enums.GeoFenceInfoFenceType> geoFenceInfoFenceTypeListFromJson(
  List? geoFenceInfoFenceType, [
  List<enums.GeoFenceInfoFenceType>? defaultValue,
]) {
  if (geoFenceInfoFenceType == null) {
    return defaultValue ?? [];
  }

  return geoFenceInfoFenceType
      .map((e) => geoFenceInfoFenceTypeFromJson(e.toString()))
      .toList();
}

List<enums.GeoFenceInfoFenceType>? geoFenceInfoFenceTypeNullableListFromJson(
  List? geoFenceInfoFenceType, [
  List<enums.GeoFenceInfoFenceType>? defaultValue,
]) {
  if (geoFenceInfoFenceType == null) {
    return defaultValue;
  }

  return geoFenceInfoFenceType
      .map((e) => geoFenceInfoFenceTypeFromJson(e.toString()))
      .toList();
}

String? geoFenceFenceTypeNullableToJson(
  enums.GeoFenceFenceType? geoFenceFenceType,
) {
  return geoFenceFenceType?.value;
}

String? geoFenceFenceTypeToJson(enums.GeoFenceFenceType geoFenceFenceType) {
  return geoFenceFenceType.value;
}

enums.GeoFenceFenceType geoFenceFenceTypeFromJson(
  Object? geoFenceFenceType, [
  enums.GeoFenceFenceType? defaultValue,
]) {
  return enums.GeoFenceFenceType.values.firstWhereOrNull(
        (e) => e.value == geoFenceFenceType,
      ) ??
      defaultValue ??
      enums.GeoFenceFenceType.swaggerGeneratedUnknown;
}

enums.GeoFenceFenceType? geoFenceFenceTypeNullableFromJson(
  Object? geoFenceFenceType, [
  enums.GeoFenceFenceType? defaultValue,
]) {
  if (geoFenceFenceType == null) {
    return null;
  }
  return enums.GeoFenceFenceType.values.firstWhereOrNull(
        (e) => e.value == geoFenceFenceType,
      ) ??
      defaultValue;
}

String geoFenceFenceTypeExplodedListToJson(
  List<enums.GeoFenceFenceType>? geoFenceFenceType,
) {
  return geoFenceFenceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> geoFenceFenceTypeListToJson(
  List<enums.GeoFenceFenceType>? geoFenceFenceType,
) {
  if (geoFenceFenceType == null) {
    return [];
  }

  return geoFenceFenceType.map((e) => e.value!).toList();
}

List<enums.GeoFenceFenceType> geoFenceFenceTypeListFromJson(
  List? geoFenceFenceType, [
  List<enums.GeoFenceFenceType>? defaultValue,
]) {
  if (geoFenceFenceType == null) {
    return defaultValue ?? [];
  }

  return geoFenceFenceType
      .map((e) => geoFenceFenceTypeFromJson(e.toString()))
      .toList();
}

List<enums.GeoFenceFenceType>? geoFenceFenceTypeNullableListFromJson(
  List? geoFenceFenceType, [
  List<enums.GeoFenceFenceType>? defaultValue,
]) {
  if (geoFenceFenceType == null) {
    return defaultValue;
  }

  return geoFenceFenceType
      .map((e) => geoFenceFenceTypeFromJson(e.toString()))
      .toList();
}

String? floorInfoFloorTypeNullableToJson(
  enums.FloorInfoFloorType? floorInfoFloorType,
) {
  return floorInfoFloorType?.value;
}

String? floorInfoFloorTypeToJson(enums.FloorInfoFloorType floorInfoFloorType) {
  return floorInfoFloorType.value;
}

enums.FloorInfoFloorType floorInfoFloorTypeFromJson(
  Object? floorInfoFloorType, [
  enums.FloorInfoFloorType? defaultValue,
]) {
  return enums.FloorInfoFloorType.values.firstWhereOrNull(
        (e) => e.value == floorInfoFloorType,
      ) ??
      defaultValue ??
      enums.FloorInfoFloorType.swaggerGeneratedUnknown;
}

enums.FloorInfoFloorType? floorInfoFloorTypeNullableFromJson(
  Object? floorInfoFloorType, [
  enums.FloorInfoFloorType? defaultValue,
]) {
  if (floorInfoFloorType == null) {
    return null;
  }
  return enums.FloorInfoFloorType.values.firstWhereOrNull(
        (e) => e.value == floorInfoFloorType,
      ) ??
      defaultValue;
}

String floorInfoFloorTypeExplodedListToJson(
  List<enums.FloorInfoFloorType>? floorInfoFloorType,
) {
  return floorInfoFloorType?.map((e) => e.value!).join(',') ?? '';
}

List<String> floorInfoFloorTypeListToJson(
  List<enums.FloorInfoFloorType>? floorInfoFloorType,
) {
  if (floorInfoFloorType == null) {
    return [];
  }

  return floorInfoFloorType.map((e) => e.value!).toList();
}

List<enums.FloorInfoFloorType> floorInfoFloorTypeListFromJson(
  List? floorInfoFloorType, [
  List<enums.FloorInfoFloorType>? defaultValue,
]) {
  if (floorInfoFloorType == null) {
    return defaultValue ?? [];
  }

  return floorInfoFloorType
      .map((e) => floorInfoFloorTypeFromJson(e.toString()))
      .toList();
}

List<enums.FloorInfoFloorType>? floorInfoFloorTypeNullableListFromJson(
  List? floorInfoFloorType, [
  List<enums.FloorInfoFloorType>? defaultValue,
]) {
  if (floorInfoFloorType == null) {
    return defaultValue;
  }

  return floorInfoFloorType
      .map((e) => floorInfoFloorTypeFromJson(e.toString()))
      .toList();
}

String? floorFloorTypeNullableToJson(enums.FloorFloorType? floorFloorType) {
  return floorFloorType?.value;
}

String? floorFloorTypeToJson(enums.FloorFloorType floorFloorType) {
  return floorFloorType.value;
}

enums.FloorFloorType floorFloorTypeFromJson(
  Object? floorFloorType, [
  enums.FloorFloorType? defaultValue,
]) {
  return enums.FloorFloorType.values.firstWhereOrNull(
        (e) => e.value == floorFloorType,
      ) ??
      defaultValue ??
      enums.FloorFloorType.swaggerGeneratedUnknown;
}

enums.FloorFloorType? floorFloorTypeNullableFromJson(
  Object? floorFloorType, [
  enums.FloorFloorType? defaultValue,
]) {
  if (floorFloorType == null) {
    return null;
  }
  return enums.FloorFloorType.values.firstWhereOrNull(
        (e) => e.value == floorFloorType,
      ) ??
      defaultValue;
}

String floorFloorTypeExplodedListToJson(
  List<enums.FloorFloorType>? floorFloorType,
) {
  return floorFloorType?.map((e) => e.value!).join(',') ?? '';
}

List<String> floorFloorTypeListToJson(
  List<enums.FloorFloorType>? floorFloorType,
) {
  if (floorFloorType == null) {
    return [];
  }

  return floorFloorType.map((e) => e.value!).toList();
}

List<enums.FloorFloorType> floorFloorTypeListFromJson(
  List? floorFloorType, [
  List<enums.FloorFloorType>? defaultValue,
]) {
  if (floorFloorType == null) {
    return defaultValue ?? [];
  }

  return floorFloorType
      .map((e) => floorFloorTypeFromJson(e.toString()))
      .toList();
}

List<enums.FloorFloorType>? floorFloorTypeNullableListFromJson(
  List? floorFloorType, [
  List<enums.FloorFloorType>? defaultValue,
]) {
  if (floorFloorType == null) {
    return defaultValue;
  }

  return floorFloorType
      .map((e) => floorFloorTypeFromJson(e.toString()))
      .toList();
}

String? twinUserEntityStateNullableToJson(
  enums.TwinUserEntityState? twinUserEntityState,
) {
  return twinUserEntityState?.value;
}

String? twinUserEntityStateToJson(
  enums.TwinUserEntityState twinUserEntityState,
) {
  return twinUserEntityState.value;
}

enums.TwinUserEntityState twinUserEntityStateFromJson(
  Object? twinUserEntityState, [
  enums.TwinUserEntityState? defaultValue,
]) {
  return enums.TwinUserEntityState.values.firstWhereOrNull(
        (e) => e.value == twinUserEntityState,
      ) ??
      defaultValue ??
      enums.TwinUserEntityState.swaggerGeneratedUnknown;
}

enums.TwinUserEntityState? twinUserEntityStateNullableFromJson(
  Object? twinUserEntityState, [
  enums.TwinUserEntityState? defaultValue,
]) {
  if (twinUserEntityState == null) {
    return null;
  }
  return enums.TwinUserEntityState.values.firstWhereOrNull(
        (e) => e.value == twinUserEntityState,
      ) ??
      defaultValue;
}

String twinUserEntityStateExplodedListToJson(
  List<enums.TwinUserEntityState>? twinUserEntityState,
) {
  return twinUserEntityState?.map((e) => e.value!).join(',') ?? '';
}

List<String> twinUserEntityStateListToJson(
  List<enums.TwinUserEntityState>? twinUserEntityState,
) {
  if (twinUserEntityState == null) {
    return [];
  }

  return twinUserEntityState.map((e) => e.value!).toList();
}

List<enums.TwinUserEntityState> twinUserEntityStateListFromJson(
  List? twinUserEntityState, [
  List<enums.TwinUserEntityState>? defaultValue,
]) {
  if (twinUserEntityState == null) {
    return defaultValue ?? [];
  }

  return twinUserEntityState
      .map((e) => twinUserEntityStateFromJson(e.toString()))
      .toList();
}

List<enums.TwinUserEntityState>? twinUserEntityStateNullableListFromJson(
  List? twinUserEntityState, [
  List<enums.TwinUserEntityState>? defaultValue,
]) {
  if (twinUserEntityState == null) {
    return defaultValue;
  }

  return twinUserEntityState
      .map((e) => twinUserEntityStateFromJson(e.toString()))
      .toList();
}

String? twinLoggedInUserEntityStateNullableToJson(
  enums.TwinLoggedInUserEntityState? twinLoggedInUserEntityState,
) {
  return twinLoggedInUserEntityState?.value;
}

String? twinLoggedInUserEntityStateToJson(
  enums.TwinLoggedInUserEntityState twinLoggedInUserEntityState,
) {
  return twinLoggedInUserEntityState.value;
}

enums.TwinLoggedInUserEntityState twinLoggedInUserEntityStateFromJson(
  Object? twinLoggedInUserEntityState, [
  enums.TwinLoggedInUserEntityState? defaultValue,
]) {
  return enums.TwinLoggedInUserEntityState.values.firstWhereOrNull(
        (e) => e.value == twinLoggedInUserEntityState,
      ) ??
      defaultValue ??
      enums.TwinLoggedInUserEntityState.swaggerGeneratedUnknown;
}

enums.TwinLoggedInUserEntityState? twinLoggedInUserEntityStateNullableFromJson(
  Object? twinLoggedInUserEntityState, [
  enums.TwinLoggedInUserEntityState? defaultValue,
]) {
  if (twinLoggedInUserEntityState == null) {
    return null;
  }
  return enums.TwinLoggedInUserEntityState.values.firstWhereOrNull(
        (e) => e.value == twinLoggedInUserEntityState,
      ) ??
      defaultValue;
}

String twinLoggedInUserEntityStateExplodedListToJson(
  List<enums.TwinLoggedInUserEntityState>? twinLoggedInUserEntityState,
) {
  return twinLoggedInUserEntityState?.map((e) => e.value!).join(',') ?? '';
}

List<String> twinLoggedInUserEntityStateListToJson(
  List<enums.TwinLoggedInUserEntityState>? twinLoggedInUserEntityState,
) {
  if (twinLoggedInUserEntityState == null) {
    return [];
  }

  return twinLoggedInUserEntityState.map((e) => e.value!).toList();
}

List<enums.TwinLoggedInUserEntityState> twinLoggedInUserEntityStateListFromJson(
  List? twinLoggedInUserEntityState, [
  List<enums.TwinLoggedInUserEntityState>? defaultValue,
]) {
  if (twinLoggedInUserEntityState == null) {
    return defaultValue ?? [];
  }

  return twinLoggedInUserEntityState
      .map((e) => twinLoggedInUserEntityStateFromJson(e.toString()))
      .toList();
}

List<enums.TwinLoggedInUserEntityState>?
twinLoggedInUserEntityStateNullableListFromJson(
  List? twinLoggedInUserEntityState, [
  List<enums.TwinLoggedInUserEntityState>? defaultValue,
]) {
  if (twinLoggedInUserEntityState == null) {
    return defaultValue;
  }

  return twinLoggedInUserEntityState
      .map((e) => twinLoggedInUserEntityStateFromJson(e.toString()))
      .toList();
}

String? attributeAttributeTypeNullableToJson(
  enums.AttributeAttributeType? attributeAttributeType,
) {
  return attributeAttributeType?.value;
}

String? attributeAttributeTypeToJson(
  enums.AttributeAttributeType attributeAttributeType,
) {
  return attributeAttributeType.value;
}

enums.AttributeAttributeType attributeAttributeTypeFromJson(
  Object? attributeAttributeType, [
  enums.AttributeAttributeType? defaultValue,
]) {
  return enums.AttributeAttributeType.values.firstWhereOrNull(
        (e) => e.value == attributeAttributeType,
      ) ??
      defaultValue ??
      enums.AttributeAttributeType.swaggerGeneratedUnknown;
}

enums.AttributeAttributeType? attributeAttributeTypeNullableFromJson(
  Object? attributeAttributeType, [
  enums.AttributeAttributeType? defaultValue,
]) {
  if (attributeAttributeType == null) {
    return null;
  }
  return enums.AttributeAttributeType.values.firstWhereOrNull(
        (e) => e.value == attributeAttributeType,
      ) ??
      defaultValue;
}

String attributeAttributeTypeExplodedListToJson(
  List<enums.AttributeAttributeType>? attributeAttributeType,
) {
  return attributeAttributeType?.map((e) => e.value!).join(',') ?? '';
}

List<String> attributeAttributeTypeListToJson(
  List<enums.AttributeAttributeType>? attributeAttributeType,
) {
  if (attributeAttributeType == null) {
    return [];
  }

  return attributeAttributeType.map((e) => e.value!).toList();
}

List<enums.AttributeAttributeType> attributeAttributeTypeListFromJson(
  List? attributeAttributeType, [
  List<enums.AttributeAttributeType>? defaultValue,
]) {
  if (attributeAttributeType == null) {
    return defaultValue ?? [];
  }

  return attributeAttributeType
      .map((e) => attributeAttributeTypeFromJson(e.toString()))
      .toList();
}

List<enums.AttributeAttributeType>? attributeAttributeTypeNullableListFromJson(
  List? attributeAttributeType, [
  List<enums.AttributeAttributeType>? defaultValue,
]) {
  if (attributeAttributeType == null) {
    return defaultValue;
  }

  return attributeAttributeType
      .map((e) => attributeAttributeTypeFromJson(e.toString()))
      .toList();
}

String? attributeValidatorNullableToJson(
  enums.AttributeValidator? attributeValidator,
) {
  return attributeValidator?.value;
}

String? attributeValidatorToJson(enums.AttributeValidator attributeValidator) {
  return attributeValidator.value;
}

enums.AttributeValidator attributeValidatorFromJson(
  Object? attributeValidator, [
  enums.AttributeValidator? defaultValue,
]) {
  return enums.AttributeValidator.values.firstWhereOrNull(
        (e) => e.value == attributeValidator,
      ) ??
      defaultValue ??
      enums.AttributeValidator.swaggerGeneratedUnknown;
}

enums.AttributeValidator? attributeValidatorNullableFromJson(
  Object? attributeValidator, [
  enums.AttributeValidator? defaultValue,
]) {
  if (attributeValidator == null) {
    return null;
  }
  return enums.AttributeValidator.values.firstWhereOrNull(
        (e) => e.value == attributeValidator,
      ) ??
      defaultValue;
}

String attributeValidatorExplodedListToJson(
  List<enums.AttributeValidator>? attributeValidator,
) {
  return attributeValidator?.map((e) => e.value!).join(',') ?? '';
}

List<String> attributeValidatorListToJson(
  List<enums.AttributeValidator>? attributeValidator,
) {
  if (attributeValidator == null) {
    return [];
  }

  return attributeValidator.map((e) => e.value!).toList();
}

List<enums.AttributeValidator> attributeValidatorListFromJson(
  List? attributeValidator, [
  List<enums.AttributeValidator>? defaultValue,
]) {
  if (attributeValidator == null) {
    return defaultValue ?? [];
  }

  return attributeValidator
      .map((e) => attributeValidatorFromJson(e.toString()))
      .toList();
}

List<enums.AttributeValidator>? attributeValidatorNullableListFromJson(
  List? attributeValidator, [
  List<enums.AttributeValidator>? defaultValue,
]) {
  if (attributeValidator == null) {
    return defaultValue;
  }

  return attributeValidator
      .map((e) => attributeValidatorFromJson(e.toString()))
      .toList();
}

String? assetGroupInfoTargetNullableToJson(
  enums.AssetGroupInfoTarget? assetGroupInfoTarget,
) {
  return assetGroupInfoTarget?.value;
}

String? assetGroupInfoTargetToJson(
  enums.AssetGroupInfoTarget assetGroupInfoTarget,
) {
  return assetGroupInfoTarget.value;
}

enums.AssetGroupInfoTarget assetGroupInfoTargetFromJson(
  Object? assetGroupInfoTarget, [
  enums.AssetGroupInfoTarget? defaultValue,
]) {
  return enums.AssetGroupInfoTarget.values.firstWhereOrNull(
        (e) => e.value == assetGroupInfoTarget,
      ) ??
      defaultValue ??
      enums.AssetGroupInfoTarget.swaggerGeneratedUnknown;
}

enums.AssetGroupInfoTarget? assetGroupInfoTargetNullableFromJson(
  Object? assetGroupInfoTarget, [
  enums.AssetGroupInfoTarget? defaultValue,
]) {
  if (assetGroupInfoTarget == null) {
    return null;
  }
  return enums.AssetGroupInfoTarget.values.firstWhereOrNull(
        (e) => e.value == assetGroupInfoTarget,
      ) ??
      defaultValue;
}

String assetGroupInfoTargetExplodedListToJson(
  List<enums.AssetGroupInfoTarget>? assetGroupInfoTarget,
) {
  return assetGroupInfoTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> assetGroupInfoTargetListToJson(
  List<enums.AssetGroupInfoTarget>? assetGroupInfoTarget,
) {
  if (assetGroupInfoTarget == null) {
    return [];
  }

  return assetGroupInfoTarget.map((e) => e.value!).toList();
}

List<enums.AssetGroupInfoTarget> assetGroupInfoTargetListFromJson(
  List? assetGroupInfoTarget, [
  List<enums.AssetGroupInfoTarget>? defaultValue,
]) {
  if (assetGroupInfoTarget == null) {
    return defaultValue ?? [];
  }

  return assetGroupInfoTarget
      .map((e) => assetGroupInfoTargetFromJson(e.toString()))
      .toList();
}

List<enums.AssetGroupInfoTarget>? assetGroupInfoTargetNullableListFromJson(
  List? assetGroupInfoTarget, [
  List<enums.AssetGroupInfoTarget>? defaultValue,
]) {
  if (assetGroupInfoTarget == null) {
    return defaultValue;
  }

  return assetGroupInfoTarget
      .map((e) => assetGroupInfoTargetFromJson(e.toString()))
      .toList();
}

String? assetGroupTargetNullableToJson(
  enums.AssetGroupTarget? assetGroupTarget,
) {
  return assetGroupTarget?.value;
}

String? assetGroupTargetToJson(enums.AssetGroupTarget assetGroupTarget) {
  return assetGroupTarget.value;
}

enums.AssetGroupTarget assetGroupTargetFromJson(
  Object? assetGroupTarget, [
  enums.AssetGroupTarget? defaultValue,
]) {
  return enums.AssetGroupTarget.values.firstWhereOrNull(
        (e) => e.value == assetGroupTarget,
      ) ??
      defaultValue ??
      enums.AssetGroupTarget.swaggerGeneratedUnknown;
}

enums.AssetGroupTarget? assetGroupTargetNullableFromJson(
  Object? assetGroupTarget, [
  enums.AssetGroupTarget? defaultValue,
]) {
  if (assetGroupTarget == null) {
    return null;
  }
  return enums.AssetGroupTarget.values.firstWhereOrNull(
        (e) => e.value == assetGroupTarget,
      ) ??
      defaultValue;
}

String assetGroupTargetExplodedListToJson(
  List<enums.AssetGroupTarget>? assetGroupTarget,
) {
  return assetGroupTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> assetGroupTargetListToJson(
  List<enums.AssetGroupTarget>? assetGroupTarget,
) {
  if (assetGroupTarget == null) {
    return [];
  }

  return assetGroupTarget.map((e) => e.value!).toList();
}

List<enums.AssetGroupTarget> assetGroupTargetListFromJson(
  List? assetGroupTarget, [
  List<enums.AssetGroupTarget>? defaultValue,
]) {
  if (assetGroupTarget == null) {
    return defaultValue ?? [];
  }

  return assetGroupTarget
      .map((e) => assetGroupTargetFromJson(e.toString()))
      .toList();
}

List<enums.AssetGroupTarget>? assetGroupTargetNullableListFromJson(
  List? assetGroupTarget, [
  List<enums.AssetGroupTarget>? defaultValue,
]) {
  if (assetGroupTarget == null) {
    return defaultValue;
  }

  return assetGroupTarget
      .map((e) => assetGroupTargetFromJson(e.toString()))
      .toList();
}

String? reportInfoTargetNullableToJson(
  enums.ReportInfoTarget? reportInfoTarget,
) {
  return reportInfoTarget?.value;
}

String? reportInfoTargetToJson(enums.ReportInfoTarget reportInfoTarget) {
  return reportInfoTarget.value;
}

enums.ReportInfoTarget reportInfoTargetFromJson(
  Object? reportInfoTarget, [
  enums.ReportInfoTarget? defaultValue,
]) {
  return enums.ReportInfoTarget.values.firstWhereOrNull(
        (e) => e.value == reportInfoTarget,
      ) ??
      defaultValue ??
      enums.ReportInfoTarget.swaggerGeneratedUnknown;
}

enums.ReportInfoTarget? reportInfoTargetNullableFromJson(
  Object? reportInfoTarget, [
  enums.ReportInfoTarget? defaultValue,
]) {
  if (reportInfoTarget == null) {
    return null;
  }
  return enums.ReportInfoTarget.values.firstWhereOrNull(
        (e) => e.value == reportInfoTarget,
      ) ??
      defaultValue;
}

String reportInfoTargetExplodedListToJson(
  List<enums.ReportInfoTarget>? reportInfoTarget,
) {
  return reportInfoTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> reportInfoTargetListToJson(
  List<enums.ReportInfoTarget>? reportInfoTarget,
) {
  if (reportInfoTarget == null) {
    return [];
  }

  return reportInfoTarget.map((e) => e.value!).toList();
}

List<enums.ReportInfoTarget> reportInfoTargetListFromJson(
  List? reportInfoTarget, [
  List<enums.ReportInfoTarget>? defaultValue,
]) {
  if (reportInfoTarget == null) {
    return defaultValue ?? [];
  }

  return reportInfoTarget
      .map((e) => reportInfoTargetFromJson(e.toString()))
      .toList();
}

List<enums.ReportInfoTarget>? reportInfoTargetNullableListFromJson(
  List? reportInfoTarget, [
  List<enums.ReportInfoTarget>? defaultValue,
]) {
  if (reportInfoTarget == null) {
    return defaultValue;
  }

  return reportInfoTarget
      .map((e) => reportInfoTargetFromJson(e.toString()))
      .toList();
}

String? reportTargetNullableToJson(enums.ReportTarget? reportTarget) {
  return reportTarget?.value;
}

String? reportTargetToJson(enums.ReportTarget reportTarget) {
  return reportTarget.value;
}

enums.ReportTarget reportTargetFromJson(
  Object? reportTarget, [
  enums.ReportTarget? defaultValue,
]) {
  return enums.ReportTarget.values.firstWhereOrNull(
        (e) => e.value == reportTarget,
      ) ??
      defaultValue ??
      enums.ReportTarget.swaggerGeneratedUnknown;
}

enums.ReportTarget? reportTargetNullableFromJson(
  Object? reportTarget, [
  enums.ReportTarget? defaultValue,
]) {
  if (reportTarget == null) {
    return null;
  }
  return enums.ReportTarget.values.firstWhereOrNull(
        (e) => e.value == reportTarget,
      ) ??
      defaultValue;
}

String reportTargetExplodedListToJson(List<enums.ReportTarget>? reportTarget) {
  return reportTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> reportTargetListToJson(List<enums.ReportTarget>? reportTarget) {
  if (reportTarget == null) {
    return [];
  }

  return reportTarget.map((e) => e.value!).toList();
}

List<enums.ReportTarget> reportTargetListFromJson(
  List? reportTarget, [
  List<enums.ReportTarget>? defaultValue,
]) {
  if (reportTarget == null) {
    return defaultValue ?? [];
  }

  return reportTarget.map((e) => reportTargetFromJson(e.toString())).toList();
}

List<enums.ReportTarget>? reportTargetNullableListFromJson(
  List? reportTarget, [
  List<enums.ReportTarget>? defaultValue,
]) {
  if (reportTarget == null) {
    return defaultValue;
  }

  return reportTarget.map((e) => reportTargetFromJson(e.toString())).toList();
}

String? fieldFilterInfoFieldTypeNullableToJson(
  enums.FieldFilterInfoFieldType? fieldFilterInfoFieldType,
) {
  return fieldFilterInfoFieldType?.value;
}

String? fieldFilterInfoFieldTypeToJson(
  enums.FieldFilterInfoFieldType fieldFilterInfoFieldType,
) {
  return fieldFilterInfoFieldType.value;
}

enums.FieldFilterInfoFieldType fieldFilterInfoFieldTypeFromJson(
  Object? fieldFilterInfoFieldType, [
  enums.FieldFilterInfoFieldType? defaultValue,
]) {
  return enums.FieldFilterInfoFieldType.values.firstWhereOrNull(
        (e) => e.value == fieldFilterInfoFieldType,
      ) ??
      defaultValue ??
      enums.FieldFilterInfoFieldType.swaggerGeneratedUnknown;
}

enums.FieldFilterInfoFieldType? fieldFilterInfoFieldTypeNullableFromJson(
  Object? fieldFilterInfoFieldType, [
  enums.FieldFilterInfoFieldType? defaultValue,
]) {
  if (fieldFilterInfoFieldType == null) {
    return null;
  }
  return enums.FieldFilterInfoFieldType.values.firstWhereOrNull(
        (e) => e.value == fieldFilterInfoFieldType,
      ) ??
      defaultValue;
}

String fieldFilterInfoFieldTypeExplodedListToJson(
  List<enums.FieldFilterInfoFieldType>? fieldFilterInfoFieldType,
) {
  return fieldFilterInfoFieldType?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterInfoFieldTypeListToJson(
  List<enums.FieldFilterInfoFieldType>? fieldFilterInfoFieldType,
) {
  if (fieldFilterInfoFieldType == null) {
    return [];
  }

  return fieldFilterInfoFieldType.map((e) => e.value!).toList();
}

List<enums.FieldFilterInfoFieldType> fieldFilterInfoFieldTypeListFromJson(
  List? fieldFilterInfoFieldType, [
  List<enums.FieldFilterInfoFieldType>? defaultValue,
]) {
  if (fieldFilterInfoFieldType == null) {
    return defaultValue ?? [];
  }

  return fieldFilterInfoFieldType
      .map((e) => fieldFilterInfoFieldTypeFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterInfoFieldType>?
fieldFilterInfoFieldTypeNullableListFromJson(
  List? fieldFilterInfoFieldType, [
  List<enums.FieldFilterInfoFieldType>? defaultValue,
]) {
  if (fieldFilterInfoFieldType == null) {
    return defaultValue;
  }

  return fieldFilterInfoFieldType
      .map((e) => fieldFilterInfoFieldTypeFromJson(e.toString()))
      .toList();
}

String? fieldFilterInfoConditionNullableToJson(
  enums.FieldFilterInfoCondition? fieldFilterInfoCondition,
) {
  return fieldFilterInfoCondition?.value;
}

String? fieldFilterInfoConditionToJson(
  enums.FieldFilterInfoCondition fieldFilterInfoCondition,
) {
  return fieldFilterInfoCondition.value;
}

enums.FieldFilterInfoCondition fieldFilterInfoConditionFromJson(
  Object? fieldFilterInfoCondition, [
  enums.FieldFilterInfoCondition? defaultValue,
]) {
  return enums.FieldFilterInfoCondition.values.firstWhereOrNull(
        (e) => e.value == fieldFilterInfoCondition,
      ) ??
      defaultValue ??
      enums.FieldFilterInfoCondition.swaggerGeneratedUnknown;
}

enums.FieldFilterInfoCondition? fieldFilterInfoConditionNullableFromJson(
  Object? fieldFilterInfoCondition, [
  enums.FieldFilterInfoCondition? defaultValue,
]) {
  if (fieldFilterInfoCondition == null) {
    return null;
  }
  return enums.FieldFilterInfoCondition.values.firstWhereOrNull(
        (e) => e.value == fieldFilterInfoCondition,
      ) ??
      defaultValue;
}

String fieldFilterInfoConditionExplodedListToJson(
  List<enums.FieldFilterInfoCondition>? fieldFilterInfoCondition,
) {
  return fieldFilterInfoCondition?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterInfoConditionListToJson(
  List<enums.FieldFilterInfoCondition>? fieldFilterInfoCondition,
) {
  if (fieldFilterInfoCondition == null) {
    return [];
  }

  return fieldFilterInfoCondition.map((e) => e.value!).toList();
}

List<enums.FieldFilterInfoCondition> fieldFilterInfoConditionListFromJson(
  List? fieldFilterInfoCondition, [
  List<enums.FieldFilterInfoCondition>? defaultValue,
]) {
  if (fieldFilterInfoCondition == null) {
    return defaultValue ?? [];
  }

  return fieldFilterInfoCondition
      .map((e) => fieldFilterInfoConditionFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterInfoCondition>?
fieldFilterInfoConditionNullableListFromJson(
  List? fieldFilterInfoCondition, [
  List<enums.FieldFilterInfoCondition>? defaultValue,
]) {
  if (fieldFilterInfoCondition == null) {
    return defaultValue;
  }

  return fieldFilterInfoCondition
      .map((e) => fieldFilterInfoConditionFromJson(e.toString()))
      .toList();
}

String? fieldFilterInfoTargetNullableToJson(
  enums.FieldFilterInfoTarget? fieldFilterInfoTarget,
) {
  return fieldFilterInfoTarget?.value;
}

String? fieldFilterInfoTargetToJson(
  enums.FieldFilterInfoTarget fieldFilterInfoTarget,
) {
  return fieldFilterInfoTarget.value;
}

enums.FieldFilterInfoTarget fieldFilterInfoTargetFromJson(
  Object? fieldFilterInfoTarget, [
  enums.FieldFilterInfoTarget? defaultValue,
]) {
  return enums.FieldFilterInfoTarget.values.firstWhereOrNull(
        (e) => e.value == fieldFilterInfoTarget,
      ) ??
      defaultValue ??
      enums.FieldFilterInfoTarget.swaggerGeneratedUnknown;
}

enums.FieldFilterInfoTarget? fieldFilterInfoTargetNullableFromJson(
  Object? fieldFilterInfoTarget, [
  enums.FieldFilterInfoTarget? defaultValue,
]) {
  if (fieldFilterInfoTarget == null) {
    return null;
  }
  return enums.FieldFilterInfoTarget.values.firstWhereOrNull(
        (e) => e.value == fieldFilterInfoTarget,
      ) ??
      defaultValue;
}

String fieldFilterInfoTargetExplodedListToJson(
  List<enums.FieldFilterInfoTarget>? fieldFilterInfoTarget,
) {
  return fieldFilterInfoTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterInfoTargetListToJson(
  List<enums.FieldFilterInfoTarget>? fieldFilterInfoTarget,
) {
  if (fieldFilterInfoTarget == null) {
    return [];
  }

  return fieldFilterInfoTarget.map((e) => e.value!).toList();
}

List<enums.FieldFilterInfoTarget> fieldFilterInfoTargetListFromJson(
  List? fieldFilterInfoTarget, [
  List<enums.FieldFilterInfoTarget>? defaultValue,
]) {
  if (fieldFilterInfoTarget == null) {
    return defaultValue ?? [];
  }

  return fieldFilterInfoTarget
      .map((e) => fieldFilterInfoTargetFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterInfoTarget>? fieldFilterInfoTargetNullableListFromJson(
  List? fieldFilterInfoTarget, [
  List<enums.FieldFilterInfoTarget>? defaultValue,
]) {
  if (fieldFilterInfoTarget == null) {
    return defaultValue;
  }

  return fieldFilterInfoTarget
      .map((e) => fieldFilterInfoTargetFromJson(e.toString()))
      .toList();
}

String? fieldFilterFieldTypeNullableToJson(
  enums.FieldFilterFieldType? fieldFilterFieldType,
) {
  return fieldFilterFieldType?.value;
}

String? fieldFilterFieldTypeToJson(
  enums.FieldFilterFieldType fieldFilterFieldType,
) {
  return fieldFilterFieldType.value;
}

enums.FieldFilterFieldType fieldFilterFieldTypeFromJson(
  Object? fieldFilterFieldType, [
  enums.FieldFilterFieldType? defaultValue,
]) {
  return enums.FieldFilterFieldType.values.firstWhereOrNull(
        (e) => e.value == fieldFilterFieldType,
      ) ??
      defaultValue ??
      enums.FieldFilterFieldType.swaggerGeneratedUnknown;
}

enums.FieldFilterFieldType? fieldFilterFieldTypeNullableFromJson(
  Object? fieldFilterFieldType, [
  enums.FieldFilterFieldType? defaultValue,
]) {
  if (fieldFilterFieldType == null) {
    return null;
  }
  return enums.FieldFilterFieldType.values.firstWhereOrNull(
        (e) => e.value == fieldFilterFieldType,
      ) ??
      defaultValue;
}

String fieldFilterFieldTypeExplodedListToJson(
  List<enums.FieldFilterFieldType>? fieldFilterFieldType,
) {
  return fieldFilterFieldType?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterFieldTypeListToJson(
  List<enums.FieldFilterFieldType>? fieldFilterFieldType,
) {
  if (fieldFilterFieldType == null) {
    return [];
  }

  return fieldFilterFieldType.map((e) => e.value!).toList();
}

List<enums.FieldFilterFieldType> fieldFilterFieldTypeListFromJson(
  List? fieldFilterFieldType, [
  List<enums.FieldFilterFieldType>? defaultValue,
]) {
  if (fieldFilterFieldType == null) {
    return defaultValue ?? [];
  }

  return fieldFilterFieldType
      .map((e) => fieldFilterFieldTypeFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterFieldType>? fieldFilterFieldTypeNullableListFromJson(
  List? fieldFilterFieldType, [
  List<enums.FieldFilterFieldType>? defaultValue,
]) {
  if (fieldFilterFieldType == null) {
    return defaultValue;
  }

  return fieldFilterFieldType
      .map((e) => fieldFilterFieldTypeFromJson(e.toString()))
      .toList();
}

String? fieldFilterConditionNullableToJson(
  enums.FieldFilterCondition? fieldFilterCondition,
) {
  return fieldFilterCondition?.value;
}

String? fieldFilterConditionToJson(
  enums.FieldFilterCondition fieldFilterCondition,
) {
  return fieldFilterCondition.value;
}

enums.FieldFilterCondition fieldFilterConditionFromJson(
  Object? fieldFilterCondition, [
  enums.FieldFilterCondition? defaultValue,
]) {
  return enums.FieldFilterCondition.values.firstWhereOrNull(
        (e) => e.value == fieldFilterCondition,
      ) ??
      defaultValue ??
      enums.FieldFilterCondition.swaggerGeneratedUnknown;
}

enums.FieldFilterCondition? fieldFilterConditionNullableFromJson(
  Object? fieldFilterCondition, [
  enums.FieldFilterCondition? defaultValue,
]) {
  if (fieldFilterCondition == null) {
    return null;
  }
  return enums.FieldFilterCondition.values.firstWhereOrNull(
        (e) => e.value == fieldFilterCondition,
      ) ??
      defaultValue;
}

String fieldFilterConditionExplodedListToJson(
  List<enums.FieldFilterCondition>? fieldFilterCondition,
) {
  return fieldFilterCondition?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterConditionListToJson(
  List<enums.FieldFilterCondition>? fieldFilterCondition,
) {
  if (fieldFilterCondition == null) {
    return [];
  }

  return fieldFilterCondition.map((e) => e.value!).toList();
}

List<enums.FieldFilterCondition> fieldFilterConditionListFromJson(
  List? fieldFilterCondition, [
  List<enums.FieldFilterCondition>? defaultValue,
]) {
  if (fieldFilterCondition == null) {
    return defaultValue ?? [];
  }

  return fieldFilterCondition
      .map((e) => fieldFilterConditionFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterCondition>? fieldFilterConditionNullableListFromJson(
  List? fieldFilterCondition, [
  List<enums.FieldFilterCondition>? defaultValue,
]) {
  if (fieldFilterCondition == null) {
    return defaultValue;
  }

  return fieldFilterCondition
      .map((e) => fieldFilterConditionFromJson(e.toString()))
      .toList();
}

String? fieldFilterTargetNullableToJson(
  enums.FieldFilterTarget? fieldFilterTarget,
) {
  return fieldFilterTarget?.value;
}

String? fieldFilterTargetToJson(enums.FieldFilterTarget fieldFilterTarget) {
  return fieldFilterTarget.value;
}

enums.FieldFilterTarget fieldFilterTargetFromJson(
  Object? fieldFilterTarget, [
  enums.FieldFilterTarget? defaultValue,
]) {
  return enums.FieldFilterTarget.values.firstWhereOrNull(
        (e) => e.value == fieldFilterTarget,
      ) ??
      defaultValue ??
      enums.FieldFilterTarget.swaggerGeneratedUnknown;
}

enums.FieldFilterTarget? fieldFilterTargetNullableFromJson(
  Object? fieldFilterTarget, [
  enums.FieldFilterTarget? defaultValue,
]) {
  if (fieldFilterTarget == null) {
    return null;
  }
  return enums.FieldFilterTarget.values.firstWhereOrNull(
        (e) => e.value == fieldFilterTarget,
      ) ??
      defaultValue;
}

String fieldFilterTargetExplodedListToJson(
  List<enums.FieldFilterTarget>? fieldFilterTarget,
) {
  return fieldFilterTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterTargetListToJson(
  List<enums.FieldFilterTarget>? fieldFilterTarget,
) {
  if (fieldFilterTarget == null) {
    return [];
  }

  return fieldFilterTarget.map((e) => e.value!).toList();
}

List<enums.FieldFilterTarget> fieldFilterTargetListFromJson(
  List? fieldFilterTarget, [
  List<enums.FieldFilterTarget>? defaultValue,
]) {
  if (fieldFilterTarget == null) {
    return defaultValue ?? [];
  }

  return fieldFilterTarget
      .map((e) => fieldFilterTargetFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterTarget>? fieldFilterTargetNullableListFromJson(
  List? fieldFilterTarget, [
  List<enums.FieldFilterTarget>? defaultValue,
]) {
  if (fieldFilterTarget == null) {
    return defaultValue;
  }

  return fieldFilterTarget
      .map((e) => fieldFilterTargetFromJson(e.toString()))
      .toList();
}

String? customEntityFieldTypeNullableToJson(
  enums.CustomEntityFieldType? customEntityFieldType,
) {
  return customEntityFieldType?.value;
}

String? customEntityFieldTypeToJson(
  enums.CustomEntityFieldType customEntityFieldType,
) {
  return customEntityFieldType.value;
}

enums.CustomEntityFieldType customEntityFieldTypeFromJson(
  Object? customEntityFieldType, [
  enums.CustomEntityFieldType? defaultValue,
]) {
  return enums.CustomEntityFieldType.values.firstWhereOrNull(
        (e) => e.value == customEntityFieldType,
      ) ??
      defaultValue ??
      enums.CustomEntityFieldType.swaggerGeneratedUnknown;
}

enums.CustomEntityFieldType? customEntityFieldTypeNullableFromJson(
  Object? customEntityFieldType, [
  enums.CustomEntityFieldType? defaultValue,
]) {
  if (customEntityFieldType == null) {
    return null;
  }
  return enums.CustomEntityFieldType.values.firstWhereOrNull(
        (e) => e.value == customEntityFieldType,
      ) ??
      defaultValue;
}

String customEntityFieldTypeExplodedListToJson(
  List<enums.CustomEntityFieldType>? customEntityFieldType,
) {
  return customEntityFieldType?.map((e) => e.value!).join(',') ?? '';
}

List<String> customEntityFieldTypeListToJson(
  List<enums.CustomEntityFieldType>? customEntityFieldType,
) {
  if (customEntityFieldType == null) {
    return [];
  }

  return customEntityFieldType.map((e) => e.value!).toList();
}

List<enums.CustomEntityFieldType> customEntityFieldTypeListFromJson(
  List? customEntityFieldType, [
  List<enums.CustomEntityFieldType>? defaultValue,
]) {
  if (customEntityFieldType == null) {
    return defaultValue ?? [];
  }

  return customEntityFieldType
      .map((e) => customEntityFieldTypeFromJson(e.toString()))
      .toList();
}

List<enums.CustomEntityFieldType>? customEntityFieldTypeNullableListFromJson(
  List? customEntityFieldType, [
  List<enums.CustomEntityFieldType>? defaultValue,
]) {
  if (customEntityFieldType == null) {
    return defaultValue;
  }

  return customEntityFieldType
      .map((e) => customEntityFieldTypeFromJson(e.toString()))
      .toList();
}

String? apiTokenInfoRoleNullableToJson(
  enums.ApiTokenInfoRole? apiTokenInfoRole,
) {
  return apiTokenInfoRole?.value;
}

String? apiTokenInfoRoleToJson(enums.ApiTokenInfoRole apiTokenInfoRole) {
  return apiTokenInfoRole.value;
}

enums.ApiTokenInfoRole apiTokenInfoRoleFromJson(
  Object? apiTokenInfoRole, [
  enums.ApiTokenInfoRole? defaultValue,
]) {
  return enums.ApiTokenInfoRole.values.firstWhereOrNull(
        (e) => e.value == apiTokenInfoRole,
      ) ??
      defaultValue ??
      enums.ApiTokenInfoRole.swaggerGeneratedUnknown;
}

enums.ApiTokenInfoRole? apiTokenInfoRoleNullableFromJson(
  Object? apiTokenInfoRole, [
  enums.ApiTokenInfoRole? defaultValue,
]) {
  if (apiTokenInfoRole == null) {
    return null;
  }
  return enums.ApiTokenInfoRole.values.firstWhereOrNull(
        (e) => e.value == apiTokenInfoRole,
      ) ??
      defaultValue;
}

String apiTokenInfoRoleExplodedListToJson(
  List<enums.ApiTokenInfoRole>? apiTokenInfoRole,
) {
  return apiTokenInfoRole?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiTokenInfoRoleListToJson(
  List<enums.ApiTokenInfoRole>? apiTokenInfoRole,
) {
  if (apiTokenInfoRole == null) {
    return [];
  }

  return apiTokenInfoRole.map((e) => e.value!).toList();
}

List<enums.ApiTokenInfoRole> apiTokenInfoRoleListFromJson(
  List? apiTokenInfoRole, [
  List<enums.ApiTokenInfoRole>? defaultValue,
]) {
  if (apiTokenInfoRole == null) {
    return defaultValue ?? [];
  }

  return apiTokenInfoRole
      .map((e) => apiTokenInfoRoleFromJson(e.toString()))
      .toList();
}

List<enums.ApiTokenInfoRole>? apiTokenInfoRoleNullableListFromJson(
  List? apiTokenInfoRole, [
  List<enums.ApiTokenInfoRole>? defaultValue,
]) {
  if (apiTokenInfoRole == null) {
    return defaultValue;
  }

  return apiTokenInfoRole
      .map((e) => apiTokenInfoRoleFromJson(e.toString()))
      .toList();
}

String? apiTokenRoleNullableToJson(enums.ApiTokenRole? apiTokenRole) {
  return apiTokenRole?.value;
}

String? apiTokenRoleToJson(enums.ApiTokenRole apiTokenRole) {
  return apiTokenRole.value;
}

enums.ApiTokenRole apiTokenRoleFromJson(
  Object? apiTokenRole, [
  enums.ApiTokenRole? defaultValue,
]) {
  return enums.ApiTokenRole.values.firstWhereOrNull(
        (e) => e.value == apiTokenRole,
      ) ??
      defaultValue ??
      enums.ApiTokenRole.swaggerGeneratedUnknown;
}

enums.ApiTokenRole? apiTokenRoleNullableFromJson(
  Object? apiTokenRole, [
  enums.ApiTokenRole? defaultValue,
]) {
  if (apiTokenRole == null) {
    return null;
  }
  return enums.ApiTokenRole.values.firstWhereOrNull(
        (e) => e.value == apiTokenRole,
      ) ??
      defaultValue;
}

String apiTokenRoleExplodedListToJson(List<enums.ApiTokenRole>? apiTokenRole) {
  return apiTokenRole?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiTokenRoleListToJson(List<enums.ApiTokenRole>? apiTokenRole) {
  if (apiTokenRole == null) {
    return [];
  }

  return apiTokenRole.map((e) => e.value!).toList();
}

List<enums.ApiTokenRole> apiTokenRoleListFromJson(
  List? apiTokenRole, [
  List<enums.ApiTokenRole>? defaultValue,
]) {
  if (apiTokenRole == null) {
    return defaultValue ?? [];
  }

  return apiTokenRole.map((e) => apiTokenRoleFromJson(e.toString())).toList();
}

List<enums.ApiTokenRole>? apiTokenRoleNullableListFromJson(
  List? apiTokenRole, [
  List<enums.ApiTokenRole>? defaultValue,
]) {
  if (apiTokenRole == null) {
    return defaultValue;
  }

  return apiTokenRole.map((e) => apiTokenRoleFromJson(e.toString())).toList();
}

String? eqlTemplateInfoProtocolNullableToJson(
  enums.EqlTemplateInfoProtocol? eqlTemplateInfoProtocol,
) {
  return eqlTemplateInfoProtocol?.value;
}

String? eqlTemplateInfoProtocolToJson(
  enums.EqlTemplateInfoProtocol eqlTemplateInfoProtocol,
) {
  return eqlTemplateInfoProtocol.value;
}

enums.EqlTemplateInfoProtocol eqlTemplateInfoProtocolFromJson(
  Object? eqlTemplateInfoProtocol, [
  enums.EqlTemplateInfoProtocol? defaultValue,
]) {
  return enums.EqlTemplateInfoProtocol.values.firstWhereOrNull(
        (e) => e.value == eqlTemplateInfoProtocol,
      ) ??
      defaultValue ??
      enums.EqlTemplateInfoProtocol.swaggerGeneratedUnknown;
}

enums.EqlTemplateInfoProtocol? eqlTemplateInfoProtocolNullableFromJson(
  Object? eqlTemplateInfoProtocol, [
  enums.EqlTemplateInfoProtocol? defaultValue,
]) {
  if (eqlTemplateInfoProtocol == null) {
    return null;
  }
  return enums.EqlTemplateInfoProtocol.values.firstWhereOrNull(
        (e) => e.value == eqlTemplateInfoProtocol,
      ) ??
      defaultValue;
}

String eqlTemplateInfoProtocolExplodedListToJson(
  List<enums.EqlTemplateInfoProtocol>? eqlTemplateInfoProtocol,
) {
  return eqlTemplateInfoProtocol?.map((e) => e.value!).join(',') ?? '';
}

List<String> eqlTemplateInfoProtocolListToJson(
  List<enums.EqlTemplateInfoProtocol>? eqlTemplateInfoProtocol,
) {
  if (eqlTemplateInfoProtocol == null) {
    return [];
  }

  return eqlTemplateInfoProtocol.map((e) => e.value!).toList();
}

List<enums.EqlTemplateInfoProtocol> eqlTemplateInfoProtocolListFromJson(
  List? eqlTemplateInfoProtocol, [
  List<enums.EqlTemplateInfoProtocol>? defaultValue,
]) {
  if (eqlTemplateInfoProtocol == null) {
    return defaultValue ?? [];
  }

  return eqlTemplateInfoProtocol
      .map((e) => eqlTemplateInfoProtocolFromJson(e.toString()))
      .toList();
}

List<enums.EqlTemplateInfoProtocol>?
eqlTemplateInfoProtocolNullableListFromJson(
  List? eqlTemplateInfoProtocol, [
  List<enums.EqlTemplateInfoProtocol>? defaultValue,
]) {
  if (eqlTemplateInfoProtocol == null) {
    return defaultValue;
  }

  return eqlTemplateInfoProtocol
      .map((e) => eqlTemplateInfoProtocolFromJson(e.toString()))
      .toList();
}

String? eqlTemplateProtocolNullableToJson(
  enums.EqlTemplateProtocol? eqlTemplateProtocol,
) {
  return eqlTemplateProtocol?.value;
}

String? eqlTemplateProtocolToJson(
  enums.EqlTemplateProtocol eqlTemplateProtocol,
) {
  return eqlTemplateProtocol.value;
}

enums.EqlTemplateProtocol eqlTemplateProtocolFromJson(
  Object? eqlTemplateProtocol, [
  enums.EqlTemplateProtocol? defaultValue,
]) {
  return enums.EqlTemplateProtocol.values.firstWhereOrNull(
        (e) => e.value == eqlTemplateProtocol,
      ) ??
      defaultValue ??
      enums.EqlTemplateProtocol.swaggerGeneratedUnknown;
}

enums.EqlTemplateProtocol? eqlTemplateProtocolNullableFromJson(
  Object? eqlTemplateProtocol, [
  enums.EqlTemplateProtocol? defaultValue,
]) {
  if (eqlTemplateProtocol == null) {
    return null;
  }
  return enums.EqlTemplateProtocol.values.firstWhereOrNull(
        (e) => e.value == eqlTemplateProtocol,
      ) ??
      defaultValue;
}

String eqlTemplateProtocolExplodedListToJson(
  List<enums.EqlTemplateProtocol>? eqlTemplateProtocol,
) {
  return eqlTemplateProtocol?.map((e) => e.value!).join(',') ?? '';
}

List<String> eqlTemplateProtocolListToJson(
  List<enums.EqlTemplateProtocol>? eqlTemplateProtocol,
) {
  if (eqlTemplateProtocol == null) {
    return [];
  }

  return eqlTemplateProtocol.map((e) => e.value!).toList();
}

List<enums.EqlTemplateProtocol> eqlTemplateProtocolListFromJson(
  List? eqlTemplateProtocol, [
  List<enums.EqlTemplateProtocol>? defaultValue,
]) {
  if (eqlTemplateProtocol == null) {
    return defaultValue ?? [];
  }

  return eqlTemplateProtocol
      .map((e) => eqlTemplateProtocolFromJson(e.toString()))
      .toList();
}

List<enums.EqlTemplateProtocol>? eqlTemplateProtocolNullableListFromJson(
  List? eqlTemplateProtocol, [
  List<enums.EqlTemplateProtocol>? defaultValue,
]) {
  if (eqlTemplateProtocol == null) {
    return defaultValue;
  }

  return eqlTemplateProtocol
      .map((e) => eqlTemplateProtocolFromJson(e.toString()))
      .toList();
}

String? ioTTwinTagsGetEntityTypeGetEntityTypeNullableToJson(
  enums.IoTTwinTagsGetEntityTypeGetEntityType?
  ioTTwinTagsGetEntityTypeGetEntityType,
) {
  return ioTTwinTagsGetEntityTypeGetEntityType?.value;
}

String? ioTTwinTagsGetEntityTypeGetEntityTypeToJson(
  enums.IoTTwinTagsGetEntityTypeGetEntityType
  ioTTwinTagsGetEntityTypeGetEntityType,
) {
  return ioTTwinTagsGetEntityTypeGetEntityType.value;
}

enums.IoTTwinTagsGetEntityTypeGetEntityType
ioTTwinTagsGetEntityTypeGetEntityTypeFromJson(
  Object? ioTTwinTagsGetEntityTypeGetEntityType, [
  enums.IoTTwinTagsGetEntityTypeGetEntityType? defaultValue,
]) {
  return enums.IoTTwinTagsGetEntityTypeGetEntityType.values.firstWhereOrNull(
        (e) => e.value == ioTTwinTagsGetEntityTypeGetEntityType,
      ) ??
      defaultValue ??
      enums.IoTTwinTagsGetEntityTypeGetEntityType.swaggerGeneratedUnknown;
}

enums.IoTTwinTagsGetEntityTypeGetEntityType?
ioTTwinTagsGetEntityTypeGetEntityTypeNullableFromJson(
  Object? ioTTwinTagsGetEntityTypeGetEntityType, [
  enums.IoTTwinTagsGetEntityTypeGetEntityType? defaultValue,
]) {
  if (ioTTwinTagsGetEntityTypeGetEntityType == null) {
    return null;
  }
  return enums.IoTTwinTagsGetEntityTypeGetEntityType.values.firstWhereOrNull(
        (e) => e.value == ioTTwinTagsGetEntityTypeGetEntityType,
      ) ??
      defaultValue;
}

String ioTTwinTagsGetEntityTypeGetEntityTypeExplodedListToJson(
  List<enums.IoTTwinTagsGetEntityTypeGetEntityType>?
  ioTTwinTagsGetEntityTypeGetEntityType,
) {
  return ioTTwinTagsGetEntityTypeGetEntityType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> ioTTwinTagsGetEntityTypeGetEntityTypeListToJson(
  List<enums.IoTTwinTagsGetEntityTypeGetEntityType>?
  ioTTwinTagsGetEntityTypeGetEntityType,
) {
  if (ioTTwinTagsGetEntityTypeGetEntityType == null) {
    return [];
  }

  return ioTTwinTagsGetEntityTypeGetEntityType.map((e) => e.value!).toList();
}

List<enums.IoTTwinTagsGetEntityTypeGetEntityType>
ioTTwinTagsGetEntityTypeGetEntityTypeListFromJson(
  List? ioTTwinTagsGetEntityTypeGetEntityType, [
  List<enums.IoTTwinTagsGetEntityTypeGetEntityType>? defaultValue,
]) {
  if (ioTTwinTagsGetEntityTypeGetEntityType == null) {
    return defaultValue ?? [];
  }

  return ioTTwinTagsGetEntityTypeGetEntityType
      .map((e) => ioTTwinTagsGetEntityTypeGetEntityTypeFromJson(e.toString()))
      .toList();
}

List<enums.IoTTwinTagsGetEntityTypeGetEntityType>?
ioTTwinTagsGetEntityTypeGetEntityTypeNullableListFromJson(
  List? ioTTwinTagsGetEntityTypeGetEntityType, [
  List<enums.IoTTwinTagsGetEntityTypeGetEntityType>? defaultValue,
]) {
  if (ioTTwinTagsGetEntityTypeGetEntityType == null) {
    return defaultValue;
  }

  return ioTTwinTagsGetEntityTypeGetEntityType
      .map((e) => ioTTwinTagsGetEntityTypeGetEntityTypeFromJson(e.toString()))
      .toList();
}

String? deviceDataTrendsDeviceIdFieldGetFilterNullableToJson(
  enums.DeviceDataTrendsDeviceIdFieldGetFilter?
  deviceDataTrendsDeviceIdFieldGetFilter,
) {
  return deviceDataTrendsDeviceIdFieldGetFilter?.value;
}

String? deviceDataTrendsDeviceIdFieldGetFilterToJson(
  enums.DeviceDataTrendsDeviceIdFieldGetFilter
  deviceDataTrendsDeviceIdFieldGetFilter,
) {
  return deviceDataTrendsDeviceIdFieldGetFilter.value;
}

enums.DeviceDataTrendsDeviceIdFieldGetFilter
deviceDataTrendsDeviceIdFieldGetFilterFromJson(
  Object? deviceDataTrendsDeviceIdFieldGetFilter, [
  enums.DeviceDataTrendsDeviceIdFieldGetFilter? defaultValue,
]) {
  return enums.DeviceDataTrendsDeviceIdFieldGetFilter.values.firstWhereOrNull(
        (e) => e.value == deviceDataTrendsDeviceIdFieldGetFilter,
      ) ??
      defaultValue ??
      enums.DeviceDataTrendsDeviceIdFieldGetFilter.swaggerGeneratedUnknown;
}

enums.DeviceDataTrendsDeviceIdFieldGetFilter?
deviceDataTrendsDeviceIdFieldGetFilterNullableFromJson(
  Object? deviceDataTrendsDeviceIdFieldGetFilter, [
  enums.DeviceDataTrendsDeviceIdFieldGetFilter? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetFilter == null) {
    return null;
  }
  return enums.DeviceDataTrendsDeviceIdFieldGetFilter.values.firstWhereOrNull(
        (e) => e.value == deviceDataTrendsDeviceIdFieldGetFilter,
      ) ??
      defaultValue;
}

String deviceDataTrendsDeviceIdFieldGetFilterExplodedListToJson(
  List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>?
  deviceDataTrendsDeviceIdFieldGetFilter,
) {
  return deviceDataTrendsDeviceIdFieldGetFilter
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> deviceDataTrendsDeviceIdFieldGetFilterListToJson(
  List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>?
  deviceDataTrendsDeviceIdFieldGetFilter,
) {
  if (deviceDataTrendsDeviceIdFieldGetFilter == null) {
    return [];
  }

  return deviceDataTrendsDeviceIdFieldGetFilter.map((e) => e.value!).toList();
}

List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>
deviceDataTrendsDeviceIdFieldGetFilterListFromJson(
  List? deviceDataTrendsDeviceIdFieldGetFilter, [
  List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetFilter == null) {
    return defaultValue ?? [];
  }

  return deviceDataTrendsDeviceIdFieldGetFilter
      .map((e) => deviceDataTrendsDeviceIdFieldGetFilterFromJson(e.toString()))
      .toList();
}

List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>?
deviceDataTrendsDeviceIdFieldGetFilterNullableListFromJson(
  List? deviceDataTrendsDeviceIdFieldGetFilter, [
  List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetFilter == null) {
    return defaultValue;
  }

  return deviceDataTrendsDeviceIdFieldGetFilter
      .map((e) => deviceDataTrendsDeviceIdFieldGetFilterFromJson(e.toString()))
      .toList();
}

String? deviceDataTrendsDeviceIdFieldGetIntervalNullableToJson(
  enums.DeviceDataTrendsDeviceIdFieldGetInterval?
  deviceDataTrendsDeviceIdFieldGetInterval,
) {
  return deviceDataTrendsDeviceIdFieldGetInterval?.value;
}

String? deviceDataTrendsDeviceIdFieldGetIntervalToJson(
  enums.DeviceDataTrendsDeviceIdFieldGetInterval
  deviceDataTrendsDeviceIdFieldGetInterval,
) {
  return deviceDataTrendsDeviceIdFieldGetInterval.value;
}

enums.DeviceDataTrendsDeviceIdFieldGetInterval
deviceDataTrendsDeviceIdFieldGetIntervalFromJson(
  Object? deviceDataTrendsDeviceIdFieldGetInterval, [
  enums.DeviceDataTrendsDeviceIdFieldGetInterval? defaultValue,
]) {
  return enums.DeviceDataTrendsDeviceIdFieldGetInterval.values.firstWhereOrNull(
        (e) => e.value == deviceDataTrendsDeviceIdFieldGetInterval,
      ) ??
      defaultValue ??
      enums.DeviceDataTrendsDeviceIdFieldGetInterval.swaggerGeneratedUnknown;
}

enums.DeviceDataTrendsDeviceIdFieldGetInterval?
deviceDataTrendsDeviceIdFieldGetIntervalNullableFromJson(
  Object? deviceDataTrendsDeviceIdFieldGetInterval, [
  enums.DeviceDataTrendsDeviceIdFieldGetInterval? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetInterval == null) {
    return null;
  }
  return enums.DeviceDataTrendsDeviceIdFieldGetInterval.values.firstWhereOrNull(
        (e) => e.value == deviceDataTrendsDeviceIdFieldGetInterval,
      ) ??
      defaultValue;
}

String deviceDataTrendsDeviceIdFieldGetIntervalExplodedListToJson(
  List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>?
  deviceDataTrendsDeviceIdFieldGetInterval,
) {
  return deviceDataTrendsDeviceIdFieldGetInterval
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> deviceDataTrendsDeviceIdFieldGetIntervalListToJson(
  List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>?
  deviceDataTrendsDeviceIdFieldGetInterval,
) {
  if (deviceDataTrendsDeviceIdFieldGetInterval == null) {
    return [];
  }

  return deviceDataTrendsDeviceIdFieldGetInterval.map((e) => e.value!).toList();
}

List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>
deviceDataTrendsDeviceIdFieldGetIntervalListFromJson(
  List? deviceDataTrendsDeviceIdFieldGetInterval, [
  List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetInterval == null) {
    return defaultValue ?? [];
  }

  return deviceDataTrendsDeviceIdFieldGetInterval
      .map(
        (e) => deviceDataTrendsDeviceIdFieldGetIntervalFromJson(e.toString()),
      )
      .toList();
}

List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>?
deviceDataTrendsDeviceIdFieldGetIntervalNullableListFromJson(
  List? deviceDataTrendsDeviceIdFieldGetInterval, [
  List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetInterval == null) {
    return defaultValue;
  }

  return deviceDataTrendsDeviceIdFieldGetInterval
      .map(
        (e) => deviceDataTrendsDeviceIdFieldGetIntervalFromJson(e.toString()),
      )
      .toList();
}

String? deviceDataSeriesDeviceIdFieldPageSizeGetFilterNullableToJson(
  enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter?
  deviceDataSeriesDeviceIdFieldPageSizeGetFilter,
) {
  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter?.value;
}

String? deviceDataSeriesDeviceIdFieldPageSizeGetFilterToJson(
  enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter
  deviceDataSeriesDeviceIdFieldPageSizeGetFilter,
) {
  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter.value;
}

enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter
deviceDataSeriesDeviceIdFieldPageSizeGetFilterFromJson(
  Object? deviceDataSeriesDeviceIdFieldPageSizeGetFilter, [
  enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter? defaultValue,
]) {
  return enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter.values
          .firstWhereOrNull(
            (e) => e.value == deviceDataSeriesDeviceIdFieldPageSizeGetFilter,
          ) ??
      defaultValue ??
      enums
          .DeviceDataSeriesDeviceIdFieldPageSizeGetFilter
          .swaggerGeneratedUnknown;
}

enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter?
deviceDataSeriesDeviceIdFieldPageSizeGetFilterNullableFromJson(
  Object? deviceDataSeriesDeviceIdFieldPageSizeGetFilter, [
  enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter? defaultValue,
]) {
  if (deviceDataSeriesDeviceIdFieldPageSizeGetFilter == null) {
    return null;
  }
  return enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter.values
          .firstWhereOrNull(
            (e) => e.value == deviceDataSeriesDeviceIdFieldPageSizeGetFilter,
          ) ??
      defaultValue;
}

String deviceDataSeriesDeviceIdFieldPageSizeGetFilterExplodedListToJson(
  List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>?
  deviceDataSeriesDeviceIdFieldPageSizeGetFilter,
) {
  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> deviceDataSeriesDeviceIdFieldPageSizeGetFilterListToJson(
  List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>?
  deviceDataSeriesDeviceIdFieldPageSizeGetFilter,
) {
  if (deviceDataSeriesDeviceIdFieldPageSizeGetFilter == null) {
    return [];
  }

  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter
      .map((e) => e.value!)
      .toList();
}

List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>
deviceDataSeriesDeviceIdFieldPageSizeGetFilterListFromJson(
  List? deviceDataSeriesDeviceIdFieldPageSizeGetFilter, [
  List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>? defaultValue,
]) {
  if (deviceDataSeriesDeviceIdFieldPageSizeGetFilter == null) {
    return defaultValue ?? [];
  }

  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter
      .map(
        (e) => deviceDataSeriesDeviceIdFieldPageSizeGetFilterFromJson(
          e.toString(),
        ),
      )
      .toList();
}

List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>?
deviceDataSeriesDeviceIdFieldPageSizeGetFilterNullableListFromJson(
  List? deviceDataSeriesDeviceIdFieldPageSizeGetFilter, [
  List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>? defaultValue,
]) {
  if (deviceDataSeriesDeviceIdFieldPageSizeGetFilter == null) {
    return defaultValue;
  }

  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter
      .map(
        (e) => deviceDataSeriesDeviceIdFieldPageSizeGetFilterFromJson(
          e.toString(),
        ),
      )
      .toList();
}

String? screenWidgetListTargetPostTargetNullableToJson(
  enums.ScreenWidgetListTargetPostTarget? screenWidgetListTargetPostTarget,
) {
  return screenWidgetListTargetPostTarget?.value;
}

String? screenWidgetListTargetPostTargetToJson(
  enums.ScreenWidgetListTargetPostTarget screenWidgetListTargetPostTarget,
) {
  return screenWidgetListTargetPostTarget.value;
}

enums.ScreenWidgetListTargetPostTarget screenWidgetListTargetPostTargetFromJson(
  Object? screenWidgetListTargetPostTarget, [
  enums.ScreenWidgetListTargetPostTarget? defaultValue,
]) {
  return enums.ScreenWidgetListTargetPostTarget.values.firstWhereOrNull(
        (e) => e.value == screenWidgetListTargetPostTarget,
      ) ??
      defaultValue ??
      enums.ScreenWidgetListTargetPostTarget.swaggerGeneratedUnknown;
}

enums.ScreenWidgetListTargetPostTarget?
screenWidgetListTargetPostTargetNullableFromJson(
  Object? screenWidgetListTargetPostTarget, [
  enums.ScreenWidgetListTargetPostTarget? defaultValue,
]) {
  if (screenWidgetListTargetPostTarget == null) {
    return null;
  }
  return enums.ScreenWidgetListTargetPostTarget.values.firstWhereOrNull(
        (e) => e.value == screenWidgetListTargetPostTarget,
      ) ??
      defaultValue;
}

String screenWidgetListTargetPostTargetExplodedListToJson(
  List<enums.ScreenWidgetListTargetPostTarget>?
  screenWidgetListTargetPostTarget,
) {
  return screenWidgetListTargetPostTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> screenWidgetListTargetPostTargetListToJson(
  List<enums.ScreenWidgetListTargetPostTarget>?
  screenWidgetListTargetPostTarget,
) {
  if (screenWidgetListTargetPostTarget == null) {
    return [];
  }

  return screenWidgetListTargetPostTarget.map((e) => e.value!).toList();
}

List<enums.ScreenWidgetListTargetPostTarget>
screenWidgetListTargetPostTargetListFromJson(
  List? screenWidgetListTargetPostTarget, [
  List<enums.ScreenWidgetListTargetPostTarget>? defaultValue,
]) {
  if (screenWidgetListTargetPostTarget == null) {
    return defaultValue ?? [];
  }

  return screenWidgetListTargetPostTarget
      .map((e) => screenWidgetListTargetPostTargetFromJson(e.toString()))
      .toList();
}

List<enums.ScreenWidgetListTargetPostTarget>?
screenWidgetListTargetPostTargetNullableListFromJson(
  List? screenWidgetListTargetPostTarget, [
  List<enums.ScreenWidgetListTargetPostTarget>? defaultValue,
]) {
  if (screenWidgetListTargetPostTarget == null) {
    return defaultValue;
  }

  return screenWidgetListTargetPostTarget
      .map((e) => screenWidgetListTargetPostTargetFromJson(e.toString()))
      .toList();
}

String? screenWidgetSearchTargetPostTargetNullableToJson(
  enums.ScreenWidgetSearchTargetPostTarget? screenWidgetSearchTargetPostTarget,
) {
  return screenWidgetSearchTargetPostTarget?.value;
}

String? screenWidgetSearchTargetPostTargetToJson(
  enums.ScreenWidgetSearchTargetPostTarget screenWidgetSearchTargetPostTarget,
) {
  return screenWidgetSearchTargetPostTarget.value;
}

enums.ScreenWidgetSearchTargetPostTarget
screenWidgetSearchTargetPostTargetFromJson(
  Object? screenWidgetSearchTargetPostTarget, [
  enums.ScreenWidgetSearchTargetPostTarget? defaultValue,
]) {
  return enums.ScreenWidgetSearchTargetPostTarget.values.firstWhereOrNull(
        (e) => e.value == screenWidgetSearchTargetPostTarget,
      ) ??
      defaultValue ??
      enums.ScreenWidgetSearchTargetPostTarget.swaggerGeneratedUnknown;
}

enums.ScreenWidgetSearchTargetPostTarget?
screenWidgetSearchTargetPostTargetNullableFromJson(
  Object? screenWidgetSearchTargetPostTarget, [
  enums.ScreenWidgetSearchTargetPostTarget? defaultValue,
]) {
  if (screenWidgetSearchTargetPostTarget == null) {
    return null;
  }
  return enums.ScreenWidgetSearchTargetPostTarget.values.firstWhereOrNull(
        (e) => e.value == screenWidgetSearchTargetPostTarget,
      ) ??
      defaultValue;
}

String screenWidgetSearchTargetPostTargetExplodedListToJson(
  List<enums.ScreenWidgetSearchTargetPostTarget>?
  screenWidgetSearchTargetPostTarget,
) {
  return screenWidgetSearchTargetPostTarget?.map((e) => e.value!).join(',') ??
      '';
}

List<String> screenWidgetSearchTargetPostTargetListToJson(
  List<enums.ScreenWidgetSearchTargetPostTarget>?
  screenWidgetSearchTargetPostTarget,
) {
  if (screenWidgetSearchTargetPostTarget == null) {
    return [];
  }

  return screenWidgetSearchTargetPostTarget.map((e) => e.value!).toList();
}

List<enums.ScreenWidgetSearchTargetPostTarget>
screenWidgetSearchTargetPostTargetListFromJson(
  List? screenWidgetSearchTargetPostTarget, [
  List<enums.ScreenWidgetSearchTargetPostTarget>? defaultValue,
]) {
  if (screenWidgetSearchTargetPostTarget == null) {
    return defaultValue ?? [];
  }

  return screenWidgetSearchTargetPostTarget
      .map((e) => screenWidgetSearchTargetPostTargetFromJson(e.toString()))
      .toList();
}

List<enums.ScreenWidgetSearchTargetPostTarget>?
screenWidgetSearchTargetPostTargetNullableListFromJson(
  List? screenWidgetSearchTargetPostTarget, [
  List<enums.ScreenWidgetSearchTargetPostTarget>? defaultValue,
]) {
  if (screenWidgetSearchTargetPostTarget == null) {
    return defaultValue;
  }

  return screenWidgetSearchTargetPostTarget
      .map((e) => screenWidgetSearchTargetPostTargetFromJson(e.toString()))
      .toList();
}

typedef $JsonFactory<T> = T Function(Map<String, dynamic> json);

class $CustomJsonDecoder {
  $CustomJsonDecoder(this.factories);

  final Map<Type, $JsonFactory> factories;

  dynamic decode<T>(dynamic entity) {
    if (entity is Iterable) {
      return _decodeList<T>(entity);
    }

    if (entity is T) {
      return entity;
    }

    if (isTypeOf<T, Map>()) {
      return entity;
    }

    if (isTypeOf<T, Iterable>()) {
      return entity;
    }

    if (entity is Map<String, dynamic>) {
      return _decodeMap<T>(entity);
    }

    return entity;
  }

  T _decodeMap<T>(Map<String, dynamic> values) {
    final jsonFactory = factories[T];
    if (jsonFactory == null || jsonFactory is! $JsonFactory<T>) {
      return throw "Could not find factory for type $T. Is '$T: $T.fromJsonFactory' included in the CustomJsonDecoder instance creation in bootstrapper.dart?";
    }

    return jsonFactory(values);
  }

  List<T> _decodeList<T>(Iterable values) =>
      values.where((v) => v != null).map<T>((v) => decode<T>(v) as T).toList();
}

class $JsonSerializableConverter extends chopper.JsonConverter {
  @override
  FutureOr<chopper.Response<ResultType>> convertResponse<ResultType, Item>(
    chopper.Response response,
  ) async {
    if (response.bodyString.isEmpty) {
      // In rare cases, when let's say 204 (no content) is returned -
      // we cannot decode the missing json with the result type specified
      return chopper.Response(response.base, null, error: response.error);
    }

    if (ResultType == String) {
      return response.copyWith();
    }

    if (ResultType == DateTime) {
      return response.copyWith(
        body:
            DateTime.parse((response.body as String).replaceAll('"', ''))
                as ResultType,
      );
    }

    final jsonRes = await super.convertResponse(response);
    return jsonRes.copyWith<ResultType>(
      body: $jsonDecoder.decode<Item>(jsonRes.body) as ResultType,
    );
  }
}

final $jsonDecoder = $CustomJsonDecoder(generatedMapping);

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
